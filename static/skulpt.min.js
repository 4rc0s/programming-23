;(function() {
  /*
 https://mths.be/fromcodepoint v0.2.1 by @mathias */
  "use strict"
  var $jscomp = $jscomp || {}
  $jscomp.scope = {}
  $jscomp.arrayIteratorImpl = function(m) {
    var p = 0
    return function() {
      return p < m.length ? { done: !1, value: m[p++] } : { done: !0 }
    }
  }
  $jscomp.arrayIterator = function(m) {
    return { next: $jscomp.arrayIteratorImpl(m) }
  }
  $jscomp.ASSUME_ES5 = !1
  $jscomp.ASSUME_NO_NATIVE_MAP = !1
  $jscomp.ASSUME_NO_NATIVE_SET = !1
  $jscomp.SIMPLE_FROUND_POLYFILL = !1
  $jscomp.defineProperty =
    $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties
      ? Object.defineProperty
      : function(m, p, a) {
          m != Array.prototype && m != Object.prototype && (m[p] = a.value)
        }
  $jscomp.getGlobal = function(m) {
    return "undefined" != typeof window && window === m
      ? m
      : "undefined" != typeof global && null != global
      ? global
      : m
  }
  $jscomp.global = $jscomp.getGlobal(this)
  $jscomp.SYMBOL_PREFIX = "jscomp_symbol_"
  $jscomp.initSymbol = function() {
    $jscomp.initSymbol = function() {}
    $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol)
  }
  $jscomp.SymbolClass = function(m, p) {
    this.$jscomp$symbol$id_ = m
    $jscomp.defineProperty(this, "description", {
      configurable: !0,
      writable: !0,
      value: p,
    })
  }
  $jscomp.SymbolClass.prototype.toString = function() {
    return this.$jscomp$symbol$id_
  }
  $jscomp.Symbol = (function() {
    function m(a) {
      if (this instanceof m) throw new TypeError("Symbol is not a constructor")
      return new $jscomp.SymbolClass(
        $jscomp.SYMBOL_PREFIX + (a || "") + "_" + p++,
        a,
      )
    }
    var p = 0
    return m
  })()
  $jscomp.initSymbolIterator = function() {
    $jscomp.initSymbol()
    var m = $jscomp.global.Symbol.iterator
    m ||
      (m = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol(
        "Symbol.iterator",
      ))
    "function" != typeof Array.prototype[m] &&
      $jscomp.defineProperty(Array.prototype, m, {
        configurable: !0,
        writable: !0,
        value: function() {
          return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this))
        },
      })
    $jscomp.initSymbolIterator = function() {}
  }
  $jscomp.initSymbolAsyncIterator = function() {
    $jscomp.initSymbol()
    var m = $jscomp.global.Symbol.asyncIterator
    m ||
      (m = $jscomp.global.Symbol.asyncIterator = $jscomp.global.Symbol(
        "Symbol.asyncIterator",
      ))
    $jscomp.initSymbolAsyncIterator = function() {}
  }
  $jscomp.iteratorPrototype = function(m) {
    $jscomp.initSymbolIterator()
    m = { next: m }
    m[$jscomp.global.Symbol.iterator] = function() {
      return this
    }
    return m
  }
  $jscomp.iteratorFromArray = function(m, p) {
    $jscomp.initSymbolIterator()
    m instanceof String && (m += "")
    var a = 0,
      b = {
        next: function() {
          if (a < m.length) {
            var c = a++
            return { value: p(c, m[c]), done: !1 }
          }
          b.next = function() {
            return { done: !0, value: void 0 }
          }
          return b.next()
        },
      }
    b[Symbol.iterator] = function() {
      return b
    }
    return b
  }
  $jscomp.polyfill = function(m, p, a, b) {
    if (p) {
      a = $jscomp.global
      m = m.split(".")
      for (b = 0; b < m.length - 1; b++) {
        var c = m[b]
        c in a || (a[c] = {})
        a = a[c]
      }
      m = m[m.length - 1]
      b = a[m]
      p = p(b)
      p != b &&
        null != p &&
        $jscomp.defineProperty(a, m, {
          configurable: !0,
          writable: !0,
          value: p,
        })
    }
  }
  $jscomp.polyfill(
    "Array.prototype.values",
    function(m) {
      return m
        ? m
        : function() {
            return $jscomp.iteratorFromArray(this, function(m, a) {
              return a
            })
          }
    },
    "es8",
    "es3",
  )
  ;(function(m) {
    function p(b) {
      if (a[b]) return a[b].exports
      var c = (a[b] = { i: b, l: !1, exports: {} })
      m[b].call(c.exports, c, c.exports, p)
      c.l = !0
      return c.exports
    }
    var a = {}
    p.m = m
    p.c = a
    p.d = function(a, c, d) {
      p.o(a, c) || Object.defineProperty(a, c, { enumerable: !0, get: d })
    }
    p.r = function(a) {
      "undefined" !== typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(a, Symbol.toStringTag, { value: "Module" })
      Object.defineProperty(a, "__esModule", { value: !0 })
    }
    p.t = function(a, c) {
      c & 1 && (a = p(a))
      if (c & 8) return a
      if (c & 4 && "object" === typeof a && a && a.__esModule) return a
      var b = Object.create(null)
      p.r(b)
      Object.defineProperty(b, "default", { enumerable: !0, value: a })
      if (c & 2 && "string" != typeof a)
        for (var e in a)
          p.d(
            b,
            e,
            function(b) {
              return a[b]
            }.bind(null, e),
          )
      return b
    }
    p.n = function(a) {
      var b =
        a && a.__esModule
          ? function() {
              return a["default"]
            }
          : function() {
              return a
            }
      p.d(b, "a", b)
      return b
    }
    p.o = function(a, c) {
      return Object.prototype.hasOwnProperty.call(a, c)
    }
    p.p = ""
    return p((p.s = 1))
  })([
    function(m, p) {
      p = (function() {
        return this
      })()
      try {
        p = p || new Function("return this")()
      } catch (a) {
        "object" === typeof window && (p = window)
      }
      m.exports = p
    },
    function(m, p, a) {
      a(2)
      self.Sk.global.strftime = a(3)
      self.Sk.global.strptime = a(4)
      a(5)
      a(7)
      a(8)
      a(9)
      a(10)
      a(11)
      a(12)
      a(13)
      a(14)
      a(15)
      a(16)
      a(17)
      a(18)
      a(19)
      a(20)
      a(21)
      a(22)
      a(23)
      a(24)
      a(25)
      a(26)
      a(27)
      a(28)
      a(29)
      a(30)
      a(31)
      a(32)
      a(33)
      a(34)
      a(35)
      a(36)
      a(37)
      a(38)
      a(39)
      a(40)
      a(41)
      a(42)
      a(43)
      a(44)
      a(45)
      a(46)
      a(47)
      a(48)
      a(49)
      a(50)
      a(51)
      a(52)
      a(53)
      a(54)
      a(55)
      a(56)
      a(57)
      a(58)
      a(59)
    },
    function(m, p, a) {
      ;(function(a) {
        var b = {
          build: {
            githash: "22c38cb03d37af6ec01c07e2e4e17c4acdc3e01f",
            date: "2019-12-12T20:49:06.490Z",
          },
        }
        b.global =
          "undefined" !== typeof a
            ? a
            : "undefined" !== typeof self
            ? self
            : "undefined" !== typeof window
            ? window
            : {}
        b.exportSymbol = function(a, c) {
          a = a.split(".")
          var d = b.global,
            e
          for (e = 0; e < a.length - 1; e++) {
            var h = a[e]
            d = d.hasOwnProperty(h) ? d[h] : (d[h] = {})
          }
          "undefined" !== typeof c && ((h = a[e]), (d[h] = c))
        }
        b.isArrayLike = function(a) {
          return a instanceof Array ||
            (a && a.length && "number" == typeof a.length)
            ? !0
            : !1
        }
        b.js_beautify = function(a) {
          return a
        }
        b.exportSymbol("Sk", b)
        b.exportSymbol("Sk.global", b.global)
        b.exportSymbol("Sk.build", b.build)
        b.exportSymbol("Sk.exportSymbol", b.exportSymbol)
        b.exportSymbol("Sk.isArrayLike", b.isArrayLike)
        b.exportSymbol("Sk.js_beautify", b.js_beautify)
      }.call(this, a(0)))
    },
    function(m, p) {
      ;(function() {
        function a(l, r, D) {
          function n(a, k, l, r) {
            for (
              var h = "", q = null, x = !1, D = a.length, H = !1, p = 0;
              p < D;
              p++
            ) {
              var B = a.charCodeAt(p)
              if (!0 === x)
                if (45 === B) q = ""
                else if (95 === B) q = " "
                else if (48 === B) q = "0"
                else if (58 === B)
                  H &&
                    g(
                      "[WARNING] detected use of unsupported %:: or %::: modifiers to strftime",
                    ),
                    (H = !0)
                else {
                  switch (B) {
                    case 37:
                      h += "%"
                      break
                    case 65:
                      h += l.days[k.getDay()]
                      break
                    case 66:
                      h += l.months[k.getMonth()]
                      break
                    case 67:
                      h += b(Math.floor(k.getFullYear() / 100), q)
                      break
                    case 68:
                      h += n(l.formats.D, k, l, r)
                      break
                    case 70:
                      h += n(l.formats.F, k, l, r)
                      break
                    case 72:
                      h += b(k.getHours(), q)
                      break
                    case 73:
                      h += b(d(k.getHours()), q)
                      break
                    case 76:
                      h += c(Math.floor(r % 1e3))
                      break
                    case 77:
                      h += b(k.getMinutes(), q)
                      break
                    case 80:
                      h += 12 > k.getHours() ? l.am : l.pm
                      break
                    case 82:
                      h += n(l.formats.R, k, l, r)
                      break
                    case 83:
                      h += b(k.getSeconds(), q)
                      break
                    case 84:
                      h += n(l.formats.T, k, l, r)
                      break
                    case 85:
                      h += b(e(k, "sunday"), q)
                      break
                    case 87:
                      h += b(e(k, "monday"), q)
                      break
                    case 88:
                      h += n(l.formats.X, k, l, r)
                      break
                    case 89:
                      h += k.getFullYear()
                      break
                    case 90:
                      A && 0 === m
                        ? (h += "GMT")
                        : ((q = k.toString().match(/\(([\w\s]+)\)/)),
                          (h += (q && q[1]) || ""))
                      break
                    case 97:
                      h += l.shortDays[k.getDay()]
                      break
                    case 98:
                      h += l.shortMonths[k.getMonth()]
                      break
                    case 99:
                      h += n(l.formats.c, k, l, r)
                      break
                    case 100:
                      h += b(k.getDate(), q)
                      break
                    case 101:
                      h += b(k.getDate(), null == q ? " " : q)
                      break
                    case 104:
                      h += l.shortMonths[k.getMonth()]
                      break
                    case 106:
                      q = new Date(k.getFullYear(), 0, 1)
                      q = Math.ceil((k.getTime() - q.getTime()) / 864e5)
                      h += c(q)
                      break
                    case 107:
                      h += b(k.getHours(), null == q ? " " : q)
                      break
                    case 108:
                      h += b(d(k.getHours()), null == q ? " " : q)
                      break
                    case 109:
                      h += b(k.getMonth() + 1, q)
                      break
                    case 110:
                      h += "\n"
                      break
                    case 111:
                      q = k.getDate()
                      h = l.ordinalSuffixes
                        ? h + (String(q) + (l.ordinalSuffixes[q - 1] || f(q)))
                        : h + (String(q) + f(q))
                      break
                    case 112:
                      h += 12 > k.getHours() ? l.AM : l.PM
                      break
                    case 114:
                      h += n(l.formats.r, k, l, r)
                      break
                    case 115:
                      h += Math.floor(r / 1e3)
                      break
                    case 116:
                      h += "\t"
                      break
                    case 117:
                      q = k.getDay()
                      h += 0 === q ? 7 : q
                      break
                    case 118:
                      h += n(l.formats.v, k, l, r)
                      break
                    case 119:
                      h += k.getDay()
                      break
                    case 120:
                      h += n(l.formats.x, k, l, r)
                      break
                    case 121:
                      h += ("" + k.getFullYear()).slice(2)
                      break
                    case 122:
                      A && 0 === m
                        ? (h += H ? "+00:00" : "+0000")
                        : ((q = 0 !== m ? m / 6e4 : -k.getTimezoneOffset()),
                          (x = H ? ":" : ""),
                          (B = Math.abs(q % 60)),
                          (h +=
                            (0 > q ? "-" : "+") +
                            b(Math.floor(Math.abs(q / 60))) +
                            x +
                            b(B)))
                      break
                    default:
                      x && (h += "%"), (h += a[p])
                  }
                  q = null
                  x = !1
                }
              else 37 === B ? (x = !0) : (h += a[p])
            }
            return h
          }
          var q = l || k,
            m = r || 0,
            A = D || !1,
            p = 0,
            K,
            B = function(a, b) {
              if (b) {
                var c = b.getTime()
                if (A) {
                  var d = 6e4 * (b.getTimezoneOffset() || 0)
                  b = new Date(c + d + m)
                  6e4 * (b.getTimezoneOffset() || 0) !== d &&
                    ((b = 6e4 * (b.getTimezoneOffset() || 0)),
                    (b = new Date(c + b + m)))
                }
              } else
                (c = Date.now()),
                  c > p
                    ? ((p = c),
                      (K = new Date(p)),
                      (c = p),
                      A &&
                        (K = new Date(
                          p + 6e4 * (K.getTimezoneOffset() || 0) + m,
                        )))
                    : (c = p),
                  (b = K)
              return n(a, b, q, c)
            }
          B.localize = function(b) {
            return new a(b || q, m, A)
          }
          B.localizeByIdentifier = function(a) {
            var b = h[a]
            return b
              ? B.localize(b)
              : (g('[WARNING] No locale found with identifier "' + a + '".'), B)
          }
          B.timezone = function(b) {
            var c = m,
              d = A,
              e = typeof b
            if ("number" === e || "string" === e)
              (d = !0),
                "string" === e
                  ? ((c = "-" === b[0] ? -1 : 1),
                    (e = parseInt(b.slice(1, 3), 10)),
                    (b = parseInt(b.slice(3, 5), 10)),
                    (c = c * (60 * e + b) * 6e4))
                  : "number" === e && (c = 6e4 * b)
            return new a(q, c, d)
          }
          B.utc = function() {
            return new a(q, m, !0)
          }
          return B
        }
        function b(a, b) {
          if ("" === b || 9 < a) return a
          null == b && (b = "0")
          return b + a
        }
        function c(a) {
          return 99 < a ? a : 9 < a ? "0" + a : "00" + a
        }
        function d(a) {
          return 0 === a ? 12 : 12 < a ? a - 12 : a
        }
        function e(a, b) {
          b = b || "sunday"
          var c = a.getDay()
          "monday" === b && (0 === c ? (c = 6) : c--)
          b = Date.UTC(a.getFullYear(), 0, 1)
          a = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate())
          return Math.floor((Math.floor((a - b) / 864e5) + 7 - c) / 7)
        }
        function f(a) {
          var b = a % 10
          a %= 100
          if ((11 <= a && 13 >= a) || 0 === b || 4 <= b) return "th"
          switch (b) {
            case 1:
              return "st"
            case 2:
              return "nd"
            case 3:
              return "rd"
          }
        }
        function g(a) {
          "undefined" !== typeof console &&
            "function" == typeof console.warn &&
            console.warn(a)
        }
        var h = {
            de_DE: {
              days: "Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag".split(
                " ",
              ),
              shortDays: "So Mo Di Mi Do Fr Sa".split(" "),
              months: "Januar Februar M\u00e4rz April Mai Juni Juli August September Oktober November Dezember".split(
                " ",
              ),
              shortMonths: "Jan Feb M\u00e4r Apr Mai Jun Jul Aug Sep Okt Nov Dez".split(
                " ",
              ),
              AM: "AM",
              PM: "PM",
              am: "am",
              pm: "pm",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%d.%m.%Y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%T",
                x: "%D",
              },
            },
            en_CA: {
              days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
                " ",
              ),
              shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
              months: "January February March April May June July August September October November December".split(
                " ",
              ),
              shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(
                " ",
              ),
              ordinalSuffixes: "st nd rd th th th th th th th th th th th th th th th th th st nd rd th th th th th th th st".split(
                " ",
              ),
              AM: "AM",
              PM: "PM",
              am: "am",
              pm: "pm",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%d/%m/%y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%r",
                x: "%D",
              },
            },
            en_US: {
              days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
                " ",
              ),
              shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
              months: "January February March April May June July August September October November December".split(
                " ",
              ),
              shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(
                " ",
              ),
              ordinalSuffixes: "st nd rd th th th th th th th th th th th th th th th th th st nd rd th th th th th th th st".split(
                " ",
              ),
              AM: "AM",
              PM: "PM",
              am: "am",
              pm: "pm",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%m/%d/%y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%r",
                x: "%D",
              },
            },
            es_MX: {
              days: "domingo lunes martes mi\u00e9rcoles jueves viernes s\u00e1bado".split(
                " ",
              ),
              shortDays: "dom lun mar mi\u00e9 jue vie s\u00e1b".split(" "),
              months: "enero;febrero;marzo;abril;mayo;junio;julio;agosto;septiembre;octubre;noviembre; diciembre".split(
                ";",
              ),
              shortMonths: "ene feb mar abr may jun jul ago sep oct nov dic".split(
                " ",
              ),
              AM: "AM",
              PM: "PM",
              am: "am",
              pm: "pm",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%d/%m/%Y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%T",
                x: "%D",
              },
            },
            fr_FR: {
              days: "dimanche lundi mardi mercredi jeudi vendredi samedi".split(
                " ",
              ),
              shortDays: "dim. lun. mar. mer. jeu. ven. sam.".split(" "),
              months: "janvier f\u00e9vrier mars avril mai juin juillet ao\u00fbt septembre octobre novembre d\u00e9cembre".split(
                " ",
              ),
              shortMonths: "janv. f\u00e9vr. mars avril mai juin juil. ao\u00fbt sept. oct. nov. d\u00e9c.".split(
                " ",
              ),
              AM: "AM",
              PM: "PM",
              am: "am",
              pm: "pm",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%d/%m/%Y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%T",
                x: "%D",
              },
            },
            it_IT: {
              days: "domenica luned\u00ec marted\u00ec mercoled\u00ec gioved\u00ec venerd\u00ec sabato".split(
                " ",
              ),
              shortDays: "dom lun mar mer gio ven sab".split(" "),
              months: "gennaio febbraio marzo aprile maggio giugno luglio agosto settembre ottobre novembre dicembre".split(
                " ",
              ),
              shortMonths: "pr mag giu lug ago set ott nov dic".split(" "),
              AM: "AM",
              PM: "PM",
              am: "am",
              pm: "pm",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%d/%m/%Y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%T",
                x: "%D",
              },
            },
            nl_NL: {
              days: "zondag maandag dinsdag woensdag donderdag vrijdag zaterdag".split(
                " ",
              ),
              shortDays: "zo ma di wo do vr za".split(" "),
              months: "januari februari maart april mei juni juli augustus september oktober november december".split(
                " ",
              ),
              shortMonths: "jan feb mrt apr mei jun jul aug sep okt nov dec".split(
                " ",
              ),
              AM: "AM",
              PM: "PM",
              am: "am",
              pm: "pm",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%d-%m-%y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%T",
                x: "%D",
              },
            },
            pt_BR: {
              days: "domingo segunda ter\u00e7a quarta quinta sexta s\u00e1bado".split(
                " ",
              ),
              shortDays: "Dom Seg Ter Qua Qui Sex S\u00e1b".split(" "),
              months: "janeiro fevereiro mar\u00e7o abril maio junho julho agosto setembro outubro novembro dezembro".split(
                " ",
              ),
              shortMonths: "Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez".split(
                " ",
              ),
              AM: "AM",
              PM: "PM",
              am: "am",
              pm: "pm",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%d-%m-%Y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%T",
                x: "%D",
              },
            },
            ru_RU: {
              days: "\u0412\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435 \u041f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a \u0412\u0442\u043e\u0440\u043d\u0438\u043a \u0421\u0440\u0435\u0434\u0430 \u0427\u0435\u0442\u0432\u0435\u0440\u0433 \u041f\u044f\u0442\u043d\u0438\u0446\u0430 \u0421\u0443\u0431\u0431\u043e\u0442\u0430".split(
                " ",
              ),
              shortDays: "\u0412\u0441 \u041f\u043d \u0412\u0442 \u0421\u0440 \u0427\u0442 \u041f\u0442 \u0421\u0431".split(
                " ",
              ),
              months: "\u042f\u043d\u0432\u0430\u0440\u044c \u0424\u0435\u0432\u0440\u0430\u043b\u044c \u041c\u0430\u0440\u0442 \u0410\u043f\u0440\u0435\u043b\u044c \u041c\u0430\u0439 \u0418\u044e\u043d\u044c \u0418\u044e\u043b\u044c \u0410\u0432\u0433\u0443\u0441\u0442 \u0421\u0435\u043d\u0442\u044f\u0431\u0440\u044c \u041e\u043a\u0442\u044f\u0431\u0440\u044c \u041d\u043e\u044f\u0431\u0440\u044c \u0414\u0435\u043a\u0430\u0431\u0440\u044c".split(
                " ",
              ),
              shortMonths: "\u044f\u043d\u0432 \u0444\u0435\u0432 \u043c\u0430\u0440 \u0430\u043f\u0440 \u043c\u0430\u0439 \u0438\u044e\u043d \u0438\u044e\u043b \u0430\u0432\u0433 \u0441\u0435\u043d \u043e\u043a\u0442 \u043d\u043e\u044f \u0434\u0435\u043a".split(
                " ",
              ),
              AM: "AM",
              PM: "PM",
              am: "am",
              pm: "pm",
              formats: {
                c: "%a %d %b %Y %X",
                D: "%d.%m.%y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%T",
                x: "%D",
              },
            },
            tr_TR: {
              days: "Pazar Pazartesi Sal\u0131 \u00c7ar\u015famba Per\u015fembe Cuma Cumartesi".split(
                " ",
              ),
              shortDays: "Paz Pzt Sal \u00c7r\u015f Pr\u015f Cum Cts".split(
                " ",
              ),
              months: "Ocak \u015eubat Mart Nisan May\u0131s Haziran Temmuz A\u011fustos Eyl\u00fcl Ekim Kas\u0131m Aral\u0131k".split(
                " ",
              ),
              shortMonths: "Oca \u015eub Mar Nis May Haz Tem A\u011fu Eyl Eki Kas Ara".split(
                " ",
              ),
              AM: "\u00d6\u00d6",
              PM: "\u00d6S",
              am: "\u00d6\u00d6",
              pm: "\u00d6S",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%d-%m-%Y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%T",
                x: "%D",
              },
            },
            zh_CN: {
              days: "\u661f\u671f\u65e5 \u661f\u671f\u4e00 \u661f\u671f\u4e8c \u661f\u671f\u4e09 \u661f\u671f\u56db \u661f\u671f\u4e94 \u661f\u671f\u516d".split(
                " ",
              ),
              shortDays: "\u65e5\u4e00\u4e8c\u4e09\u56db\u4e94\u516d".split(""),
              months: "\u4e00\u6708\u4efd \u4e8c\u6708\u4efd \u4e09\u6708\u4efd \u56db\u6708\u4efd \u4e94\u6708\u4efd \u516d\u6708\u4efd \u4e03\u6708\u4efd \u516b\u6708\u4efd \u4e5d\u6708\u4efd \u5341\u6708\u4efd \u5341\u4e00\u6708\u4efd \u5341\u4e8c\u6708\u4efd".split(
                " ",
              ),
              shortMonths: "\u4e00\u6708 \u4e8c\u6708 \u4e09\u6708 \u56db\u6708 \u4e94\u6708 \u516d\u6708 \u4e03\u6708 \u516b\u6708 \u4e5d\u6708 \u5341\u6708 \u5341\u4e00\u6708 \u5341\u4e8c\u6708".split(
                " ",
              ),
              AM: "\u4e0a\u5348",
              PM: "\u4e0b\u5348",
              am: "\u4e0a\u5348",
              pm: "\u4e0b\u5348",
              formats: {
                c: "%a %d %b %Y %X %Z",
                D: "%d/%m/%y",
                F: "%Y-%m-%d",
                R: "%H:%M",
                r: "%I:%M:%S %p",
                T: "%H:%M:%S",
                v: "%e-%b-%Y",
                X: "%r",
                x: "%D",
              },
            },
          },
          k = h.en_US,
          l = new a(k, 0, !1)
        if ("undefined" !== typeof m) var r = (m.exports = l)
        else
          (r = (function() {
            return this || (0, eval)("this")
          })()),
            (r.strftime = l)
        "function" !== typeof Date.now &&
          (Date.now = function() {
            return +new Date()
          })
      })()
    },
    function(m, p, a) {
      ;(function() {
        var a = function(b, d, e) {
          return a.parse(b, d, e)
        }
        a.version = "0.0.1"
        ;(m.exports = a).strptime = a
        a.locale = {
          a: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
          A: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
            " ",
          ),
          b: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
          B: "January February March April May June July August September October November December".split(
            " ",
          ),
          f: "Jan. Feb. Mar. Apr. May Jun. Jul. Aug. Sep. Oct. Nov. Dec.".split(
            " ",
          ),
          c: "%Y-%m-%d %H:%M:%S",
          P: ["am", "pm"],
          r: "%I:%M:%S %p",
          x: "%m/%d/%y",
          X: "%H:%M:%S",
          day: ["Yesterday", "Today", "Tomorrow"],
          bg: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
          Bg: "January February March April May June July August September October November December".split(
            " ",
          ),
          fg: "Jan. Feb. Mar. Apr. May Jun. Jul. Aug. Sep. Oct. Nov. Dec.".split(
            " ",
          ),
          Date_dBY_year_in_HM: "%#B %-d, %Y at %-H:%M",
          Date_dBY_year: "%#B %-d, %Y",
          Date_dBY: "%#B %-d, %Y",
          Date_AdBY: "%A, %#B %-d, %Y",
          Date_dBA: "%#B %-d, %A",
          Date_df_in_HM: "%#f, %-d at %-H:%M",
          Date_dfY: "%-d %#f %Y",
          Date_dB_in_HM: "%#B %-d at %-H:%M",
          Date_df: "%-d %#f",
        }
        ;(function(a) {
          function b(a, c, d, e, g, f) {
            c = String(c)
            d = String(d)
            c = c.replace(/^[#_0\^\-!~]+/, "")
            e = h[c]
            if (!e) return a
            var k = !1
            ;-1 === d.indexOf("!") &&
              1 === c.length &&
              (-1 < d.indexOf("~") ||
                (-1 < "bBf".indexOf(c) &&
                  /%[0\-_]?d[\s]+$/.test(f.substr(0, g)))) &&
              (k = !0)
            if (("I" === c || "l" === c) && !/%[pP]/.test(f))
              throw Error("Undefined AM/PM")
            switch (typeof e) {
              case "function":
                return e()
              case "string":
                return e
              case "object":
                return b.make.push([e.make, d, k]), "(" + e.reg + ")"
              default:
                return a
            }
          }
          function c(a, b) {
            a = String(a)
            b = String(b)
            return -1 !== b.indexOf("#")
              ? a.substr(0, 1).toUpperCase() + a.substr(1)
              : -1 !== b.indexOf("^")
              ? a.substr(0, 1) + a.substr(1).toLowerCase()
              : a
          }
          var f =
              Array.prototype.indexOf ||
              function(a) {
                for (var b = this.length, c = 0; c < b; ) {
                  if (a == this[c]) return c
                  c++
                }
                return -1
              },
            g = a.locale,
            h = {
              "%": "\\%",
              a: "\\S+",
              A: "\\S+",
              b: {
                reg: "\\S+",
                make: function(a, b, d, e) {
                  b = f.call(e ? g.bg : g.b, c(b, d))
                  if (-1 === b) return !1
                  a.setUTCMonth(b)
                  return !0
                },
              },
              h: {
                reg: "\\S+",
                make: function(a, b, d, e) {
                  b = f.call(e ? g.bg : g.b, c(b, d))
                  if (-1 === b) return !1
                  a.setUTCMonth(b)
                  return !0
                },
              },
              B: {
                reg: "\\S+",
                make: function(a, b, d, e) {
                  b = f.call(e ? g.Bg : g.B, c(b, d))
                  if (-1 === b) return !1
                  a.setUTCMonth(b)
                  return !0
                },
              },
              f: {
                reg: "\\S+",
                make: function(a, b, d, e) {
                  b = f.call(e ? g.fg : g.f, c(b, d))
                  if (-1 === b) return !1
                  a.setUTCMonth(b)
                  return !0
                },
              },
              g: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (0 > b || 99 < b) return !1
                  b += 100 * parseInt(new Date().getUTCFullYear() / 100, 10)
                  a.setUTCFullYear(b)
                  return !0
                },
              },
              G: {
                reg: "\\d{4}",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  a.setUTCFullYear(b)
                  return !0
                },
              },
              d: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (1 > b || 31 < b) return !1
                  a.setUTCDate(b)
                  return !0
                },
              },
              e: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (1 > b || 31 < b) return !1
                  a.setUTCDate(b)
                  return !0
                },
              },
              H: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (0 > b || 23 < b) return !1
                  a.setUTCHours(b)
                  return !0
                },
              },
              I: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (1 > b || 12 < b) return !1
                  a.setUTCHours(a.getUTCHours() + b)
                  return !0
                },
              },
              m: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (1 > b || 12 < b) return !1
                  a.setUTCMonth(b - 1)
                  return !0
                },
              },
              M: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (0 > b || 59 < b) return !1
                  a.setUTCMinutes(b)
                  return !0
                },
              },
              n: "\\n",
              p: {
                reg: "\\S+",
                make: function(a, b) {
                  b = f.call(g.P, b.toLowerCase())
                  if (-1 === b) return !1
                  1 === b && a.setUTCHours(a.getUTCHours() + 12)
                  return !0
                },
              },
              P: {
                reg: "\\S+",
                make: function(a, b) {
                  b = f.call(g.P, b.toLowerCase())
                  if (-1 === b) return !1
                  1 === b && a.setUTCHours(a.getUTCHours() + 12)
                  return !0
                },
              },
              S: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (0 > b || 60 < b) return !1
                  a.setUTCSeconds(b)
                  return !0
                },
              },
              t: "\\t",
              u: "\\d",
              U: "[\\d\\s]?\\d",
              w: "\\d",
              W: "[\\d\\s]?\\d",
              y: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (0 > b || 99 < b) return !1
                  b += 100 * parseInt(new Date().getUTCFullYear() / 100, 10)
                  a.setUTCFullYear(b)
                  return !0
                },
              },
              Y: {
                reg: "\\d{4}",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  a.setUTCFullYear(b)
                  return !0
                },
              },
              z: {
                reg: "[+\\-]\\d{4}",
                make: function(a, b) {
                  b = b.match(/^([+\-])(\d{2})(\d{2})$/)
                  if (!b) return !1
                  var c = 6e4 * (60 * parseInt(b[2], 10) + parseInt(b[3], 10))
                  "+" === b[1] && (c = -c)
                  a.setTime(a.getTime() + c)
                  return !0
                },
              },
              l: {
                reg: "[\\d\\s]?\\d",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  if (1 > b || 12 < b) return !1
                  a.setUTCHours(a.getUTCHours() + b)
                  return !0
                },
              },
              s: {
                reg: "\\d+",
                make: function(a, b) {
                  b = parseInt(b, 10)
                  a.setTime(1e3 * b)
                  return !0
                },
              },
              c: g.c,
              r: g.r,
              R: "%H:%M",
              T: "%H:%M:%S",
              x: g.x,
              X: g.X,
              D: "%m/%d/%y",
              F: "%Y-%m-%d",
              Date_iso: "%Y-%m-%dT%H:%M:%S",
              Date_dBY_year_in_HM: g.Date_dBY_year_in_HM,
              Date_dBY_year: g.Date_dBY_year,
              Date_dBY: g.Date_dBY,
              Date_dBA: g.Date_dBA,
              Date_AdBY: g.Date_AdBY,
              Date_df_in_HM: g.Date_df_in_HM,
              Date_dfY: g.Date_dfY,
              Date_dB_in_HM: g.Date_dB_in_HM,
              Date_dmY__dot: "%d.%m.%Y",
              Date_df: g.Date_df,
              Date_FT: "%F %T",
              Date_dmY__minus: "%d-%m-%Y",
            }
          a.parse = function(a, c, d) {
            a = String(a)
            c = String(c)
            for (var e = 5; /%(Date_[a-zA-Z0-9_]+|[cDFrRTxX])/g.test(c) && e; )
              (c = c.replace(/%(Date_[a-zA-Z0-9_]+|[cDFrRTxX])/, b)), e--
            b.make = []
            c = c.replace(
              /%(([#\^!~]{0,2})[aAbBfh]|([0\-_]?)[degHImMSVWyl]|[GnpPtuUwYzZs%])/g,
              b,
            )
            a = a.match(new RegExp(c))
            if (!a || !b.make.length) return null
            c = new Date(Date.UTC(0, 0))
            e = 0
            for (var k = b.make.length; e < k; e++) {
              var g = b.make[e]
              if (!g[0](c, a[e + 1], g[1], g[2])) return null
            }
            d && c.setTime(c.getTime() + 6e4 * c.getTimezoneOffset())
            return c
          }
        })(a)
      })()
    },
    function(m, p, a) {
      ;(function(a, c) {
        ;(function(a, b) {
          function d(a) {
            delete x[a]
          }
          function e(a) {
            if (H) setTimeout(e, 0, a)
            else {
              var c = x[a]
              if (c) {
                H = !0
                try {
                  var k = c.callback,
                    g = c.args
                  switch (g.length) {
                    case 0:
                      k()
                      break
                    case 1:
                      k(g[0])
                      break
                    case 2:
                      k(g[0], g[1])
                      break
                    case 3:
                      k(g[0], g[1], g[2])
                      break
                    default:
                      k.apply(b, g)
                  }
                } finally {
                  d(a), (H = !1)
                }
              }
            }
          }
          function h() {
            A = function(a) {
              c.nextTick(function() {
                e(a)
              })
            }
          }
          function k() {
            if (a.postMessage && !a.importScripts) {
              var b = !0,
                c = a.onmessage
              a.onmessage = function() {
                b = !1
              }
              a.postMessage("", "*")
              a.onmessage = c
              return b
            }
          }
          function l() {
            var b = "setImmediate$" + Math.random() + "$",
              c = function(c) {
                c.source === a &&
                  "string" === typeof c.data &&
                  0 === c.data.indexOf(b) &&
                  e(+c.data.slice(b.length))
              }
            a.addEventListener
              ? a.addEventListener("message", c, !1)
              : a.attachEvent("onmessage", c)
            A = function(c) {
              a.postMessage(b + c, "*")
            }
          }
          function r() {
            var a = new MessageChannel()
            a.port1.onmessage = function(a) {
              e(a.data)
            }
            A = function(b) {
              a.port2.postMessage(b)
            }
          }
          function n() {
            var a = p.documentElement
            A = function(b) {
              var c = p.createElement("script")
              c.onreadystatechange = function() {
                e(b)
                c.onreadystatechange = null
                a.removeChild(c)
                c = null
              }
              a.appendChild(c)
            }
          }
          function q() {
            A = function(a) {
              setTimeout(e, 0, a)
            }
          }
          if (!a.setImmediate) {
            var m = 1,
              x = {},
              H = !1,
              p = a.document,
              A,
              C = Object.getPrototypeOf && Object.getPrototypeOf(a)
            C = C && C.setTimeout ? C : a
            "[object process]" === {}.toString.call(a.process)
              ? h()
              : k()
              ? l()
              : a.MessageChannel
              ? r()
              : p && "onreadystatechange" in p.createElement("script")
              ? n()
              : q()
            C.setImmediate = function(a) {
              "function" !== typeof a && (a = new Function("" + a))
              for (
                var b = Array(arguments.length - 1), c = 0;
                c < b.length;
                c++
              )
                b[c] = arguments[c + 1]
              x[m] = { callback: a, args: b }
              A(m)
              return m++
            }
            C.clearImmediate = d
          }
        })(
          "undefined" === typeof self
            ? "undefined" === typeof a
              ? this
              : a
            : self,
        )
      }.call(this, a(0), a(6)))
    },
    function(m, p) {
      function a() {
        throw Error("setTimeout has not been defined")
      }
      function b() {
        throw Error("clearTimeout has not been defined")
      }
      function c(b) {
        if (k === setTimeout) return setTimeout(b, 0)
        if ((k === a || !k) && setTimeout)
          return (k = setTimeout), setTimeout(b, 0)
        try {
          return k(b, 0)
        } catch (H) {
          try {
            return k.call(null, b, 0)
          } catch (J) {
            return k.call(this, b, 0)
          }
        }
      }
      function d(a) {
        if (l === clearTimeout) return clearTimeout(a)
        if ((l === b || !l) && clearTimeout)
          return (l = clearTimeout), clearTimeout(a)
        try {
          return l(a)
        } catch (H) {
          try {
            return l.call(null, a)
          } catch (J) {
            return l.call(this, a)
          }
        }
      }
      function e() {
        n &&
          q &&
          ((n = !1), q.length ? (r = q.concat(r)) : (D = -1), r.length && f())
      }
      function f() {
        if (!n) {
          var a = c(e)
          n = !0
          for (var b = r.length; b; ) {
            q = r
            for (r = []; ++D < b; ) q && q[D].run()
            D = -1
            b = r.length
          }
          q = null
          n = !1
          d(a)
        }
      }
      function g(a, b) {
        this.fun = a
        this.array = b
      }
      function h() {}
      m = m.exports = {}
      try {
        var k = "function" === typeof setTimeout ? setTimeout : a
      } catch (x) {
        k = a
      }
      try {
        var l = "function" === typeof clearTimeout ? clearTimeout : b
      } catch (x) {
        l = b
      }
      var r = [],
        n = !1,
        q,
        D = -1
      m.nextTick = function(a) {
        var b = Array(arguments.length - 1)
        if (1 < arguments.length)
          for (var d = 1; d < arguments.length; d++) b[d - 1] = arguments[d]
        r.push(new g(a, b))
        1 !== r.length || n || c(f)
      }
      g.prototype.run = function() {
        this.fun.apply(null, this.array)
      }
      m.title = "browser"
      m.browser = !0
      m.env = {}
      m.argv = []
      m.version = ""
      m.versions = {}
      m.on = h
      m.addListener = h
      m.once = h
      m.off = h
      m.removeListener = h
      m.removeAllListeners = h
      m.emit = h
      m.prependListener = h
      m.prependOnceListener = h
      m.listeners = function(a) {
        return []
      }
      m.binding = function(a) {
        throw Error("process.binding is not supported")
      }
      m.cwd = function() {
        return "/"
      }
      m.chdir = function(a) {
        throw Error("process.chdir is not supported")
      }
      m.umask = function() {
        return 0
      }
    },
    function(m, p) {
      self.Sk.asserts = {}
      self.Sk.asserts.assert = function(a, b) {
        return a
      }
      self.Sk.exportSymbol("Sk.asserts.assert", self.Sk.asserts.assert)
      self.Sk.asserts.fail = function(a) {}
      self.Sk.exportSymbol("Sk.asserts.fail", self.Sk.asserts.fail)
    },
    function(m, p) {
      self.Sk.bool_check = function(a, b) {
        if (void 0 === a || null === a || "boolean" !== typeof a)
          throw Error("must specify " + b + " and it must be a boolean")
      }
      self.Sk.python2 = {
        print_function: !1,
        division: !1,
        absolute_import: null,
        unicode_literals: !1,
        python3: !1,
        set_repr: !1,
        class_repr: !1,
        inherit_from_object: !1,
        super_args: !1,
        octal_number_literal: !1,
        bankers_rounding: !1,
        python_version: !1,
        dunder_next: !1,
        dunder_round: !1,
        list_clear: !1,
        exceptions: !1,
        no_long_type: !1,
        ceil_floor_int: !1,
        silent_octal_literal: !0,
      }
      self.Sk.python3 = {
        print_function: !0,
        division: !0,
        absolute_import: null,
        unicode_literals: !0,
        python3: !0,
        set_repr: !0,
        class_repr: !0,
        inherit_from_object: !0,
        super_args: !0,
        octal_number_literal: !0,
        bankers_rounding: !0,
        python_version: !0,
        dunder_next: !0,
        dunder_round: !0,
        list_clear: !0,
        exceptions: !0,
        no_long_type: !0,
        ceil_floor_int: !0,
        silent_octal_literal: !1,
      }
      self.Sk.configure = function(a) {
        self.Sk.output = a.output || self.Sk.output
        self.Sk.asserts.assert("function" === typeof self.Sk.output)
        self.Sk.debugout = a.debugout || self.Sk.debugout
        self.Sk.asserts.assert("function" === typeof self.Sk.debugout)
        self.Sk.uncaughtException = a.uncaughtException || self.Sk.uncaughtException
        self.Sk.asserts.assert("function" === typeof self.Sk.uncaughtException)
        self.Sk.read = a.read || self.Sk.read
        self.Sk.asserts.assert("function" === typeof self.Sk.read)
        self.Sk.nonreadopen = a.nonreadopen || !1
        self.Sk.asserts.assert("boolean" === typeof self.Sk.nonreadopen)
        self.Sk.fileopen = a.fileopen || void 0
        self.Sk.asserts.assert(
          "function" === typeof self.Sk.fileopen ||
            "undefined" === typeof self.Sk.fileopen,
        )
        self.Sk.filewrite = a.filewrite || void 0
        self.Sk.asserts.assert(
          "function" === typeof self.Sk.filewrite ||
            "undefined" === typeof self.Sk.filewrite,
        )
        self.Sk.timeoutMsg = a.timeoutMsg || self.Sk.timeoutMsg
        self.Sk.asserts.assert("function" === typeof self.Sk.timeoutMsg)
        self.Sk.exportSymbol("Sk.timeoutMsg", self.Sk.timeoutMsg)
        self.Sk.sysargv = a.sysargv || self.Sk.sysargv
        self.Sk.asserts.assert(self.Sk.isArrayLike(self.Sk.sysargv))
        self.Sk.__future__ = a.__future__ || self.Sk.python2
        self.Sk.bool_check(
          self.Sk.__future__.print_function,
          "Sk.__future__.print_function",
        )
        self.Sk.bool_check(self.Sk.__future__.division, "Sk.__future__.division")
        self.Sk.bool_check(
          self.Sk.__future__.unicode_literals,
          "Sk.__future__.unicode_literals",
        )
        self.Sk.bool_check(self.Sk.__future__.set_repr, "Sk.__future__.set_repr")
        self.Sk.bool_check(self.Sk.__future__.class_repr, "Sk.__future__.class_repr")
        self.Sk.bool_check(
          self.Sk.__future__.inherit_from_object,
          "Sk.__future__.inherit_from_object",
        )
        self.Sk.bool_check(self.Sk.__future__.super_args, "Sk.__future__.super_args")
        self.Sk.bool_check(
          self.Sk.__future__.octal_number_literal,
          "Sk.__future__.octal_number_literal",
        )
        self.Sk.bool_check(
          self.Sk.__future__.bankers_rounding,
          "Sk.__future__.bankers_rounding",
        )
        self.Sk.bool_check(
          self.Sk.__future__.python_version,
          "Sk.__future__.python_version",
        )
        self.Sk.bool_check(self.Sk.__future__.dunder_next, "Sk.__future__.dunder_next")
        self.Sk.bool_check(self.Sk.__future__.dunder_round, "Sk.__future__.dunder_round")
        self.Sk.bool_check(self.Sk.__future__.list_clear, "Sk.__future__.list_clear")
        self.Sk.bool_check(self.Sk.__future__.exceptions, "Sk.__future__.exceptions")
        self.Sk.bool_check(self.Sk.__future__.no_long_type, "Sk.__future__.no_long_type")
        self.Sk.bool_check(
          self.Sk.__future__.ceil_floor_int,
          "Sk.__future__.ceil_floor_int",
        )
        self.Sk.bool_check(
          self.Sk.__future__.silent_octal_literal,
          "Sk.__future__.silent_octal_literal",
        )
        self.Sk.imageProxy = a.imageProxy || "http://localhost:8080/320x"
        self.Sk.asserts.assert(
          "string" === typeof self.Sk.imageProxy ||
            "function" === typeof self.Sk.imageProxy,
        )
        self.Sk.inputfun = a.inputfun || self.Sk.inputfun
        self.Sk.asserts.assert("function" === typeof self.Sk.inputfun)
        self.Sk.inputfunTakesPrompt = a.inputfunTakesPrompt || !1
        self.Sk.asserts.assert("boolean" === typeof self.Sk.inputfunTakesPrompt)
        self.Sk.retainGlobals = a.retainglobals || !1
        self.Sk.asserts.assert("boolean" === typeof self.Sk.retainGlobals)
        self.Sk.debugging = a.debugging || !1
        self.Sk.asserts.assert("boolean" === typeof self.Sk.debugging)
        self.Sk.killableWhile = a.killableWhile || !1
        self.Sk.asserts.assert("boolean" === typeof self.Sk.killableWhile)
        self.Sk.killableFor = a.killableFor || !1
        self.Sk.asserts.assert("boolean" === typeof self.Sk.killableFor)
        self.Sk.signals = a.signals
        self.Sk.signals =
          !0 === self.Sk.signals
            ? {
                listeners: [],
                addEventListener: function(a) {
                  self.Sk.signals.listeners.push(a)
                },
                removeEventListener: function(a) {
                  a = self.Sk.signals.listeners.indexOf(a)
                  0 <= a && self.Sk.signals.listeners.splice(a, 1)
                },
                signal: function(a, c) {
                  for (var b = 0; b < self.Sk.signals.listeners.length; b++)
                    self.Sk.signals.listeners[b].call(null, a, c)
                },
              }
            : null
        self.Sk.asserts.assert("object" === typeof self.Sk.signals)
        self.Sk.breakpoints =
          a.breakpoints ||
          function() {
            return !0
          }
        self.Sk.asserts.assert("function" === typeof self.Sk.breakpoints)
        self.Sk.setTimeout = a.setTimeout
        void 0 === self.Sk.setTimeout &&
          (self.Sk.setTimeout =
            "function" === typeof setTimeout
              ? function(a, c) {
                  setTimeout(a, c)
                }
              : function(a, c) {
                  a()
                })
        self.Sk.asserts.assert("function" === typeof self.Sk.setTimeout)
        "execLimit" in a && (self.Sk.execLimit = a.execLimit)
        "yieldLimit" in a && (self.Sk.yieldLimit = a.yieldLimit)
        a.syspath &&
          ((self.Sk.syspath = a.syspath),
          self.Sk.asserts.assert(self.Sk.isArrayLike(self.Sk.syspath)),
          (self.Sk.realsyspath = void 0),
          (self.Sk.sysmodules = new self.Sk.builtin.dict([])))
        self.Sk.misceval.softspace_ = !1
        self.Sk.switch_version("round$", self.Sk.__future__.dunder_round)
        self.Sk.switch_version("next$", self.Sk.__future__.dunder_next)
        self.Sk.switch_version("clear$", self.Sk.__future__.list_clear)
        self.Sk.builtin.lng.tp$name = self.Sk.__future__.no_long_type ? "int" : "long"
        self.Sk.setupOperators(self.Sk.__future__.python3)
        self.Sk.setupDunderMethods(self.Sk.__future__.python3)
        self.Sk.setupObjects(self.Sk.__future__.python3)
      }
      self.Sk.exportSymbol("Sk.configure", self.Sk.configure)
      self.Sk.uncaughtException = function(a) {
        throw a
      }
      self.Sk.uncaughtException = function(a) {
        throw a
      }
      self.Sk.exportSymbol("Sk.uncaughtException", self.Sk.uncaughtException)
      self.Sk.timeoutMsg = function() {
        return "Program exceeded run time limit."
      }
      self.Sk.exportSymbol("Sk.timeoutMsg", self.Sk.timeoutMsg)
      self.Sk.execLimit = Number.POSITIVE_INFINITY
      self.Sk.yieldLimit = Number.POSITIVE_INFINITY
      self.Sk.output = function(a) {}
      self.Sk.read = function(a) {
        throw "Sk.read has not been implemented"
      }
      self.Sk.sysargv = []
      self.Sk.getSysArgv = function() {
        return self.Sk.sysargv
      }
      self.Sk.exportSymbol("Sk.getSysArgv", self.Sk.getSysArgv)
      self.Sk.syspath = []
      self.Sk.inBrowser = void 0 !== self.Sk.global.document
      self.Sk.debugout = function(a) {}
      ;(function() {
        void 0 !== self.Sk.global.write
          ? (self.Sk.output = self.Sk.global.write)
          : void 0 !== self.Sk.global.console && void 0 !== self.Sk.global.console.log
          ? (self.Sk.output = function(a) {
              self.Sk.global.console.log(a)
            })
          : void 0 !== self.Sk.global.print && (self.Sk.output = self.Sk.global.print)
        void 0 !== self.Sk.global.console && void 0 !== self.Sk.global.console.log
          ? (self.Sk.debugout = function(a) {
              self.Sk.global.console.log(a)
            })
          : void 0 !== self.Sk.global.print && (self.Sk.debugout = self.Sk.global.print)
      })()
      self.Sk.inputfun = function(a) {
        return window.prompt(a)
      }
      self.Sk.setup_method_mappings = function() {
        return {
          round$: {
            classes: [self.Sk.builtin.float_, self.Sk.builtin.int_, self.Sk.builtin.nmber],
            2: null,
            3: "__round__",
          },
          clear$: { classes: [self.Sk.builtin.list], 2: null, 3: "clear" },
          next$: {
            classes: [
              self.Sk.builtin.dict_iter_,
              self.Sk.builtin.list_iter_,
              self.Sk.builtin.set_iter_,
              self.Sk.builtin.str_iter_,
              self.Sk.builtin.tuple_iter_,
              self.Sk.builtin.generator,
              self.Sk.builtin.enumerate,
              self.Sk.builtin.filter_,
              self.Sk.builtin.zip_,
              self.Sk.builtin.map_,
              self.Sk.builtin.iterator,
            ],
            2: "next",
            3: "__next__",
          },
        }
      }
      self.Sk.switch_version = function(a, b) {
        var c
        var d = self.Sk.setup_method_mappings()[a]
        if (b) {
          b = d[3]
          var e = d[2]
        } else (b = d[2]), (e = d[3])
        var f = d.classes
        var g = f.length
        for (c = 0; c < g; c++)
          (d = f[c]),
            e && d.prototype.hasOwnProperty(e) && delete d.prototype[e],
            b && (d.prototype[b] = new self.Sk.builtin.func(d.prototype[a]))
      }
      self.Sk.exportSymbol("Sk.__future__", self.Sk.__future__)
      self.Sk.exportSymbol("Sk.inputfun", self.Sk.inputfun)
    },
    function(m, p) {
      void 0 === self.Sk.builtin && (self.Sk.builtin = {})
      self.Sk.dunderToSkulpt = {
        __eq__: "ob$eq",
        __ne__: "ob$ne",
        __lt__: "ob$lt",
        __le__: "ob$le",
        __gt__: "ob$gt",
        __ge__: "ob$ge",
        __hash__: "tp$hash",
        __abs__: "nb$abs",
        __neg__: "nb$negative",
        __pos__: "nb$positive",
        __int__: "nb$int_",
        __long__: "nb$lng",
        __float__: "nb$float_",
        __add__: "nb$add",
        __radd__: "nb$reflected_add",
        __sub__: "nb$subtract",
        __rsub__: "nb$reflected_subtract",
        __mul__: "nb$multiply",
        __rmul__: "nb$reflected_multiply",
        __div__: "nb$divide",
        __rdiv__: "nb$reflected_divide",
        __floordiv__: "nb$floor_divide",
        __rfloordiv__: "nb$reflected_floor_divide",
        __mod__: "nb$remainder",
        __rmod__: "nb$reflected_remainder",
        __divmod__: "nb$divmod",
        __rdivmod__: "nb$reflected_divmod",
        __pow__: "nb$power",
        __rpow__: "nb$reflected_power",
        __contains__: "sq$contains",
        __len__: ["sq$length", 1],
        __get__: ["tp$descr_get", 3],
        __set__: ["tp$descr_set", 3],
      }
      self.Sk.setupDunderMethods = function(a) {
        a
          ? ((self.Sk.dunderToSkulpt.__matmul__ = "tp$matmul"),
            (self.Sk.dunderToSkulpt.__rmatmul__ = "tp$reflected_matmul"))
          : (self.Sk.dunderToSkulpt.__matmul__ &&
              delete self.Sk.dunderToSkulpt.__matmul__,
            self.Sk.dunderToSkulpt.__rmatmul__ &&
              delete self.Sk.dunderToSkulpt.__rmatmul__)
      }
      self.Sk.exportSymbol("Sk.setupDunderMethods", self.Sk.setupDunderMethods)
      self.Sk.builtin.type = function(a, b, c) {
        var d
        if (void 0 === b && void 0 === c) return a.ob$type
        if ("dict" !== c.tp$name)
          throw new self.Sk.builtin.TypeError(
            "type() argument 3 must be dict, not " + self.Sk.abstr.typeName(c),
          )
        if (!self.Sk.builtin.checkString(a))
          throw new self.Sk.builtin.TypeError(
            "type() argument 1 must be str, not " + self.Sk.abstr.typeName(a),
          )
        if ("tuple" !== b.tp$name)
          throw new self.Sk.builtin.TypeError(
            "type() argument 2 must be tuple, not " + self.Sk.abstr.typeName(b),
          )
        var e = function(a, b) {
          void 0 !== e.prototype.tp$base &&
            (e.prototype.tp$base.sk$klass
              ? e.prototype.tp$base.call(this, a, b)
              : ((a = a.slice()),
                a.unshift(e, this),
                self.Sk.abstr.superConstructor.apply(void 0, a)))
          this.$d = new self.Sk.builtin.dict([])
          this.$d.mp$ass_subscript(new self.Sk.builtin.str("__dict__"), this.$d)
        }
        var f = self.Sk.ffi.remapToJs(a),
          g = !1
        e.tp$call = function(a, b) {
          var c = self.Sk.builtin.type.typeLookup(e, self.Sk.builtin.str.$new)
          a = a || []
          b = b || []
          if (void 0 === c || c === self.Sk.builtin.object.prototype.__new__) {
            var d = new e(a, b)
            c = void 0
          } else {
            var k = a.slice()
            k.unshift(e)
            d = self.Sk.misceval.applyOrSuspend(c, void 0, void 0, b, k)
          }
          return self.Sk.misceval.chain(
            d,
            function(e) {
              var k = self.Sk.builtin.type.typeLookup(
                e.ob$type,
                self.Sk.builtin.str.$init,
              )
              d = e
              if (void 0 !== k)
                return (
                  a.unshift(d),
                  self.Sk.misceval.applyOrSuspend(k, void 0, void 0, b, a)
                )
              if (void 0 === c && (0 !== a.length || 0 !== b.length) && !g)
                throw new self.Sk.builtin.TypeError(
                  "__init__() got unexpected argument(s)",
                )
            },
            function(a) {
              if (a !== self.Sk.builtin.none.none$ && void 0 !== a)
                throw new self.Sk.builtin.TypeError(
                  "__init__() should return None, not " + self.Sk.abstr.typeName(a),
                )
              return d
            },
          )
        }
        0 === b.v.length &&
          self.Sk.__future__.inherit_from_object &&
          (b.v.push(self.Sk.builtin.object),
          self.Sk.abstr.setUpInheritance(f, e, self.Sk.builtin.object))
        var h,
          k = []
        var l = b.tp$iter()
        for (d = l.tp$iternext(); void 0 !== d; d = l.tp$iternext()) {
          for (void 0 === h && (h = d); d.sk$klass && d.prototype.tp$base; )
            d = d.prototype.tp$base
          !d.sk$klass && 0 > k.indexOf(d) && (k.push(d), (g = !0))
        }
        if (1 < k.length)
          throw new self.Sk.builtin.TypeError(
            "Multiple inheritance with more than one builtin type is unsupported",
          )
        void 0 !== h &&
          (self.Sk.abstr.inherits(e, h),
          h.prototype instanceof self.Sk.builtin.object ||
            h === self.Sk.builtin.object) &&
          (e.prototype.tp$base = h)
        e.prototype.tp$name = f
        e.prototype.ob$type = self.Sk.builtin.type.makeIntoTypeObj(f, e)
        var r = new self.Sk.builtin.str("__module__")
        void 0 === c.mp$lookup(r) && c.mp$ass_subscript(r, self.Sk.globals.__name__)
        l = c.tp$iter()
        for (h = l.tp$iternext(); void 0 !== h; h = l.tp$iternext())
          (d = c.mp$subscript(h)),
            void 0 === d && (d = null),
            (e.prototype[h.v] = d),
            (e[h.v] = d)
        e.__class__ = e
        e.__name__ = a
        e.sk$klass = !0
        e.prototype.$r = function() {
          var a = this.tp$getattr(self.Sk.builtin.str.$repr)
          if (
            void 0 !== a &&
            a.im_func !== self.Sk.builtin.object.prototype.__repr__
          )
            return self.Sk.misceval.apply(a, void 0, void 0, void 0, [])
          if (
            void 0 !== e.prototype.tp$base &&
            e.prototype.tp$base !== self.Sk.builtin.object &&
            void 0 !== e.prototype.tp$base.prototype.$r
          )
            return e.prototype.tp$base.prototype.$r.call(this)
          var b = c.mp$subscript(r)
          a = ""
          b && (a = b.v + ".")
          return new self.Sk.builtin.str("<" + a + f + " object>")
        }
        e.prototype.tp$setattr = function(a, b, c) {
          var d = self.Sk.builtin.object.prototype.GenericGetAttr.call(
            this,
            self.Sk.builtin.str.$setattr,
          )
          return void 0 !== d
            ? ((a = self.Sk.misceval.callsimOrSuspendArray(d, [a, b])),
              c ? a : self.Sk.misceval.retryOptionalSuspensionOrThrow(a))
            : self.Sk.builtin.object.prototype.GenericSetAttr.call(this, a, b, c)
        }
        e.prototype.tp$getattr = function(a, b) {
          var c
          var d = self.Sk.builtin.type.typeLookup(e, self.Sk.builtin.str.$getattribute)
          void 0 !== d &&
            null !== d &&
            void 0 !== d.tp$descr_get &&
            (c = d.tp$descr_get.call(d, this, e))
          void 0 === c &&
            (c = self.Sk.builtin.object.prototype.GenericPythonGetAttr.bind(
              null,
              this,
            ))
          d = self.Sk.misceval.tryCatch(
            function() {
              return self.Sk.misceval.callsimOrSuspendArray(c, [a])
            },
            function(a) {
              if (!(a instanceof self.Sk.builtin.AttributeError)) throw a
            },
          )
          return b ? d : self.Sk.misceval.retryOptionalSuspensionOrThrow(d)
        }
        e.prototype.tp$str = function() {
          var a = this.tp$getattr(self.Sk.builtin.str.$str)
          return void 0 !== a &&
            a.im_func !== self.Sk.builtin.object.prototype.__str__
            ? self.Sk.misceval.apply(a, void 0, void 0, void 0, [])
            : void 0 !== e.prototype.tp$base &&
              e.prototype.tp$base !== self.Sk.builtin.object &&
              void 0 !== e.prototype.tp$base.prototype.tp$str
            ? e.prototype.tp$base.prototype.tp$str.call(this)
            : this.$r()
        }
        e.prototype.tp$length = function(a) {
          var b = self.Sk.misceval.chain(
            self.Sk.abstr.gattr(this, self.Sk.builtin.str.$len, a),
            function(a) {
              return self.Sk.misceval.applyOrSuspend(a, void 0, void 0, void 0, [])
            },
          )
          return a ? b : self.Sk.misceval.retryOptionalSuspensionOrThrow(b)
        }
        e.prototype.tp$call = function(a, b) {
          return self.Sk.misceval.chain(
            this.tp$getattr(self.Sk.builtin.str.$call, !0),
            function(c) {
              if (void 0 === c)
                throw new self.Sk.builtin.TypeError(
                  "'" + self.Sk.abstr.typeName(this) + "' object is not callable",
                )
              return self.Sk.misceval.applyOrSuspend(c, void 0, void 0, b, a)
            },
          )
        }
        e.prototype.tp$iter = function() {
          var a = this.tp$getattr(self.Sk.builtin.str.$iter)
          if (void 0 === a)
            throw new self.Sk.builtin.TypeError(
              "'" + self.Sk.abstr.typeName(this) + "' object is not iterable",
            )
          return self.Sk.misceval.callsimArray(a)
        }
        e.prototype.tp$iternext = function(a) {
          var b = this,
            c = self.Sk.misceval.chain(
              b.tp$getattr(
                self.Sk.__future__.dunder_next
                  ? self.Sk.builtin.str.$next3
                  : self.Sk.builtin.str.$next2,
                a,
              ),
              function(a) {
                if (void 0 === a)
                  throw new self.Sk.builtin.TypeError(
                    "'" + self.Sk.abstr.typeName(b) + "' object is not iterable",
                  )
                return self.Sk.misceval.tryCatch(
                  function() {
                    return self.Sk.misceval.callsimOrSuspendArray(a)
                  },
                  function(a) {
                    if (!(a instanceof self.Sk.builtin.StopIteration)) throw a
                  },
                )
              },
            )
          return a ? c : self.Sk.misceval.retryOptionalSuspensionOrThrow(c)
        }
        e.prototype.tp$getitem = function(a, b) {
          var c = this.tp$getattr(self.Sk.builtin.str.$getitem, b)
          if (void 0 !== c)
            return (
              (a = self.Sk.misceval.applyOrSuspend(c, void 0, void 0, void 0, [a])),
              b ? a : self.Sk.misceval.retryOptionalSuspensionOrThrow(a)
            )
          throw new self.Sk.builtin.TypeError(
            "'" +
              self.Sk.abstr.typeName(this) +
              "' object does not support indexing",
          )
        }
        e.prototype.tp$setitem = function(a, b, c) {
          var d = this.tp$getattr(self.Sk.builtin.str.$setitem, c)
          if (void 0 !== d)
            return (
              (a = self.Sk.misceval.applyOrSuspend(d, void 0, void 0, void 0, [
                a,
                b,
              ])),
              c ? a : self.Sk.misceval.retryOptionalSuspensionOrThrow(a)
            )
          throw new self.Sk.builtin.TypeError(
            "'" +
              self.Sk.abstr.typeName(this) +
              "' object does not support item assignment",
          )
        }
        b &&
          ((e.$d = new self.Sk.builtin.dict([])),
          e.$d.mp$ass_subscript(self.Sk.builtin.type.basesStr_, b),
          (a = self.Sk.builtin.type.buildMRO(e)),
          e.$d.mp$ass_subscript(self.Sk.builtin.type.mroStr_, a),
          (e.tp$mro = a))
        e.tp$setattr = self.Sk.builtin.type.prototype.tp$setattr
        a = function(a, b, c, d) {
          e.prototype[a] = function() {
            var a = !1,
              b = arguments.length,
              e
            var k = null !== d && d <= b ? Array(b) : Array(b + 1)
            k[0] = this
            var g = 1
            for (e = 0; e < b; e++)
              e === d - 1
                ? (a = arguments[e])
                : ((k[g] = arguments[e]), (g += 1))
            return a
              ? self.Sk.misceval.callsimOrSuspendArray(c, k)
              : self.Sk.misceval.callsimArray(c, k)
          }
        }
        for (var n in self.Sk.dunderToSkulpt)
          (b = self.Sk.dunderToSkulpt[n]),
            "string" === typeof b ? (l = null) : ((l = b[1]), (b = b[0])),
            e[n] && a(b, n, e[n], l)
        return e
      }
      self.Sk.builtin.type.makeTypeObj = function(a, b) {
        self.Sk.builtin.type.makeIntoTypeObj(a, b)
        return b
      }
      self.Sk.builtin.type.makeIntoTypeObj = function(a, b) {
        self.Sk.asserts.assert(void 0 !== a)
        self.Sk.asserts.assert(void 0 !== b)
        b.ob$type = self.Sk.builtin.type
        b.tp$name = a
        b.$r = function() {
          var a = b.__module__,
            d = ""
          a && (d = a.v + ".")
          var e = "class"
          a || b.sk$klass || self.Sk.__future__.class_repr || (e = "type")
          return new self.Sk.builtin.str("<" + e + " '" + d + b.tp$name + "'>")
        }
        b.tp$str = void 0
        b.tp$getattr = self.Sk.builtin.type.prototype.tp$getattr
        b.tp$setattr = self.Sk.builtin.object.prototype.GenericSetAttr
        b.tp$richcompare = self.Sk.builtin.type.prototype.tp$richcompare
        b.sk$type = !0
        return b
      }
      self.Sk.builtin.type.ob$type = self.Sk.builtin.type
      self.Sk.builtin.type.tp$name = "type"
      self.Sk.builtin.type.sk$type = !0
      self.Sk.builtin.type.$r = function() {
        return self.Sk.__future__.class_repr
          ? new self.Sk.builtin.str("<class 'type'>")
          : new self.Sk.builtin.str("<type 'type'>")
      }
      self.Sk.builtin.type.prototype.tp$getattr = function(a, b) {
        if (this.$d) {
          var c = this.$d.mp$lookup(a)
          if (void 0 !== c) return c
        }
        a = self.Sk.builtin.type.typeLookup(this, a)
        if (void 0 !== a && null !== a && void 0 !== a.ob$type)
          var d = a.tp$descr_get
        if (d) return d.call(a, self.Sk.builtin.none.none$, this, b)
        if (void 0 !== a) return a
      }
      self.Sk.builtin.type.prototype.tp$setattr = function(a, b) {
        this[a.$jsstr()] = b
      }
      self.Sk.builtin.type.typeLookup = function(a, b) {
        var c = a.tp$mro,
          d,
          e = b.$jsstr()
        if (c)
          for (d = 0; d < c.v.length; ++d) {
            a = c.v[d]
            if (a.hasOwnProperty(e)) return a[e]
            var f = a.$d.mp$lookup(b)
            if (void 0 !== f) return f
            if (a.prototype && void 0 !== a.prototype[e]) return a.prototype[e]
          }
        else if (a.prototype) return a.prototype[e]
      }
      self.Sk.builtin.type.mroMerge_ = function(a) {
        for (var b, c, d, e, f, g, h = []; ; ) {
          for (c = 0; c < a.length && ((b = a[c]), 0 === b.length); ++c);
          if (c === a.length) return h
          d = []
          for (c = 0; c < a.length; ++c)
            if (((b = a[c]), 0 !== b.length)) {
              g = b[0]
              f = 0
              a: for (; f < a.length; ++f)
                for (e = a[f], b = 1; b < e.length; ++b) if (e[b] === g) break a
              f === a.length && d.push(g)
            }
          if (0 === d.length)
            throw new self.Sk.builtin.TypeError(
              "Inconsistent precedences in type hierarchy",
            )
          d = d[0]
          h.push(d)
          for (c = 0; c < a.length; ++c)
            (b = a[c]), 0 < b.length && b[0] === d && b.splice(0, 1)
        }
      }
      self.Sk.builtin.type.buildMRO_ = function(a) {
        var b = [[a]],
          c = a.$d.mp$subscript(self.Sk.builtin.type.basesStr_)
        for (a = 0; a < c.v.length; ++a)
          b.push(self.Sk.builtin.type.buildMRO_(c.v[a]))
        var d = []
        for (a = 0; a < c.v.length; ++a) d.push(c.v[a])
        b.push(d)
        return self.Sk.builtin.type.mroMerge_(b)
      }
      self.Sk.builtin.type.buildMRO = function(a) {
        return new self.Sk.builtin.tuple(self.Sk.builtin.type.buildMRO_(a))
      }
      self.Sk.builtin.type.prototype.tp$richcompare = function(a, b) {
        if (a.ob$type == self.Sk.builtin.type && this.$r && a.$r) {
          var c = this.$r()
          a = a.$r()
          return c.tp$richcompare(a, b)
        }
      }
      self.Sk.builtin.type.prototype.__format__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__format__", arguments.length, 1, 2)
        return new self.Sk.builtin.str(a)
      }
      self.Sk.builtin.type.pythonFunctions = ["__format__"]
    },
    function(m, p) {
      self.Sk.abstr = {}
      self.Sk.abstr.typeName = function(a) {
        return void 0 !== a.tp$name ? a.tp$name : "<invalid type>"
      }
      self.Sk.abstr.binop_type_error = function(a, b, c) {
        a = self.Sk.abstr.typeName(a)
        b = self.Sk.abstr.typeName(b)
        throw new self.Sk.builtin.TypeError(
          "unsupported operand type(s) for " +
            c +
            ": '" +
            a +
            "' and '" +
            b +
            "'",
        )
      }
      self.Sk.abstr.unop_type_error = function(a, b) {
        a = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError(
          "bad operand type for unary " +
            { UAdd: "+", USub: "-", Invert: "~" }[b] +
            ": '" +
            a +
            "'",
        )
      }
      self.Sk.abstr.boNameToSlotFuncLhs_ = function(a, b) {
        if (null !== a)
          switch (b) {
            case "Add":
              return a.nb$add ? a.nb$add : a.__add__
            case "Sub":
              return a.nb$subtract ? a.nb$subtract : a.__sub__
            case "Mult":
              return a.nb$multiply ? a.nb$multiply : a.__mul__
            case "MatMult":
              if (self.Sk.__future__.python3)
                return a.tp$matmul ? a.tp$matmul : a.__matmul__
            case "Div":
              return a.nb$divide ? a.nb$divide : a.__div__
            case "FloorDiv":
              return a.nb$floor_divide ? a.nb$floor_divide : a.__floordiv__
            case "Mod":
              return a.nb$remainder ? a.nb$remainder : a.__mod__
            case "DivMod":
              return a.nb$divmod ? a.nb$divmod : a.__divmod__
            case "Pow":
              return a.nb$power ? a.nb$power : a.__pow__
            case "LShift":
              return a.nb$lshift ? a.nb$lshift : a.__lshift__
            case "RShift":
              return a.nb$rshift ? a.nb$rshift : a.__rshift__
            case "BitAnd":
              return a.nb$and ? a.nb$and : a.__and__
            case "BitXor":
              return a.nb$xor ? a.nb$xor : a.__xor__
            case "BitOr":
              return a.nb$or ? a.nb$or : a.__or__
          }
      }
      self.Sk.abstr.boNameToSlotFuncRhs_ = function(a, b) {
        if (null !== a)
          switch (b) {
            case "Add":
              return a.nb$reflected_add ? a.nb$reflected_add : a.__radd__
            case "Sub":
              return a.nb$reflected_subtract
                ? a.nb$reflected_subtract
                : a.__rsub__
            case "Mult":
              return a.nb$reflected_multiply
                ? a.nb$reflected_multiply
                : a.__rmul__
            case "MatMult":
              if (self.Sk.__future__.python3)
                return a.tp$reflected_matmul
                  ? a.tp$reflected_matmul
                  : a.__rmatmul__
            case "Div":
              return a.nb$reflected_divide ? a.nb$reflected_divide : a.__rdiv__
            case "FloorDiv":
              return a.nb$reflected_floor_divide
                ? a.nb$reflected_floor_divide
                : a.__rfloordiv__
            case "Mod":
              return a.nb$reflected_remainder
                ? a.nb$reflected_remainder
                : a.__rmod__
            case "DivMod":
              return a.nb$reflected_divmod
                ? a.nb$reflected_divmod
                : a.__rdivmod__
            case "Pow":
              return a.nb$reflected_power ? a.nb$reflected_power : a.__rpow__
            case "LShift":
              return a.nb$reflected_lshift
                ? a.nb$reflected_lshift
                : a.__rlshift__
            case "RShift":
              return a.nb$reflected_rshift
                ? a.nb$reflected_rshift
                : a.__rrshift__
            case "BitAnd":
              return a.nb$reflected_and ? a.nb$reflected_and : a.__rand__
            case "BitXor":
              return a.nb$reflected_xor ? a.nb$reflected_xor : a.__rxor__
            case "BitOr":
              return a.nb$reflected_or ? a.nb$reflected_or : a.__ror__
          }
      }
      self.Sk.abstr.iboNameToSlotFunc_ = function(a, b) {
        switch (b) {
          case "Add":
            return a.nb$inplace_add ? a.nb$inplace_add : a.__iadd__
          case "Sub":
            return a.nb$inplace_subtract ? a.nb$inplace_subtract : a.__isub__
          case "Mult":
            return a.nb$inplace_multiply ? a.nb$inplace_multiply : a.__imul__
          case "MatMult":
            if (self.Sk.__future__.python3)
              return a.tp$inplace_matmul ? a.tp$inplace_matmul : a.__imatmul__
          case "Div":
            return a.nb$inplace_divide ? a.nb$inplace_divide : a.__idiv__
          case "FloorDiv":
            return a.nb$inplace_floor_divide
              ? a.nb$inplace_floor_divide
              : a.__ifloordiv__
          case "Mod":
            return a.nb$inplace_remainder
          case "Pow":
            return a.nb$inplace_power
          case "LShift":
            return a.nb$inplace_lshift ? a.nb$inplace_lshift : a.__ilshift__
          case "RShift":
            return a.nb$inplace_rshift ? a.nb$inplace_rshift : a.__irshift__
          case "BitAnd":
            return a.nb$inplace_and
          case "BitOr":
            return a.nb$inplace_or
          case "BitXor":
            return a.nb$inplace_xor ? a.nb$inplace_xor : a.__ixor__
        }
      }
      self.Sk.abstr.uoNameToSlotFunc_ = function(a, b) {
        if (null !== a)
          switch (b) {
            case "USub":
              return a.nb$negative ? a.nb$negative : a.__neg__
            case "UAdd":
              return a.nb$positive ? a.nb$positive : a.__pos__
            case "Invert":
              return a.nb$invert ? a.nb$invert : a.__invert__
          }
      }
      self.Sk.abstr.binary_op_ = function(a, b, c) {
        var d = b.constructor.prototype instanceof a.constructor
        if (d) {
          var e = self.Sk.abstr.boNameToSlotFuncRhs_(b, c)
          if (
            void 0 !== e &&
            ((e = e.call ? e.call(b, a) : self.Sk.misceval.callsimArray(e, [b, a])),
            void 0 !== e && e !== self.Sk.builtin.NotImplemented.NotImplemented$)
          )
            return e
        }
        e = self.Sk.abstr.boNameToSlotFuncLhs_(a, c)
        if (
          (void 0 !== e &&
            ((e = e.call ? e.call(a, b) : self.Sk.misceval.callsimArray(e, [a, b])),
            void 0 !== e && e !== self.Sk.builtin.NotImplemented.NotImplemented$)) ||
          (!d &&
            ((e = self.Sk.abstr.boNameToSlotFuncRhs_(b, c)),
            void 0 !== e &&
              ((e = e.call
                ? e.call(b, a)
                : self.Sk.misceval.callsimArray(e, [b, a])),
              void 0 !== e && e !== self.Sk.builtin.NotImplemented.NotImplemented$)))
        )
          return e
        self.Sk.abstr.binop_type_error(a, b, c)
      }
      self.Sk.abstr.binary_iop_ = function(a, b, c) {
        var d = self.Sk.abstr.iboNameToSlotFunc_(a, c)
        return void 0 !== d &&
          ((d = d.call ? d.call(a, b) : self.Sk.misceval.callsimArray(d, [a, b])),
          void 0 !== d && d !== self.Sk.builtin.NotImplemented.NotImplemented$)
          ? d
          : self.Sk.abstr.binary_op_(a, b, c)
      }
      self.Sk.abstr.unary_op_ = function(a, b) {
        var c = self.Sk.abstr.uoNameToSlotFunc_(a, b)
        if (
          void 0 !== c &&
          ((c = c.call ? c.call(a) : self.Sk.misceval.callsimArray(c, [a])),
          void 0 !== c)
        )
          return c
        self.Sk.abstr.unop_type_error(a, b)
      }
      self.Sk.abstr.numOpAndPromote = function(a, b, c) {
        if (null !== a && null !== b) {
          if ("number" === typeof a && "number" === typeof b)
            return (
              (c = c(a, b)),
              (c > self.Sk.builtin.int_.threshold$ ||
                c < -self.Sk.builtin.int_.threshold$) &&
              Math.floor(c) === c
                ? [self.Sk.builtin.lng.fromInt$(a), self.Sk.builtin.lng.fromInt$(b)]
                : c
            )
          if (void 0 === a || void 0 === b)
            throw new self.Sk.builtin.NameError("Undefined variable in expression")
          if (a.constructor === self.Sk.builtin.lng) return [a, b]
          if (
            (a.constructor !== self.Sk.builtin.int_ &&
              a.constructor !== self.Sk.builtin.float_) ||
            b.constructor !== self.Sk.builtin.complex
          ) {
            if (
              a.constructor === self.Sk.builtin.int_ ||
              a.constructor === self.Sk.builtin.float_
            )
              return [a, b]
            if ("number" === typeof a) return (a = self.Sk.builtin.assk$(a)), [a, b]
          } else return (a = new self.Sk.builtin.complex(a)), [a, b]
        }
      }
      self.Sk.abstr.boNumPromote_ = {
        Add: function(a, b) {
          return a + b
        },
        Sub: function(a, b) {
          return a - b
        },
        Mult: function(a, b) {
          return a * b
        },
        Mod: function(a, b) {
          if (0 === b)
            throw new self.Sk.builtin.ZeroDivisionError("division or modulo by zero")
          a %= b
          return 0 > a * b ? a + b : a
        },
        Div: function(a, b) {
          if (0 === b)
            throw new self.Sk.builtin.ZeroDivisionError("division or modulo by zero")
          return a / b
        },
        FloorDiv: function(a, b) {
          if (0 === b)
            throw new self.Sk.builtin.ZeroDivisionError("division or modulo by zero")
          return Math.floor(a / b)
        },
        Pow: Math.pow,
        BitAnd: function(a, b) {
          a &= b
          0 > a && (a += 4294967296)
          return a
        },
        BitOr: function(a, b) {
          a |= b
          0 > a && (a += 4294967296)
          return a
        },
        BitXor: function(a, b) {
          a ^= b
          0 > a && (a += 4294967296)
          return a
        },
        LShift: function(a, b) {
          if (0 > b) throw new self.Sk.builtin.ValueError("negative shift count")
          var c = a << b
          return c > a ? c : a * Math.pow(2, b)
        },
        RShift: function(a, b) {
          if (0 > b) throw new self.Sk.builtin.ValueError("negative shift count")
          var c = a >> b
          0 < a && 0 > c && (c &= Math.pow(2, 32 - b) - 1)
          return c
        },
      }
      self.Sk.abstr.numberBinOp = function(a, b, c) {
        var d = self.Sk.abstr.boNumPromote_[c]
        if (void 0 !== d) {
          d = self.Sk.abstr.numOpAndPromote(a, b, d)
          if ("number" === typeof d) return d
          if (
            (void 0 !== d && d.constructor === self.Sk.builtin.int_) ||
            (void 0 !== d && d.constructor === self.Sk.builtin.float_) ||
            (void 0 !== d && d.constructor === self.Sk.builtin.lng)
          )
            return d
          void 0 !== d && ((a = d[0]), (b = d[1]))
        }
        return self.Sk.abstr.binary_op_(a, b, c)
      }
      self.Sk.exportSymbol("Sk.abstr.numberBinOp", self.Sk.abstr.numberBinOp)
      self.Sk.abstr.numberInplaceBinOp = function(a, b, c) {
        var d = self.Sk.abstr.boNumPromote_[c]
        if (void 0 !== d) {
          d = self.Sk.abstr.numOpAndPromote(a, b, d)
          if ("number" === typeof d) return d
          if (
            (void 0 !== d && d.constructor === self.Sk.builtin.int_) ||
            (void 0 !== d && d.constructor === self.Sk.builtin.float_) ||
            (void 0 !== d && d.constructor === self.Sk.builtin.lng)
          )
            return d
          void 0 !== d && ((a = d[0]), (b = d[1]))
        }
        return self.Sk.abstr.binary_iop_(a, b, c)
      }
      self.Sk.exportSymbol(
        "Sk.abstr.numberInplaceBinOp",
        self.Sk.abstr.numberInplaceBinOp,
      )
      self.Sk.abstr.numberUnaryOp = function(a, b) {
        if ("Not" === b)
          return self.Sk.misceval.isTrue(a)
            ? self.Sk.builtin.bool.false$
            : self.Sk.builtin.bool.true$
        if (a instanceof self.Sk.builtin.bool) {
          var c = self.Sk.builtin.asnum$(a)
          if ("USub" === b) return new self.Sk.builtin.int_(-c)
          if ("UAdd" === b) return new self.Sk.builtin.int_(c)
          if ("Invert" === b) return new self.Sk.builtin.int_(~c)
        } else {
          if ("USub" === b && a.nb$negative) return a.nb$negative()
          if ("UAdd" === b && a.nb$positive) return a.nb$positive()
          if ("Invert" === b && a.nb$invert) return a.nb$invert()
        }
        return self.Sk.abstr.unary_op_(a, b)
      }
      self.Sk.exportSymbol("Sk.abstr.numberUnaryOp", self.Sk.abstr.numberUnaryOp)
      self.Sk.abstr.fixSeqIndex_ = function(a, b) {
        b = self.Sk.builtin.asnum$(b)
        0 > b && a.sq$length && (b += a.sq$length())
        return b
      }
      self.Sk.abstr.sequenceContains = function(a, b, c) {
        if (a.sq$contains) return a.sq$contains(b)
        var d = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$contains)
        if (null != d)
          return self.Sk.misceval.isTrue(self.Sk.misceval.callsimArray(d, [a, b]))
        if (!self.Sk.builtin.checkIterable(a))
          throw ((c = self.Sk.abstr.typeName(a)),
          new self.Sk.builtin.TypeError(
            "argument of type '" + c + "' is not iterable",
          ))
        a = self.Sk.misceval.iterFor(
          self.Sk.abstr.iter(a),
          function(a) {
            return self.Sk.misceval.richCompareBool(a, b, "Eq")
              ? new self.Sk.misceval.Break(!0)
              : !1
          },
          !1,
        )
        return c ? a : self.Sk.misceval.retryOptionalSuspensionOrThrow(a)
      }
      self.Sk.abstr.sequenceConcat = function(a, b) {
        if (a.sq$concat) return a.sq$concat(b)
        a = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError(
          "'" + a + "' object can't be concatenated",
        )
      }
      self.Sk.abstr.sequenceGetIndexOf = function(a, b) {
        if (a.index) return self.Sk.misceval.callsimArray(a.index, [a, b])
        if (self.Sk.builtin.checkIterable(a)) {
          var c = 0
          var d = self.Sk.abstr.iter(a)
          for (a = d.tp$iternext(); void 0 !== a; a = d.tp$iternext()) {
            if (self.Sk.misceval.richCompareBool(b, a, "Eq"))
              return new self.Sk.builtin.int_(c)
            c += 1
          }
          throw new self.Sk.builtin.ValueError(
            "sequence.index(x): x not in sequence",
          )
        }
        b = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError(
          "argument of type '" + b + "' is not iterable",
        )
      }
      self.Sk.abstr.sequenceGetCountOf = function(a, b) {
        if (a.count) return self.Sk.misceval.callsimArray(a.count, [a, b])
        if (self.Sk.builtin.checkIterable(a)) {
          var c = 0
          var d = self.Sk.abstr.iter(a)
          for (a = d.tp$iternext(); void 0 !== a; a = d.tp$iternext())
            self.Sk.misceval.richCompareBool(b, a, "Eq") && (c += 1)
          return new self.Sk.builtin.int_(c)
        }
        b = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError(
          "argument of type '" + b + "' is not iterable",
        )
      }
      self.Sk.abstr.sequenceGetItem = function(a, b, c) {
        if (a.mp$subscript) return a.mp$subscript(b)
        a = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError("'" + a + "' object is unsubscriptable")
      }
      self.Sk.abstr.sequenceSetItem = function(a, b, c, d) {
        if (a.mp$ass_subscript) return a.mp$ass_subscript(b, c)
        a = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError(
          "'" + a + "' object does not support item assignment",
        )
      }
      self.Sk.abstr.sequenceDelItem = function(a, b) {
        if (a.sq$del_item) (b = self.Sk.abstr.fixSeqIndex_(a, b)), a.sq$del_item(b)
        else
          throw ((a = self.Sk.abstr.typeName(a)),
          new self.Sk.builtin.TypeError(
            "'" + a + "' object does not support item deletion",
          ))
      }
      self.Sk.abstr.sequenceRepeat = function(a, b, c) {
        c = self.Sk.builtin.asnum$(c)
        if (void 0 === self.Sk.misceval.asIndex(c))
          throw ((a = self.Sk.abstr.typeName(c)),
          new self.Sk.builtin.TypeError(
            "can't multiply sequence by non-int of type '" + a + "'",
          ))
        return a.call(b, c)
      }
      self.Sk.abstr.sequenceGetSlice = function(a, b, c) {
        if (a.sq$slice)
          return (
            (b = self.Sk.abstr.fixSeqIndex_(a, b)),
            (c = self.Sk.abstr.fixSeqIndex_(a, c)),
            a.sq$slice(b, c)
          )
        if (a.mp$subscript) return a.mp$subscript(new self.Sk.builtin.slice(b, c))
        a = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError("'" + a + "' object is unsliceable")
      }
      self.Sk.abstr.sequenceDelSlice = function(a, b, c) {
        if (a.sq$del_slice)
          (b = self.Sk.abstr.fixSeqIndex_(a, b)),
            (c = self.Sk.abstr.fixSeqIndex_(a, c)),
            a.sq$del_slice(b, c)
        else
          throw ((a = self.Sk.abstr.typeName(a)),
          new self.Sk.builtin.TypeError(
            "'" + a + "' doesn't support slice deletion",
          ))
      }
      self.Sk.abstr.sequenceSetSlice = function(a, b, c, d) {
        if (a.sq$ass_slice)
          (b = self.Sk.abstr.fixSeqIndex_(a, b)),
            (c = self.Sk.abstr.fixSeqIndex_(a, c)),
            a.sq$ass_slice(b, c, d)
        else if (a.mp$ass_subscript)
          a.mp$ass_subscript(new self.Sk.builtin.slice(b, c), d)
        else
          throw ((a = self.Sk.abstr.typeName(a)),
          new self.Sk.builtin.TypeError(
            "'" + a + "' object doesn't support slice assignment",
          ))
      }
      self.Sk.abstr.sequenceUnpack = function(a, b) {
        var c = [],
          d
        if (!self.Sk.builtin.checkIterable(a))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not iterable",
          )
        a = self.Sk.abstr.iter(a)
        for (
          d = a.tp$iternext();
          void 0 !== d && c.length < b;
          d = a.tp$iternext()
        )
          c.push(d)
        if (c.length < b)
          throw new self.Sk.builtin.ValueError(
            "need more than " + c.length + " values to unpack",
          )
        if (void 0 !== d)
          throw new self.Sk.builtin.ValueError("too many values to unpack")
        return c
      }
      self.Sk.abstr.mappingUnpackIntoKeywordArray = function(a, b, c) {
        return self.Sk.misceval.chain(
          b.tp$getattr(new self.Sk.builtin.str("items")),
          function(a) {
            if (!a) throw new self.Sk.builtin.TypeError("Object is not a mapping")
            return self.Sk.misceval.callsimOrSuspend(a)
          },
          function(b) {
            return self.Sk.misceval.iterFor(self.Sk.abstr.iter(b), function(b) {
              if (!b || !b.v)
                throw new self.Sk.builtin.TypeError(
                  "Object is not a mapping; items() does not return tuples",
                )
              if (!(b.v[0] instanceof self.Sk.builtin.str))
                throw new self.Sk.builtin.TypeError(
                  (c.tp$name ? c.tp$name + ":" : "") +
                    "keywords must be strings",
                )
              a.push(b.v[0].v, b.v[1])
            })
          },
        )
      }
      self.Sk.abstr.objectFormat = function(a, b) {
        var c = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$format)
        if (null == c)
          throw new self.Sk.builtin.TypeError(
            "Type " + self.Sk.abstr.typeName(a) + " doesn't define __format__",
          )
        a = self.Sk.misceval.callsimArray(c, [a, b])
        if (!self.Sk.builtin.checkString(a))
          throw new self.Sk.builtin.TypeError(
            "__format__ must return a str, not " + self.Sk.abstr.typeName(a),
          )
        return a
      }
      self.Sk.abstr.objectAdd = function(a, b) {
        if (a.nb$add) return a.nb$add(b)
        a = self.Sk.abstr.typeName(a)
        b = self.Sk.abstr.typeName(b)
        throw new self.Sk.builtin.TypeError(
          "unsupported operand type(s) for +: '" + a + "' and '" + b + "'",
        )
      }
      self.Sk.abstr.objectNegative = function(a) {
        var b = self.Sk.builtin.asnum$(a)
        a instanceof self.Sk.builtin.bool && (a = new self.Sk.builtin.int_(b))
        if (a.nb$negative) return a.nb$negative()
        a = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError(
          "bad operand type for unary -: '" + a + "'",
        )
      }
      self.Sk.abstr.objectPositive = function(a) {
        var b = self.Sk.abstr.typeName(a),
          c = self.Sk.builtin.asnum$(a)
        a instanceof self.Sk.builtin.bool && (a = new self.Sk.builtin.int_(c))
        if (a.nb$negative) return a.nb$positive()
        throw new self.Sk.builtin.TypeError(
          "bad operand type for unary +: '" + b + "'",
        )
      }
      self.Sk.abstr.objectDelItem = function(a, b) {
        if (null !== a) {
          if (a.mp$del_subscript) {
            a.mp$del_subscript(b)
            return
          }
          if (a.sq$ass_item) {
            var c = self.Sk.misceval.asIndex(b)
            if (void 0 === c)
              throw ((a = self.Sk.abstr.typeName(b)),
              new self.Sk.builtin.TypeError(
                "sequence index must be integer, not '" + a + "'",
              ))
            self.Sk.abstr.sequenceDelItem(a, c)
            return
          }
        }
        a = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError(
          "'" + a + "' object does not support item deletion",
        )
      }
      self.Sk.exportSymbol("Sk.abstr.objectDelItem", self.Sk.abstr.objectDelItem)
      self.Sk.abstr.objectGetItem = function(a, b, c) {
        if (null !== a) {
          if (a.tp$getitem) return a.tp$getitem(b, c)
          if (a.mp$subscript) return a.mp$subscript(b, c)
          if (self.Sk.misceval.isIndex(b) && a.sq$item)
            return self.Sk.abstr.sequenceGetItem(a, self.Sk.misceval.asIndex(b), c)
        }
        a = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError("'" + a + "' does not support indexing")
      }
      self.Sk.exportSymbol("Sk.abstr.objectGetItem", self.Sk.abstr.objectGetItem)
      self.Sk.abstr.objectSetItem = function(a, b, c, d) {
        if (null !== a) {
          if (a.tp$setitem) return a.tp$setitem(b, c, d)
          if (a.mp$ass_subscript) return a.mp$ass_subscript(b, c, d)
          if (self.Sk.misceval.isIndex(b) && a.sq$ass_item)
            return self.Sk.abstr.sequenceSetItem(a, self.Sk.misceval.asIndex(b), c, d)
        }
        a = self.Sk.abstr.typeName(a)
        throw new self.Sk.builtin.TypeError(
          "'" + a + "' does not support item assignment",
        )
      }
      self.Sk.exportSymbol("Sk.abstr.objectSetItem", self.Sk.abstr.objectSetItem)
      self.Sk.abstr.gattr = function(a, b, c) {
        var d,
          e = self.Sk.abstr.typeName(a),
          f = b.$jsstr()
        if (null === a)
          throw new self.Sk.builtin.AttributeError(
            "'" + e + "' object has no attribute '" + f + "'",
          )
        void 0 !== a.tp$getattr && (d = a.tp$getattr(b, c))
        d = self.Sk.misceval.chain(d, function(a) {
          if (void 0 === a)
            throw new self.Sk.builtin.AttributeError(
              "'" + e + "' object has no attribute '" + f + "'",
            )
          return a
        })
        return c ? d : self.Sk.misceval.retryOptionalSuspensionOrThrow(d)
      }
      self.Sk.exportSymbol("Sk.abstr.gattr", self.Sk.abstr.gattr)
      self.Sk.abstr.sattr = function(a, b, c, d) {
        var e = self.Sk.abstr.typeName(a),
          f = b.$jsstr()
        if (null === a)
          throw new self.Sk.builtin.AttributeError(
            "'" + e + "' object has no attribute '" + f + "'",
          )
        if (void 0 !== a.tp$setattr) return a.tp$setattr(b, c, d)
        throw new self.Sk.builtin.AttributeError(
          "'" + e + "' object has no attribute '" + f + "'",
        )
      }
      self.Sk.exportSymbol("Sk.abstr.sattr", self.Sk.abstr.sattr)
      self.Sk.abstr.iternext = function(a, b) {
        return a.tp$iternext(b)
      }
      self.Sk.exportSymbol("Sk.abstr.iternext", self.Sk.abstr.iternext)
      self.Sk.abstr.iter = function(a) {
        var b,
          c = function(a) {
            this.idx = 0
            this.myobj = a
            this.getitem = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$getitem)
            this.tp$iternext = function() {
              try {
                var a = self.Sk.misceval.callsimArray(this.getitem, [
                  this.myobj,
                  self.Sk.ffi.remapToPy(this.idx),
                ])
              } catch (g) {
                if (
                  g instanceof self.Sk.builtin.IndexError ||
                  g instanceof self.Sk.builtin.StopIteration
                )
                  return
                throw g
              }
              this.idx++
              return a
            }
          }
        if (
          a.tp$getattr &&
          (b = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$iter))
        ) {
          var d = self.Sk.misceval.callsimArray(b, [a])
          if (d.tp$iternext) return d
        }
        if (a.tp$iter)
          try {
            if (((d = a.tp$iter()), d.tp$iternext)) return d
          } catch (e) {}
        if (self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$getitem)) return new c(a)
        throw new self.Sk.builtin.TypeError(
          "'" + self.Sk.abstr.typeName(a) + "' object is not iterable",
        )
      }
      self.Sk.exportSymbol("Sk.abstr.iter", self.Sk.abstr.iter)
      self.Sk.abstr.lookupSpecial = function(a, b) {
        if (a.ob$type) a = a.ob$type
        else return null
        return self.Sk.builtin.type.typeLookup(a, b)
      }
      self.Sk.exportSymbol("Sk.abstr.lookupSpecial", self.Sk.abstr.lookupSpecial)
      self.Sk.abstr.markUnhashable = function(a) {
        a = a.prototype
        a.__hash__ = self.Sk.builtin.none.none$
        a.tp$hash = self.Sk.builtin.none.none$
      }
      self.Sk.abstr.inherits = function(a, b) {
        function c() {}
        c.prototype = b.prototype
        a.superClass_ = b.prototype
        a.prototype = new c()
        a.prototype.constructor = a
      }
      self.Sk.abstr.setUpInheritance = function(a, b, c) {
        self.Sk.abstr.inherits(b, c)
        b.prototype.tp$base = c
        b.prototype.tp$name = a
        b.prototype.ob$type = self.Sk.builtin.type.makeIntoTypeObj(a, b)
      }
      self.Sk.abstr.superConstructor = function(a, b, c) {
        var d = Array.prototype.slice.call(arguments, 2)
        a.prototype.tp$base.apply(b, d)
      }
    },
    function(m, p) {
      self.Sk.builtin.object = function() {
        return this instanceof self.Sk.builtin.object
          ? this
          : new self.Sk.builtin.object()
      }
      self.Sk.builtin.object.prototype.__init__ = function() {
        return self.Sk.builtin.none.none$
      }
      self.Sk.builtin.object.prototype.__init__.co_kwargs = 1
      self.Sk.builtin._tryGetSubscript = function(a, b) {
        try {
          return a.mp$subscript(b)
        } catch (c) {}
      }
      self.Sk.exportSymbol(
        "Sk.builtin._tryGetSubscript",
        self.Sk.builtin._tryGetSubscript,
      )
      self.Sk.builtin.object.prototype.GenericGetAttr = function(a, b) {
        var c,
          d,
          e = a.$jsstr()
        var f = this.ob$type
        self.Sk.asserts.assert(void 0 !== f, "object has no ob$type!")
        if ((d = this.$d || this.constructor.$d))
          if (
            (d.mp$lookup
              ? (c = d.mp$lookup(a))
              : d.mp$subscript
              ? (c = self.Sk.builtin._tryGetSubscript(d, a))
              : "object" === typeof d && (c = d[e]),
            void 0 !== c)
          )
            return c
        d = self.Sk.builtin.type.typeLookup(f, a)
        if (void 0 !== d && null !== d && (c = d.tp$descr_get))
          return c.call(d, this, this.ob$type, b)
        if (void 0 !== d) return d
        d = self.Sk.builtin.type.typeLookup(f, self.Sk.builtin.str.$getattr)
        if (void 0 !== d && null !== d) {
          var g = (c = d.tp$descr_get) ? c.call(d, this, this.ob$type) : d
          c = self.Sk.misceval.tryCatch(
            function() {
              return self.Sk.misceval.callsimOrSuspendArray(g, [a])
            },
            function(a) {
              if (!(a instanceof self.Sk.builtin.AttributeError)) throw a
            },
          )
          return b ? c : self.Sk.misceval.retryOptionalSuspensionOrThrow(c)
        }
      }
      self.Sk.exportSymbol(
        "Sk.builtin.object.prototype.GenericGetAttr",
        self.Sk.builtin.object.prototype.GenericGetAttr,
      )
      self.Sk.builtin.object.prototype.GenericPythonGetAttr = function(a, b) {
        a = self.Sk.builtin.object.prototype.GenericGetAttr.call(a, b, !0)
        if (void 0 === a) throw new self.Sk.builtin.AttributeError(b)
        return a
      }
      self.Sk.exportSymbol(
        "Sk.builtin.object.prototype.GenericPythonGetAttr",
        self.Sk.builtin.object.prototype.GenericPythonGetAttr,
      )
      self.Sk.builtin.object.prototype.GenericSetAttr = function(a, b, c) {
        var d = self.Sk.abstr.typeName(this),
          e = a.$jsstr(),
          f = this.ob$type,
          g
        self.Sk.asserts.assert(void 0 !== f, "object has no ob$type!")
        var h = this.$d || this.constructor.$d
        if ("__class__" == e) {
          if (void 0 === b.tp$mro || void 0 === b.tp$name)
            throw new self.Sk.builtin.TypeError(
              "attempted to assign non-class to __class__",
            )
          this.ob$type = b
          this.tp$name = b.tp$name
        } else {
          f = self.Sk.builtin.type.typeLookup(f, a)
          if (void 0 !== f && null !== f && (g = f.tp$descr_set))
            return g.call(f, this, b, c)
          if (h.mp$ass_subscript) {
            if (
              this instanceof self.Sk.builtin.object &&
              !this.ob$type.sk$klass &&
              void 0 === h.mp$lookup(a)
            )
              throw new self.Sk.builtin.AttributeError(
                "'" +
                  d +
                  "' object has no attribute '" +
                  self.Sk.unfixReserved(e) +
                  "'",
              )
            h.mp$ass_subscript(a, b)
          } else "object" === typeof h && (h[e] = b)
        }
      }
      self.Sk.exportSymbol(
        "Sk.builtin.object.prototype.GenericSetAttr",
        self.Sk.builtin.object.prototype.GenericSetAttr,
      )
      self.Sk.builtin.object.prototype.GenericPythonSetAttr = function(a, b, c) {
        return self.Sk.builtin.object.prototype.GenericSetAttr.call(a, b, c, !0)
      }
      self.Sk.exportSymbol(
        "Sk.builtin.object.prototype.GenericPythonSetAttr",
        self.Sk.builtin.object.prototype.GenericPythonSetAttr,
      )
      self.Sk.builtin.object.prototype.HashNotImplemented = function() {
        throw new self.Sk.builtin.TypeError(
          "unhashable type: '" + self.Sk.abstr.typeName(this) + "'",
        )
      }
      self.Sk.builtin.object.prototype.tp$getattr =
        self.Sk.builtin.object.prototype.GenericGetAttr
      self.Sk.builtin.object.prototype.tp$setattr =
        self.Sk.builtin.object.prototype.GenericSetAttr
      self.Sk.builtin.object.prototype.__getattribute__ =
        self.Sk.builtin.object.prototype.GenericPythonGetAttr
      self.Sk.builtin.object.prototype.__setattr__ =
        self.Sk.builtin.object.prototype.GenericPythonSetAttr
      self.Sk.builtin.object.prototype.tp$name = "object"
      self.Sk.builtin.object.prototype.ob$type = self.Sk.builtin.type.makeIntoTypeObj(
        "object",
        self.Sk.builtin.object,
      )
      self.Sk.builtin.object.prototype.ob$type.sk$klass = void 0
      self.Sk.builtin.object.prototype.tp$descr_set = void 0
      self.Sk.builtin.object.prototype.__new__ = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__new__", arguments.length, 1, 1, !1, !1)
        return new a([], [])
      }
      self.Sk.builtin.object.prototype.__repr__ = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__repr__", arguments.length, 0, 0, !1, !0)
        return a.$r()
      }
      self.Sk.builtin.object.prototype.__format__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__format__", arguments.length, 2, 2)
        if (self.Sk.builtin.checkString(b)) {
          var c = self.Sk.ffi.remapToJs(b)
          if ("" !== c)
            throw new self.Sk.builtin.NotImplementedError(
              "format spec is not yet implemented",
            )
        } else {
          if (self.Sk.__future__.exceptions)
            throw new self.Sk.builtin.TypeError(
              "format() argument 2 must be str, not " + self.Sk.abstr.typeName(b),
            )
          throw new self.Sk.builtin.TypeError(
            "format expects arg 2 to be string or unicode, not " +
              self.Sk.abstr.typeName(b),
          )
        }
        return new self.Sk.builtin.str(a)
      }
      self.Sk.builtin.object.prototype.__str__ = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__str__", arguments.length, 0, 0, !1, !0)
        return a.$r()
      }
      self.Sk.builtin.object.prototype.__hash__ = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__hash__", arguments.length, 0, 0, !1, !0)
        return a.tp$hash()
      }
      self.Sk.builtin.object.prototype.__eq__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__eq__", arguments.length, 1, 1, !1, !0)
        return a.ob$eq(b)
      }
      self.Sk.builtin.object.prototype.__ne__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__ne__", arguments.length, 1, 1, !1, !0)
        return a.ob$ne(b)
      }
      self.Sk.builtin.object.prototype.__lt__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__lt__", arguments.length, 1, 1, !1, !0)
        return a.ob$lt(b)
      }
      self.Sk.builtin.object.prototype.__le__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__le__", arguments.length, 1, 1, !1, !0)
        return a.ob$le(b)
      }
      self.Sk.builtin.object.prototype.__gt__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__gt__", arguments.length, 1, 1, !1, !0)
        return a.ob$gt(b)
      }
      self.Sk.builtin.object.prototype.__ge__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__ge__", arguments.length, 1, 1, !1, !0)
        return a.ob$ge(b)
      }
      self.Sk.builtin.object.prototype.$r = function() {
        return new self.Sk.builtin.str("<object>")
      }
      self.Sk.builtin.hashCount = 1
      self.Sk.builtin.idCount = 1
      self.Sk.builtin.object.prototype.tp$hash = function() {
        this.$savedHash_ ||
          (this.$savedHash_ = new self.Sk.builtin.int_(self.Sk.builtin.hashCount++))
        return this.$savedHash_
      }
      self.Sk.builtin.object.prototype.ob$eq = function(a) {
        return this === a
          ? self.Sk.builtin.bool.true$
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.object.prototype.ob$ne = function(a) {
        return this === a
          ? self.Sk.builtin.bool.false$
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.object.prototype.ob$lt = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.object.prototype.ob$le = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.object.prototype.ob$gt = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.object.prototype.ob$ge = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.object.pythonFunctions = "__repr__ __str__ __hash__ __eq__ __ne__ __lt__ __le__ __gt__ __ge__ __getattribute__ __setattr__ __format__".split(
        " ",
      )
      self.Sk.builtin.none = function() {
        this.v = null
      }
      self.Sk.abstr.setUpInheritance("NoneType", self.Sk.builtin.none, self.Sk.builtin.object)
      self.Sk.builtin.none.prototype.$r = function() {
        return new self.Sk.builtin.str("None")
      }
      self.Sk.builtin.none.prototype.tp$hash = function() {
        return new self.Sk.builtin.int_(0)
      }
      self.Sk.builtin.none.none$ = new self.Sk.builtin.none()
      self.Sk.builtin.NotImplemented = function() {}
      self.Sk.abstr.setUpInheritance(
        "NotImplementedType",
        self.Sk.builtin.NotImplemented,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.NotImplemented.prototype.$r = function() {
        return new self.Sk.builtin.str("NotImplemented")
      }
      self.Sk.builtin.NotImplemented.NotImplemented$ = new self.Sk.builtin.NotImplemented()
      self.Sk.exportSymbol("Sk.builtin.none", self.Sk.builtin.none)
      self.Sk.exportSymbol("Sk.builtin.NotImplemented", self.Sk.builtin.NotImplemented)
    },
    function(m, p) {
      self.Sk.builtin.pyCheckArgs = function(a, b, c, d, e, f) {
        b = b.length
        void 0 === d && (d = Infinity)
        e && --b
        f && --b
        if (b < c || b > d)
          throw new self.Sk.builtin.TypeError(
            (c === d
              ? a + "() takes exactly " + c + " arguments"
              : b < c
              ? a + "() takes at least " + c + " arguments"
              : a + "() takes at most " + d + " arguments") +
              (" (" + b + " given)"),
          )
      }
      self.Sk.exportSymbol("Sk.builtin.pyCheckArgs", self.Sk.builtin.pyCheckArgs)
      self.Sk.builtin.pyCheckArgsLen = function(a, b, c, d, e, f) {
        void 0 === d && (d = Infinity)
        e && --b
        f && --b
        if (b < c || b > d)
          throw new self.Sk.builtin.TypeError(
            (c === d
              ? a + "() takes exactly " + c + " arguments"
              : b < c
              ? a + "() takes at least " + c + " arguments"
              : a + "() takes at most " + d + " arguments") +
              (" (" + b + " given)"),
          )
      }
      self.Sk.builtin.pyCheckType = function(a, b, c) {
        if (!c) throw new self.Sk.builtin.TypeError(a + " must be a " + b)
      }
      self.Sk.exportSymbol("Sk.builtin.pyCheckType", self.Sk.builtin.pyCheckType)
      self.Sk.builtin.checkSequence = function(a) {
        return null !== a && void 0 !== a.mp$subscript
      }
      self.Sk.exportSymbol("Sk.builtin.checkSequence", self.Sk.builtin.checkSequence)
      self.Sk.builtin.checkIterable = function(a) {
        var b = !1
        if (null !== a)
          try {
            return (b = self.Sk.abstr.iter(a)) ? !0 : !1
          } catch (c) {
            if (c instanceof self.Sk.builtin.TypeError) return !1
            throw c
          }
        return b
      }
      self.Sk.exportSymbol("Sk.builtin.checkIterable", self.Sk.builtin.checkIterable)
      self.Sk.builtin.checkCallable = function(a) {
        return "function" === typeof a ||
          a instanceof self.Sk.builtin.func ||
          a instanceof self.Sk.builtin.method ||
          void 0 !== self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$call)
          ? !0
          : !1
      }
      self.Sk.builtin.checkNumber = function(a) {
        return (
          null !== a &&
          ("number" === typeof a ||
            a instanceof self.Sk.builtin.int_ ||
            a instanceof self.Sk.builtin.float_ ||
            a instanceof self.Sk.builtin.lng)
        )
      }
      self.Sk.exportSymbol("Sk.builtin.checkNumber", self.Sk.builtin.checkNumber)
      self.Sk.builtin.checkComplex = function(a) {
        return self.Sk.builtin.complex._complex_check(a)
      }
      self.Sk.exportSymbol("Sk.builtin.checkComplex", self.Sk.builtin.checkComplex)
      self.Sk.builtin.checkInt = function(a) {
        return (
          null !== a &&
          (("number" === typeof a && a === (a | 0)) ||
            a instanceof self.Sk.builtin.int_ ||
            a instanceof self.Sk.builtin.lng)
        )
      }
      self.Sk.exportSymbol("Sk.builtin.checkInt", self.Sk.builtin.checkInt)
      self.Sk.builtin.checkFloat = function(a) {
        return null !== a && a instanceof self.Sk.builtin.float_
      }
      self.Sk.exportSymbol("Sk.builtin.checkFloat", self.Sk.builtin.checkFloat)
      self.Sk.builtin.checkString = function(a) {
        return null !== a && a.__class__ == self.Sk.builtin.str
      }
      self.Sk.exportSymbol("Sk.builtin.checkString", self.Sk.builtin.checkString)
      self.Sk.builtin.checkClass = function(a) {
        return null !== a && a.sk$type
      }
      self.Sk.exportSymbol("Sk.builtin.checkClass", self.Sk.builtin.checkClass)
      self.Sk.builtin.checkBool = function(a) {
        return a instanceof self.Sk.builtin.bool
      }
      self.Sk.exportSymbol("Sk.builtin.checkBool", self.Sk.builtin.checkBool)
      self.Sk.builtin.checkNone = function(a) {
        return a instanceof self.Sk.builtin.none
      }
      self.Sk.exportSymbol("Sk.builtin.checkNone", self.Sk.builtin.checkNone)
      self.Sk.builtin.checkFunction = function(a) {
        return null !== a && void 0 !== a.tp$call
      }
      self.Sk.exportSymbol("Sk.builtin.checkFunction", self.Sk.builtin.checkFunction)
      self.Sk.builtin.func = function(a, b, c, d) {
        if (!(this instanceof self.Sk.builtin.func))
          throw Error("builtin func should be called as a class with `new`")
        var e
        this.func_code = a
        this.func_globals = b || null
        if (void 0 !== d) for (e in d) c[e] = d[e]
        this.$d = { __name__: a.co_name, __class__: self.Sk.builtin.func }
        this.func_closure = c
        this.tp$name =
          (this.func_code &&
            this.func_code.co_name &&
            this.func_code.co_name.v) ||
          this.func_code.name ||
          "<native JS>"
        return this
      }
      self.Sk.abstr.setUpInheritance("function", self.Sk.builtin.func, self.Sk.builtin.object)
      self.Sk.exportSymbol("Sk.builtin.func", self.Sk.builtin.func)
      self.Sk.builtin.func.prototype.tp$name = "function"
      self.Sk.builtin.func.prototype.tp$descr_get = function(a, b) {
        self.Sk.asserts.assert(!(void 0 === a && void 0 === b))
        return b && b.tp$name in self.Sk.builtin && self.Sk.builtin[b.tp$name] === b
          ? new self.Sk.builtin.method(this, a, b, !0)
          : new self.Sk.builtin.method(this, a, b)
      }
      self.Sk.builtin.func.pythonFunctions = ["__get__"]
      self.Sk.builtin.func.prototype.__get__ = function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("__get__", arguments.length, 1, 2, !1, !0)
        if (b === self.Sk.builtin.none.none$ && c === self.Sk.builtin.none.none$)
          throw new self.Sk.builtin.TypeError("__get__(None, None) is invalid")
        return a.tp$descr_get(b, c)
      }
      self.Sk.builtin.func.prototype.tp$getname = function() {
        return (
          (this.func_code &&
            this.func_code.co_name &&
            this.func_code.co_name.v) ||
          this.func_code.name ||
          "<native JS>"
        )
      }
      self.Sk.builtin.func.prototype.tp$call = function(a, b) {
        var c = this.func_code.co_argcount
        void 0 === c &&
          (c = this.func_code.co_varnames
            ? this.func_code.co_varnames.length
            : a.length)
        let d = this.func_code.co_varnames || []
        var e = this.func_code.co_kwonlyargcount || 0
        let f = c + e,
          g
        this.func_code.co_kwargs && (g = [])
        var h = a.length
        let k = a.length <= c ? a : a.slice(0, c)
        if (this.func_code.co_varargs)
          (a = a.length > k.length ? a.slice(k.length) : []),
            (k[f] = new self.Sk.builtin.tuple(a))
        else if (h > c)
          throw new self.Sk.builtin.TypeError(
            this.tp$getname() +
              "() takes " +
              c +
              " positional argument" +
              (1 == c ? "" : "s") +
              " but " +
              h +
              (1 == h ? " was " : " were ") +
              " given",
          )
        if (b) {
          if (this.func_code.no_kw)
            throw new self.Sk.builtin.TypeError(
              this.tp$getname() + "() takes no keyword arguments",
            )
          for (a = 0; a < b.length; a += 2) {
            h = b[a]
            var l = b[a + 1],
              r = d.indexOf(h)
            if (0 <= r) {
              if (void 0 !== k[r])
                throw new self.Sk.builtin.TypeError(
                  this.tp$getname() +
                    "() got multiple values for argument '" +
                    h +
                    "'",
                )
              k[r] = l
            } else if (g) g.push(new self.Sk.builtin.str(h), l)
            else
              throw new self.Sk.builtin.TypeError(
                this.tp$getname() +
                  "() got an unexpected keyword argument '" +
                  h +
                  "'",
              )
          }
        }
        b = this.func_code.$defaults || []
        a = 0
        h = []
        l = !1
        for (r = c - b.length; a < r; a++)
          void 0 === k[a] && (h.push(d[a]), void 0 === d[a] && (l = !0))
        if (
          0 != h.length &&
          (this.func_code.co_argcount || this.func_code.co_varnames)
        )
          throw new self.Sk.builtin.TypeError(
            this.tp$getname() +
              "() missing " +
              h.length +
              " required argument" +
              (1 == h.length ? "" : "s") +
              (l ? "" : ": " + h.join(", ")),
          )
        for (; a < c; a++) void 0 === k[a] && (k[a] = b[a - r])
        if (0 < e) {
          e = []
          b = this.func_code.$kwdefs
          for (a = c; a < f; a++)
            void 0 === k[a] &&
              (void 0 !== b[a - c] ? (k[a] = b[a - c]) : e.push(d[a]))
          if (0 !== e.length)
            throw new self.Sk.builtin.TypeError(
              this.tp$getname() +
                "() missing " +
                e.length +
                " required keyword argument" +
                (1 == e.length ? "" : "s") +
                ": " +
                e.join(", "),
            )
        }
        if (this.func_closure) {
          if (d) for (c = k.length; c < d.length; c++) k.push(void 0)
          k.push(this.func_closure)
        }
        g && k.unshift(g)
        return this.func_code.apply(this.func_globals, k)
      }
      self.Sk.builtin.func.prototype.$r = function() {
        var a = this.tp$getname()
        return a in self.Sk.builtins && this === self.Sk.builtins[a]
          ? new self.Sk.builtin.str("<built-in function " + a + ">")
          : new self.Sk.builtin.str("<function " + a + ">")
      }
    },
    function(m, p) {
      self.Sk.builtin.range = function(a, b, c) {
        var d = [],
          e
        self.Sk.builtin.pyCheckArgsLen("range", arguments.length, 1, 3)
        self.Sk.builtin.pyCheckType("start", "integer", self.Sk.builtin.checkInt(a))
        void 0 !== b &&
          self.Sk.builtin.pyCheckType("stop", "integer", self.Sk.builtin.checkInt(b))
        void 0 !== c &&
          self.Sk.builtin.pyCheckType("step", "integer", self.Sk.builtin.checkInt(c))
        a = self.Sk.builtin.asnum$(a)
        b = self.Sk.builtin.asnum$(b)
        c = self.Sk.builtin.asnum$(c)
        void 0 === b && void 0 === c
          ? ((b = a), (a = 0), (c = 1))
          : void 0 === c && (c = 1)
        if (0 === c)
          throw new self.Sk.builtin.ValueError(
            "range() step argument must not be zero",
          )
        if (0 < c) for (e = a; e < b; e += c) d.push(new self.Sk.builtin.int_(e))
        else for (e = a; e > b; e += c) d.push(new self.Sk.builtin.int_(e))
        return new self.Sk.builtin.list(d)
      }
      self.Sk.builtin.asnum$ = function(a) {
        return void 0 === a || null === a
          ? a
          : a instanceof self.Sk.builtin.none
          ? null
          : a instanceof self.Sk.builtin.bool
          ? a.v
            ? 1
            : 0
          : "number" === typeof a
          ? a
          : "string" === typeof a
          ? a
          : a instanceof self.Sk.builtin.int_
          ? a.v
          : a instanceof self.Sk.builtin.float_
          ? a.v
          : a instanceof self.Sk.builtin.lng
          ? a.cantBeInt()
            ? a.str$(10, !0)
            : a.toInt$()
          : a.constructor === self.Sk.builtin.biginteger
          ? 0 <
              a.trueCompare(
                new self.Sk.builtin.biginteger(self.Sk.builtin.int_.threshold$),
              ) ||
            0 >
              a.trueCompare(
                new self.Sk.builtin.biginteger(-self.Sk.builtin.int_.threshold$),
              )
            ? a.toString()
            : a.intValue()
          : a
      }
      self.Sk.exportSymbol("Sk.builtin.asnum$", self.Sk.builtin.asnum$)
      self.Sk.builtin.assk$ = function(a) {
        return 0 === a % 1 ? new self.Sk.builtin.int_(a) : new self.Sk.builtin.float_(a)
      }
      self.Sk.exportSymbol("Sk.builtin.assk$", self.Sk.builtin.assk$)
      self.Sk.builtin.asnum$nofloat = function(a) {
        if (void 0 === a || null === a) return a
        if (a.constructor === self.Sk.builtin.none) return null
        if (a.constructor === self.Sk.builtin.bool) return a.v ? 1 : 0
        "number" === typeof a && (a = a.toString())
        a.constructor === self.Sk.builtin.int_ && (a = a.v.toString())
        a.constructor === self.Sk.builtin.float_ && (a = a.v.toString())
        a.constructor === self.Sk.builtin.lng && (a = a.str$(10, !0))
        a.constructor === self.Sk.builtin.biginteger && (a = a.toString())
        if (0 > a.indexOf(".") && 0 > a.indexOf("e") && 0 > a.indexOf("E"))
          return a
        var b = 0
        if (0 <= a.indexOf("e")) {
          var c = a.substr(0, a.indexOf("e"))
          b = a.substr(a.indexOf("e") + 1)
        } else
          0 <= a.indexOf("E")
            ? ((c = a.substr(0, a.indexOf("e"))),
              (b = a.substr(a.indexOf("E") + 1)))
            : (c = a)
        b = parseInt(b, 10)
        a = c.indexOf(".")
        if (0 > a) {
          if (0 <= b) {
            for (; 0 < b--; ) c += "0"
            return c
          }
          return c.length > -b ? c.substr(0, c.length + b) : 0
        }
        c =
          0 === a
            ? c.substr(1)
            : a < c.length
            ? c.substr(0, a) + c.substr(a + 1)
            : c.substr(0, a)
        for (a += b; a > c.length; ) c += "0"
        return (c = 0 >= a ? 0 : c.substr(0, a))
      }
      self.Sk.exportSymbol("Sk.builtin.asnum$nofloat", self.Sk.builtin.asnum$nofloat)
      self.Sk.builtin.round = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("round", arguments.length, 1, 2)
        if (!self.Sk.builtin.checkNumber(a)) {
          if (!self.Sk.builtin.checkFunction(a))
            throw new self.Sk.builtin.TypeError("a float is required")
          if (!self.Sk.__future__.exceptions)
            throw new self.Sk.builtin.AttributeError(
              self.Sk.abstr.typeName(a) + " instance has no attribute '__float__'",
            )
        }
        if (void 0 !== b && !self.Sk.misceval.isIndex(b))
          throw new self.Sk.builtin.TypeError(
            "'" +
              self.Sk.abstr.typeName(b) +
              "' object cannot be interpreted as an index",
          )
        if (!self.Sk.__future__.dunder_round && a.round$) return a.round$(a, b)
        var c = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$round)
        if (null != c)
          return self.Sk.builtin.checkFunction(a)
            ? self.Sk.misceval.callsimArray(c, [a])
            : self.Sk.misceval.callsimArray(c, [a, b])
        throw new self.Sk.builtin.TypeError("a float is required")
      }
      self.Sk.builtin.len = function(a) {
        self.Sk.builtin.pyCheckArgsLen("len", arguments.length, 1, 1)
        var b = function(a) {
          return new self.Sk.builtin.int_(a)
        }
        var c = function(a) {
          if (self.Sk.builtin.checkInt(a)) return b(a)
          if (self.Sk.__future__.exceptions)
            throw new self.Sk.builtin.TypeError(
              "'" +
                self.Sk.abstr.typeName(a) +
                "' object cannot be interpreted as an integer",
            )
          throw new self.Sk.builtin.TypeError("__len__() should return an int")
        }
        if (a.sq$length) return self.Sk.misceval.chain(a.sq$length(!0), c)
        if (a.mp$length) return self.Sk.misceval.chain(a.mp$length(), b)
        if (a.tp$length)
          if (self.Sk.builtin.checkFunction(a)) {
            c = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$len)
            if (null != c) return self.Sk.misceval.callsimArray(c, [a])
            if (!self.Sk.__future__.exceptions)
              throw new self.Sk.builtin.AttributeError(
                self.Sk.abstr.typeName(a) + " instance has no attribute '__len__'",
              )
          } else return self.Sk.misceval.chain(a.tp$length(!0), c)
        throw new self.Sk.builtin.TypeError(
          "object of type '" + self.Sk.abstr.typeName(a) + "' has no len()",
        )
      }
      self.Sk.builtin.min = function() {
        var a
        self.Sk.builtin.pyCheckArgsLen("min", arguments.length, 1)
        var b = self.Sk.misceval.arrayFromArguments(arguments)
        var c = b[0]
        if (void 0 === c)
          throw new self.Sk.builtin.ValueError("min() arg is an empty sequence")
        for (a = 1; a < b.length; ++a)
          self.Sk.misceval.richCompareBool(b[a], c, "Lt") && (c = b[a])
        return c
      }
      self.Sk.builtin.max = function() {
        var a
        self.Sk.builtin.pyCheckArgsLen("max", arguments.length, 1)
        var b = self.Sk.misceval.arrayFromArguments(arguments)
        var c = b[0]
        if (void 0 === c)
          throw new self.Sk.builtin.ValueError("max() arg is an empty sequence")
        for (a = 1; a < b.length; ++a)
          self.Sk.misceval.richCompareBool(b[a], c, "Gt") && (c = b[a])
        return c
      }
      self.Sk.builtin.any = function(a) {
        var b
        self.Sk.builtin.pyCheckArgsLen("any", arguments.length, 1, 1)
        if (!self.Sk.builtin.checkIterable(a))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not iterable",
          )
        var c = self.Sk.abstr.iter(a)
        for (b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
          if (self.Sk.misceval.isTrue(b)) return self.Sk.builtin.bool.true$
        return self.Sk.builtin.bool.false$
      }
      self.Sk.builtin.all = function(a) {
        var b
        self.Sk.builtin.pyCheckArgsLen("all", arguments.length, 1, 1)
        if (!self.Sk.builtin.checkIterable(a))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not iterable",
          )
        var c = self.Sk.abstr.iter(a)
        for (b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
          if (!self.Sk.misceval.isTrue(b)) return self.Sk.builtin.bool.false$
        return self.Sk.builtin.bool.true$
      }
      self.Sk.builtin.sum = function(a, b) {
        var c
        self.Sk.builtin.pyCheckArgsLen("sum", arguments.length, 1, 2)
        self.Sk.builtin.pyCheckType("iter", "iterable", self.Sk.builtin.checkIterable(a))
        if (void 0 !== b && self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError(
            "sum() can't sum strings [use ''.join(seq) instead]",
          )
        var d = void 0 === b ? new self.Sk.builtin.int_(0) : b
        var e = self.Sk.abstr.iter(a)
        for (c = e.tp$iternext(); void 0 !== c; c = e.tp$iternext()) {
          if (c instanceof self.Sk.builtin.float_) {
            var f = !0
            d instanceof self.Sk.builtin.float_ ||
              (d = new self.Sk.builtin.float_(self.Sk.builtin.asnum$(d)))
          } else
            c instanceof self.Sk.builtin.lng &&
              (f || d instanceof self.Sk.builtin.lng || (d = new self.Sk.builtin.lng(d)))
          if (void 0 !== d.nb$add) {
            var g = d.nb$add(c)
            if (
              void 0 !== g &&
              g !== self.Sk.builtin.NotImplemented.NotImplemented$
            ) {
              d = d.nb$add(c)
              continue
            }
          }
          throw new self.Sk.builtin.TypeError(
            "unsupported operand type(s) for +: '" +
              self.Sk.abstr.typeName(d) +
              "' and '" +
              self.Sk.abstr.typeName(c) +
              "'",
          )
        }
        return d
      }
      self.Sk.builtin.zip = function() {
        var a, b
        if (0 === arguments.length) return new self.Sk.builtin.list([])
        var c = []
        for (b = 0; b < arguments.length; b++)
          if (self.Sk.builtin.checkIterable(arguments[b]))
            c.push(self.Sk.abstr.iter(arguments[b]))
          else
            throw new self.Sk.builtin.TypeError(
              "argument " + b + " must support iteration",
            )
        var d = []
        for (a = !1; !a; ) {
          var e = []
          for (b = 0; b < arguments.length; b++) {
            var f = c[b].tp$iternext()
            if (void 0 === f) {
              a = !0
              break
            }
            e.push(f)
          }
          a || d.push(new self.Sk.builtin.tuple(e))
        }
        return new self.Sk.builtin.list(d)
      }
      self.Sk.builtin.abs = function(a) {
        self.Sk.builtin.pyCheckArgsLen("abs", arguments.length, 1, 1)
        if (a instanceof self.Sk.builtin.int_)
          return new self.Sk.builtin.int_(Math.abs(a.v))
        if (a instanceof self.Sk.builtin.float_)
          return new self.Sk.builtin.float_(Math.abs(a.v))
        if (self.Sk.builtin.checkNumber(a))
          return self.Sk.builtin.assk$(Math.abs(self.Sk.builtin.asnum$(a)))
        if (self.Sk.builtin.checkComplex(a))
          return self.Sk.misceval.callsimArray(a.__abs__, [a])
        if (a.tp$getattr) {
          var b = a.tp$getattr(self.Sk.builtin.str.$abs)
          return self.Sk.misceval.callsimArray(b)
        }
        throw new TypeError(
          "bad operand type for abs(): '" + self.Sk.abstr.typeName(a) + "'",
        )
      }
      self.Sk.builtin.fabs = function(a) {
        return self.Sk.builtin.abs(a)
      }
      self.Sk.builtin.ord = function(a) {
        self.Sk.builtin.pyCheckArgsLen("ord", arguments.length, 1, 1)
        if (!self.Sk.builtin.checkString(a))
          throw new self.Sk.builtin.TypeError(
            "ord() expected a string of length 1, but " +
              self.Sk.abstr.typeName(a) +
              " found",
          )
        if (1 !== a.v.length)
          throw new self.Sk.builtin.TypeError(
            "ord() expected a character, but string of length " +
              a.v.length +
              " found",
          )
        return new self.Sk.builtin.int_(a.v.charCodeAt(0))
      }
      self.Sk.builtin.chr = function(a) {
        self.Sk.builtin.pyCheckArgsLen("chr", arguments.length, 1, 1)
        if (!self.Sk.builtin.checkInt(a))
          throw new self.Sk.builtin.TypeError("an integer is required")
        a = self.Sk.builtin.asnum$(a)
        if (0 > a || 255 < a)
          throw new self.Sk.builtin.ValueError("chr() arg not in range(256)")
        return new self.Sk.builtin.str(String.fromCharCode(a))
      }
      self.Sk.builtin.unichr = function(a) {
        self.Sk.builtin.pyCheckArgsLen("chr", arguments.length, 1, 1)
        if (!self.Sk.builtin.checkInt(a))
          throw new self.Sk.builtin.TypeError("an integer is required")
        a = self.Sk.builtin.asnum$(a)
        try {
          return new self.Sk.builtin.str(String.fromCodePoint(a))
        } catch (b) {
          if (b instanceof RangeError)
            throw new self.Sk.builtin.ValueError(b.message)
          throw b
        }
      }
      self.Sk.builtin.int2str_ = function(a, b, c) {
        if (a instanceof self.Sk.builtin.lng) {
          var d = ""
          2 === b || self.Sk.__future__.python3 || (d = "L")
          b = a.str$(b, !1)
          return a.nb$isnegative()
            ? new self.Sk.builtin.str("-" + c + b + d)
            : new self.Sk.builtin.str(c + b + d)
        }
        a = self.Sk.misceval.asIndex(a)
        b = a.toString(b)
        return 0 > a
          ? new self.Sk.builtin.str("-" + c + b.slice(1))
          : new self.Sk.builtin.str(c + b)
      }
      self.Sk.builtin.hex = function(a) {
        self.Sk.builtin.pyCheckArgsLen("hex", arguments.length, 1, 1)
        if (!self.Sk.misceval.isIndex(a))
          throw new self.Sk.builtin.TypeError(
            "hex() argument can't be converted to hex",
          )
        return self.Sk.builtin.int2str_(a, 16, "0x")
      }
      self.Sk.builtin.oct = function(a) {
        self.Sk.builtin.pyCheckArgsLen("oct", arguments.length, 1, 1)
        if (!self.Sk.misceval.isIndex(a))
          throw new self.Sk.builtin.TypeError(
            "oct() argument can't be converted to hex",
          )
        return self.Sk.__future__.octal_number_literal
          ? self.Sk.builtin.int2str_(a, 8, "0o")
          : self.Sk.builtin.int2str_(a, 8, "0")
      }
      self.Sk.builtin.bin = function(a) {
        self.Sk.builtin.pyCheckArgsLen("bin", arguments.length, 1, 1)
        if (!self.Sk.misceval.isIndex(a))
          throw new self.Sk.builtin.TypeError(
            "'" +
              self.Sk.abstr.typeName(a) +
              "' object can't be interpreted as an index",
          )
        return self.Sk.builtin.int2str_(a, 2, "0b")
      }
      self.Sk.builtin.dir = function(a) {
        var b, c
        self.Sk.builtin.pyCheckArgsLen("dir", arguments.length, 1, 1)
        var d = function(a) {
          var b = null
          if (
            -1 !==
            "__bases__ __mro__ __class__ __name__ GenericGetAttr GenericSetAttr GenericPythonGetAttr GenericPythonSetAttr pythonFunctions HashNotImplemented constructor __dict__"
              .split(" ")
              .indexOf(a)
          )
            return null
          ;-1 !== a.indexOf("$")
            ? (b = self.Sk.builtin.dir.slotNameToRichName(a))
            : "_" !== a.charAt(a.length - 1)
            ? (b = a)
            : "_" === a.charAt(0) && (b = a)
          return b
        }
        var e = []
        var f = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$dir)
        if (null != f) {
          var g = self.Sk.misceval.callsimArray(f, [a])
          if (!self.Sk.builtin.checkSequence(g))
            throw new self.Sk.builtin.TypeError("__dir__ must return sequence.")
          g = self.Sk.ffi.remapToJs(g)
          for (b = 0; b < g.length; ++b) e.push(new self.Sk.builtin.str(g[b]))
        } else {
          for (b in a.constructor.prototype)
            (c = d(b)) && e.push(new self.Sk.builtin.str(c))
          if (a.$d)
            if (a.$d.tp$iter)
              for (
                f = a.$d.tp$iter(), b = f.tp$iternext();
                void 0 !== b;
                b = f.tp$iternext()
              )
                (c = new self.Sk.builtin.str(b)),
                  (c = d(c.v)) && e.push(new self.Sk.builtin.str(c))
            else for (c in a.$d) e.push(new self.Sk.builtin.str(c))
          var h = a.tp$mro
          !h && a.ob$type && (h = a.ob$type.tp$mro)
          if (h)
            for (b = 0; b < h.v.length; ++b)
              for (g in ((f = h.v[b]), f))
                f.hasOwnProperty(g) &&
                  (c = d(g)) &&
                  e.push(new self.Sk.builtin.str(c))
        }
        e.sort(function(a, b) {
          return (a.v > b.v) - (a.v < b.v)
        })
        return new self.Sk.builtin.list(
          e.filter(function(a, b, c) {
            return a !== c[b + 1]
          }),
        )
      }
      self.Sk.builtin.dir.slotNameToRichName = function(a) {}
      self.Sk.builtin.repr = function(a) {
        self.Sk.builtin.pyCheckArgsLen("repr", arguments.length, 1, 1)
        return self.Sk.misceval.objectRepr(a)
      }
      self.Sk.builtin.open = function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("open", arguments.length, 1, 3)
        void 0 === b && (b = new self.Sk.builtin.str("r"))
        if (/\+/.test(b.v)) throw "todo; haven't implemented read/write mode"
        if (
          ("w" === b.v || "wb" === b.v || "a" === b.v || "ab" === b.v) &&
          !self.Sk.nonreadopen
        )
          throw "todo; haven't implemented non-read opens"
        return new self.Sk.builtin.file(a, b, c)
      }
      self.Sk.builtin.isinstance = function(a, b) {
        var c
        self.Sk.builtin.pyCheckArgsLen("isinstance", arguments.length, 2, 2)
        if (!(self.Sk.builtin.checkClass(b) || b instanceof self.Sk.builtin.tuple))
          throw new self.Sk.builtin.TypeError(
            "isinstance() arg 2 must be a class, type, or tuple of classes and types",
          )
        if (b === self.Sk.builtin.none.prototype.ob$type)
          return a instanceof self.Sk.builtin.none
            ? self.Sk.builtin.bool.true$
            : self.Sk.builtin.bool.false$
        if (a.ob$type === b) return self.Sk.builtin.bool.true$
        if (b instanceof self.Sk.builtin.tuple) {
          for (c = 0; c < b.v.length; ++c)
            if (self.Sk.misceval.isTrue(self.Sk.builtin.isinstance(a, b.v[c])))
              return self.Sk.builtin.bool.true$
          return self.Sk.builtin.bool.false$
        }
        if (a instanceof b) return self.Sk.builtin.bool.true$
        var d = function(a, b) {
          if (a === b) return self.Sk.builtin.bool.true$
          if (void 0 === a.$d) return self.Sk.builtin.bool.false$
          var c = a.$d.mp$subscript(self.Sk.builtin.type.basesStr_)
          for (a = 0; a < c.v.length; ++a)
            if (self.Sk.misceval.isTrue(d(c.v[a], b))) return self.Sk.builtin.bool.true$
          return self.Sk.builtin.bool.false$
        }
        return d(a.ob$type, b)
      }
      self.Sk.builtin.hash = function(a) {
        self.Sk.builtin.pyCheckArgsLen("hash", arguments.length, 1, 1)
        if (a instanceof Object) {
          if (self.Sk.builtin.checkNone(a.tp$hash))
            throw new self.Sk.builtin.TypeError(
              new self.Sk.builtin.str(
                "unhashable type: '" + self.Sk.abstr.typeName(a) + "'",
              ),
            )
          if (void 0 !== a.tp$hash) {
            if (a.$savedHash_) return a.$savedHash_
            a.$savedHash_ = a.tp$hash()
            return a.$savedHash_
          }
          void 0 === a.__hash &&
            ((self.Sk.builtin.hashCount += 1), (a.__hash = self.Sk.builtin.hashCount))
          return new self.Sk.builtin.int_(a.__hash)
        }
        if ("number" === typeof a || null === a || !0 === a || !1 === a)
          throw new self.Sk.builtin.TypeError("unsupported Javascript type")
        return new self.Sk.builtin.str(typeof a + " " + String(a))
      }
      self.Sk.builtin.getattr = function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("getattr", arguments.length, 2, 3)
        if (!self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError("attribute name must be string")
        var d = b.$jsstr()
        var e = new self.Sk.builtin.str(self.Sk.fixReservedWords(d))
        e = a.tp$getattr(e)
        if (void 0 === e) {
          if (void 0 !== c) return c
          throw new self.Sk.builtin.AttributeError(
            "'" +
              self.Sk.abstr.typeName(a) +
              "' object has no attribute '" +
              d +
              "'",
          )
        }
        return e
      }
      self.Sk.builtin.setattr = function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("setattr", arguments.length, 3, 3)
        if (
          void 0 === a ||
          void 0 === a.$r ||
          "type" !== a.$r().v.slice(1, 5)
        ) {
          if (!self.Sk.builtin.checkString(b))
            throw new self.Sk.builtin.TypeError("attribute name must be string")
          var d = b.$jsstr()
          if (a.tp$setattr)
            a.tp$setattr(new self.Sk.builtin.str(self.Sk.fixReservedWords(d)), c)
          else
            throw new self.Sk.builtin.AttributeError("object has no attribute " + d)
          return self.Sk.builtin.none.none$
        }
        throw new self.Sk.builtin.TypeError(
          "can't set attributes of built-in/extension type '" + a.tp$name + "'",
        )
      }
      self.Sk.builtin.raw_input = function(a) {
        var b = a ? a : ""
        return self.Sk.misceval.chain(self.Sk.importModule("sys", !1, !0), function(a) {
          return self.Sk.inputfunTakesPrompt
            ? self.Sk.misceval.callsimOrSuspendArray(self.Sk.builtin.file.$readline, [
                a.$d.stdin,
                null,
                b,
              ])
            : self.Sk.misceval.chain(
                void 0,
                function() {
                  return self.Sk.misceval.callsimOrSuspendArray(a.$d.stdout.write, [
                    a.$d.stdout,
                    new self.Sk.builtin.str(b),
                  ])
                },
                function() {
                  return self.Sk.misceval.callsimOrSuspendArray(
                    a.$d.stdin.readline,
                    [a.$d.stdin],
                  )
                },
              )
        })
      }
      self.Sk.builtin.input = self.Sk.builtin.raw_input
      self.Sk.builtin.jseval = function(a) {
        a = self.Sk.global.eval(self.Sk.ffi.remapToJs(a))
        try {
          return self.Sk.ffi.remapToPy(a)
        } catch (b) {
          if (b.constructor === self.Sk.asserts.AssertionError)
            return self.Sk.builtin.none.none$
          throw b
        }
      }
      self.Sk.builtin.jsmillis = function() {
        return new Date().valueOf()
      }
      self.Sk.builtin.eval_ = function() {
        throw new self.Sk.builtin.NotImplementedError("eval is not yet implemented")
      }
      self.Sk.builtin.map = function(a, b) {
        var c = [],
          d,
          e
        self.Sk.builtin.pyCheckArgsLen("map", arguments.length, 2)
        if (2 < arguments.length) {
          var f = []
          var g = Array.prototype.slice.apply(arguments).slice(1)
          for (e = 0; e < g.length; e++) {
            if (!self.Sk.builtin.checkIterable(g[e])) {
              var h = parseInt(e, 10) + 2
              throw new self.Sk.builtin.TypeError(
                "argument " + h + " to map() must support iteration",
              )
            }
            g[e] = self.Sk.abstr.iter(g[e])
          }
          for (;;) {
            var k = []
            for (e = d = 0; e < g.length; e++)
              (h = g[e].tp$iternext()),
                void 0 === h ? (k.push(self.Sk.builtin.none.none$), d++) : k.push(h)
            if (d !== g.length) f.push(k)
            else break
          }
          b = new self.Sk.builtin.list(f)
        }
        if (!self.Sk.builtin.checkIterable(b))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(b) + "' object is not iterable",
          )
        return self.Sk.misceval.chain(
          self.Sk.misceval.iterFor(self.Sk.abstr.iter(b), function(b) {
            if (a === self.Sk.builtin.none.none$)
              b instanceof Array && (b = new self.Sk.builtin.tuple(b)), c.push(b)
            else
              return (
                b instanceof Array || (b = [b]),
                self.Sk.misceval.chain(
                  self.Sk.misceval.applyOrSuspend(a, void 0, void 0, void 0, b),
                  function(a) {
                    c.push(a)
                  },
                )
              )
          }),
          function() {
            return new self.Sk.builtin.list(c)
          },
        )
      }
      self.Sk.builtin.reduce = function(a, b, c) {
        var d
        self.Sk.builtin.pyCheckArgsLen("reduce", arguments.length, 2, 3)
        if (!self.Sk.builtin.checkIterable(b))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(b) + "' object is not iterable",
          )
        var e = self.Sk.abstr.iter(b)
        if (void 0 === c && ((c = e.tp$iternext()), void 0 === c))
          throw new self.Sk.builtin.TypeError(
            "reduce() of empty sequence with no initial value",
          )
        var f = c
        for (d = e.tp$iternext(); void 0 !== d; d = e.tp$iternext())
          f = self.Sk.misceval.callsimArray(a, [f, d])
        return f
      }
      self.Sk.builtin.filter = function(a, b) {
        var c
        self.Sk.builtin.pyCheckArgsLen("filter", arguments.length, 2, 2)
        if (!self.Sk.builtin.checkIterable(b))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(b) + "' object is not iterable",
          )
        var d = function() {
          return []
        }
        var e = function(a, b) {
          a.push(b)
          return a
        }
        var f = function(a) {
          return new self.Sk.builtin.list(a)
        }
        b.__class__ === self.Sk.builtin.str
          ? ((d = function() {
              return new self.Sk.builtin.str("")
            }),
            (e = function(a, b) {
              return a.sq$concat(b)
            }),
            (f = function(a) {
              return a
            }))
          : b.__class__ === self.Sk.builtin.tuple &&
            (f = function(a) {
              return new self.Sk.builtin.tuple(a)
            })
        var g = d()
        var h = self.Sk.abstr.iter(b)
        for (c = h.tp$iternext(); void 0 !== c; c = h.tp$iternext())
          (d =
            a === self.Sk.builtin.none.none$
              ? new self.Sk.builtin.bool(c)
              : self.Sk.misceval.callsimArray(a, [c])),
            self.Sk.misceval.isTrue(d) && (g = e(g, c))
        return f(g)
      }
      self.Sk.builtin.hasattr = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("hasattr", arguments.length, 2, 2)
        if (!self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError(
            "hasattr(): attribute name must be string",
          )
        if (a.tp$getattr)
          return a.tp$getattr(b)
            ? self.Sk.builtin.bool.true$
            : self.Sk.builtin.bool.false$
        throw new self.Sk.builtin.AttributeError("Object has no tp$getattr method")
      }
      self.Sk.builtin.pow = function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("pow", arguments.length, 2, 3)
        c instanceof self.Sk.builtin.none && (c = void 0)
        if (self.Sk.builtin.checkComplex(a)) return a.nb$power(b, c)
        var d = self.Sk.builtin.asnum$(a)
        var e = self.Sk.builtin.asnum$(b)
        var f = self.Sk.builtin.asnum$(c)
        if (!self.Sk.builtin.checkNumber(a) || !self.Sk.builtin.checkNumber(b)) {
          if (void 0 === c)
            throw new self.Sk.builtin.TypeError(
              "unsupported operand type(s) for pow(): '" +
                self.Sk.abstr.typeName(a) +
                "' and '" +
                self.Sk.abstr.typeName(b) +
                "'",
            )
          throw new self.Sk.builtin.TypeError(
            "unsupported operand type(s) for pow(): '" +
              self.Sk.abstr.typeName(a) +
              "', '" +
              self.Sk.abstr.typeName(b) +
              "', '" +
              self.Sk.abstr.typeName(c) +
              "'",
          )
        }
        if (0 > d && b instanceof self.Sk.builtin.float_)
          throw new self.Sk.builtin.ValueError(
            "negative number cannot be raised to a fractional power",
          )
        if (void 0 === c) {
          if (
            a instanceof self.Sk.builtin.float_ ||
            b instanceof self.Sk.builtin.float_ ||
            0 > e
          )
            return new self.Sk.builtin.float_(Math.pow(d, e))
          f = new self.Sk.builtin.int_(d)
          e = new self.Sk.builtin.int_(e)
          e = f.nb$power(e)
          return a instanceof self.Sk.builtin.lng || b instanceof self.Sk.builtin.lng
            ? new self.Sk.builtin.lng(e)
            : e
        }
        if (
          !self.Sk.builtin.checkInt(a) ||
          !self.Sk.builtin.checkInt(b) ||
          !self.Sk.builtin.checkInt(c)
        )
          throw new self.Sk.builtin.TypeError(
            "pow() 3rd argument not allowed unless all arguments are integers",
          )
        if (0 > e) {
          if (self.Sk.__future__.exceptions)
            throw new self.Sk.builtin.ValueError(
              "pow() 2nd argument cannot be negative when 3rd argument specified",
            )
          throw new self.Sk.builtin.TypeError(
            "pow() 2nd argument cannot be negative when 3rd argument specified",
          )
        }
        if (0 === f)
          throw new self.Sk.builtin.ValueError("pow() 3rd argument cannot be 0")
        return a instanceof self.Sk.builtin.lng ||
          b instanceof self.Sk.builtin.lng ||
          c instanceof self.Sk.builtin.lng ||
          Infinity === Math.pow(d, e)
          ? ((a = new self.Sk.builtin.lng(a)), a.nb$power(b, c))
          : new self.Sk.builtin.int_(Math.pow(d, e)).nb$remainder(c)
      }
      self.Sk.builtin.quit = function(a) {
        a = new self.Sk.builtin.str(a).v
        throw new self.Sk.builtin.SystemExit(a)
      }
      self.Sk.builtin.issubclass = function(a, b) {
        var c
        self.Sk.builtin.pyCheckArgsLen("issubclass", arguments.length, 2, 2)
        if (!self.Sk.builtin.checkClass(a))
          throw new self.Sk.builtin.TypeError("issubclass() arg 1 must be a class")
        if (!(self.Sk.builtin.checkClass(b) || b instanceof self.Sk.builtin.tuple))
          throw new self.Sk.builtin.TypeError(
            "issubclass() arg 2 must be a class or tuple of classes",
          )
        var d = function(a, b) {
          if (a === b) return !0
          if (void 0 !== a.$d && a.$d.mp$subscript)
            if (a.$d.sq$contains(self.Sk.builtin.type.basesStr_))
              var c = a.$d.mp$subscript(self.Sk.builtin.type.basesStr_)
            else return !1
          else return !1
          for (a = 0; a < c.v.length; ++a) if (d(c.v[a], b)) return !0
          return !1
        }
        if (self.Sk.builtin.checkClass(b)) return a === b ? !0 : d(a, b)
        if (b instanceof self.Sk.builtin.tuple) {
          for (c = 0; c < b.v.length; ++c)
            if (self.Sk.builtin.issubclass(a, b.v[c])) return !0
          return !1
        }
      }
      self.Sk.builtin.globals = function() {
        var a,
          b = new self.Sk.builtin.dict([])
        for (a in self.Sk.globals)
          b.mp$ass_subscript(new self.Sk.builtin.str(a), self.Sk.globals[a])
        return b
      }
      self.Sk.builtin.divmod = function(a, b) {
        return self.Sk.abstr.numberBinOp(a, b, "DivMod")
      }
      self.Sk.builtin.format = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("format", arguments.length, 1, 2)
        void 0 === b && (b = self.Sk.builtin.str.$emptystr)
        return self.Sk.abstr.objectFormat(a, b)
      }
      self.Sk.builtin.reversed = function(a) {
        self.Sk.builtin.pyCheckArgsLen("reversed", arguments.length, 1, 1)
        var b = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$reversed)
        if (null != b) return self.Sk.misceval.callsimArray(b, [a])
        if (!self.Sk.builtin.checkSequence(a))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not a sequence",
          )
        return new (function(a) {
          this.idx = a.sq$length() - 1
          this.myobj = a
          this.getitem = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$getitem)
          this.tp$iter = function() {
            return this
          }
          this.tp$iternext = function() {
            if (!(0 > this.idx)) {
              try {
                var a = self.Sk.misceval.callsimArray(this.getitem, [
                  this.myobj,
                  self.Sk.ffi.remapToPy(this.idx),
                ])
              } catch (e) {
                if (e instanceof self.Sk.builtin.IndexError) return
                throw e
              }
              this.idx--
              return a
            }
          }
        })(a)
      }
      self.Sk.builtin.id = function(a) {
        self.Sk.builtin.pyCheckArgsLen("id", arguments.length, 1, 1)
        void 0 === a.__id &&
          ((self.Sk.builtin.idCount += 1), (a.__id = self.Sk.builtin.idCount))
        return new self.Sk.builtin.int_(a.__id)
      }
      self.Sk.builtin.bytearray = function() {
        throw new self.Sk.builtin.NotImplementedError(
          "bytearray is not yet implemented",
        )
      }
      self.Sk.builtin.callable = function(a) {
        self.Sk.builtin.pyCheckArgsLen("callable", arguments.length, 1, 1)
        return self.Sk.builtin.checkCallable(a)
          ? self.Sk.builtin.bool.true$
          : self.Sk.builtin.bool.false$
      }
      self.Sk.builtin.delattr = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("delattr", arguments.length, 2, 2)
        if (void 0 !== a.$d[b.v])
          return self.Sk.misceval.tryCatch(
            function() {
              return self.Sk.builtin.setattr(a, b, void 0)
            },
            function(c) {
              self.Sk.misceval.tryCatch(
                function() {
                  return self.Sk.builtin.setattr(a.$d, b, void 0)
                },
                function(c) {
                  if (c instanceof self.Sk.builtin.AttributeError)
                    throw new self.Sk.builtin.AttributeError(
                      self.Sk.abstr.typeName(a) +
                        " instance has no attribute '" +
                        b.v +
                        "'",
                    )
                  throw c
                },
              )
            },
          )
        if ("type" !== a.$r().v.slice(1, 5)) {
          if (a.ob$type === self.Sk.builtin.type && void 0 !== a[b.v])
            return (a[b.v] = void 0), self.Sk.builtin.none.none$
          throw new self.Sk.builtin.AttributeError(
            self.Sk.abstr.typeName(a) + " instance has no attribute '" + b.v + "'",
          )
        }
        throw new self.Sk.builtin.TypeError(
          "can't set attributes of built-in/extension type '" + a.tp$name + "'",
        )
      }
      self.Sk.builtin.execfile = function() {
        throw new self.Sk.builtin.NotImplementedError(
          "execfile is not yet implemented",
        )
      }
      self.Sk.builtin.frozenset = function() {
        throw new self.Sk.builtin.NotImplementedError(
          "frozenset is not yet implemented",
        )
      }
      self.Sk.builtin.help = function() {
        throw new self.Sk.builtin.NotImplementedError("help is not yet implemented")
      }
      self.Sk.builtin.iter = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("iter", arguments.length, 1, 2)
        if (1 === arguments.length) {
          if (self.Sk.builtin.checkIterable(a)) return new self.Sk.builtin.iterator(a)
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not iterable",
          )
        }
        if (self.Sk.builtin.checkCallable(a)) return new self.Sk.builtin.iterator(a, b)
        throw new TypeError("iter(v, w): v must be callable")
      }
      self.Sk.builtin.locals = function() {
        throw new self.Sk.builtin.NotImplementedError(
          "locals is not yet implemented",
        )
      }
      self.Sk.builtin.memoryview = function() {
        throw new self.Sk.builtin.NotImplementedError(
          "memoryview is not yet implemented",
        )
      }
      self.Sk.builtin.next_ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("next", arguments.length, 1, 2)
        if (!a.tp$iternext)
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not an iterator",
          )
        var c = a.tp$iternext()
        if (void 0 === c) {
          if (b) return b
          throw new self.Sk.builtin.StopIteration()
        }
        return c
      }
      self.Sk.builtin.reload = function() {
        throw new self.Sk.builtin.NotImplementedError(
          "reload is not yet implemented",
        )
      }
      self.Sk.builtin.vars = function() {
        throw new self.Sk.builtin.NotImplementedError("vars is not yet implemented")
      }
      self.Sk.builtin.xrange = self.Sk.builtin.range
      self.Sk.builtin.apply_ = function() {
        throw new self.Sk.builtin.NotImplementedError("apply is not yet implemented")
      }
      self.Sk.builtin.buffer = function() {
        throw new self.Sk.builtin.NotImplementedError(
          "buffer is not yet implemented",
        )
      }
      self.Sk.builtin.coerce = function() {
        throw new self.Sk.builtin.NotImplementedError(
          "coerce is not yet implemented",
        )
      }
      self.Sk.builtin.intern = function() {
        throw new self.Sk.builtin.NotImplementedError(
          "intern is not yet implemented",
        )
      }
    },
    function(m, p) {
      String.fromCodePoint ||
        (function() {
          var a = (function() {
              try {
                var a = {},
                  b = Object.defineProperty
                var c = b(a, "foo", a) && b
              } catch (h) {}
              return c
            })(),
            b = String.fromCharCode,
            c = Math.floor,
            d = function(a) {
              var d = [],
                e = -1,
                h = arguments.length
              if (!h) return ""
              for (var k = ""; ++e < h; ) {
                var l = Number(arguments[e])
                if (!isFinite(l) || 0 > l || 1114111 < l || c(l) != l)
                  throw RangeError("Invalid code point: " + l)
                if (65535 >= l) d.push(l)
                else {
                  l -= 65536
                  var r = (l >> 10) + 55296
                  l = (l % 1024) + 56320
                  d.push(r, l)
                }
                if (e + 1 == h || 16384 < d.length)
                  (k += b.apply(null, d)), (d.length = 0)
              }
              return k
            }
          a
            ? a(String, "fromCodePoint", {
                value: d,
                configurable: !0,
                writable: !0,
              })
            : (String.fromCodePoint = d)
        })()
    },
    function(m, p) {
      self.Sk.builtin.BaseException = function(a) {
        if (!(this instanceof self.Sk.builtin.BaseException)) {
          var b = Object.create(self.Sk.builtin.BaseException.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        a = Array.prototype.slice.call(arguments)
        for (b = 0; b < a.length; ++b)
          "string" === typeof a[b] && (a[b] = new self.Sk.builtin.str(a[b]))
        this.args = new self.Sk.builtin.tuple(a)
        this.traceback = []
        3 <= this.args.sq$length() &&
          this.traceback.push({
            lineno: this.args.v[2],
            filename: this.args.v[1].v || "<unknown>",
          })
      }
      self.Sk.abstr.setUpInheritance(
        "BaseException",
        self.Sk.builtin.BaseException,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.BaseException.prototype.tp$str = function() {
        var a
        var b = "" + this.tp$name
        this.args &&
          (b += ": " + (0 < this.args.v.length ? this.args.v[0].v : ""))
        b =
          0 !== this.traceback.length
            ? b + (" on line " + this.traceback[0].lineno)
            : b + " at <unknown>"
        if (4 < this.args.v.length) {
          b += "\n" + this.args.v[4].v + "\n"
          for (a = 0; a < this.args.v[3]; ++a) b += " "
          b += "^\n"
        }
        return new self.Sk.builtin.str(b)
      }
      self.Sk.builtin.BaseException.prototype.toString = function() {
        return this.tp$str().v
      }
      self.Sk.builtin.BaseException.prototype.args = {
        tp$descr_get: function(a, b) {
          return a.args
        },
      }
      self.Sk.exportSymbol("Sk.builtin.BaseException", self.Sk.builtin.BaseException)
      self.Sk.builtin.Exception = function(a) {
        if (!(this instanceof self.Sk.builtin.Exception)) {
          var b = Object.create(self.Sk.builtin.Exception.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.BaseException.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "Exception",
        self.Sk.builtin.Exception,
        self.Sk.builtin.BaseException,
      )
      self.Sk.exportSymbol("Sk.builtin.Exception", self.Sk.builtin.Exception)
      self.Sk.builtin.StandardError = function(a) {
        if (!(this instanceof self.Sk.builtin.StandardError)) {
          var b = Object.create(self.Sk.builtin.StandardError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.Exception.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "StandardError",
        self.Sk.builtin.StandardError,
        self.Sk.builtin.Exception,
      )
      self.Sk.exportSymbol("Sk.builtin.StandardError", self.Sk.builtin.StandardError)
      self.Sk.builtin.AssertionError = function(a) {
        if (!(this instanceof self.Sk.builtin.AssertionError)) {
          var b = Object.create(self.Sk.builtin.AssertionError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "AssertionError",
        self.Sk.builtin.AssertionError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.AssertionError", self.Sk.builtin.AssertionError)
      self.Sk.builtin.AttributeError = function(a) {
        if (!(this instanceof self.Sk.builtin.AttributeError)) {
          var b = Object.create(self.Sk.builtin.AttributeError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "AttributeError",
        self.Sk.builtin.AttributeError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.ImportError = function(a) {
        if (!(this instanceof self.Sk.builtin.ImportError)) {
          var b = Object.create(self.Sk.builtin.ImportError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "ImportError",
        self.Sk.builtin.ImportError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.IndentationError = function(a) {
        if (!(this instanceof self.Sk.builtin.IndentationError)) {
          var b = Object.create(self.Sk.builtin.IndentationError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "IndentationError",
        self.Sk.builtin.IndentationError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.IndexError = function(a) {
        if (!(this instanceof self.Sk.builtin.IndexError)) {
          var b = Object.create(self.Sk.builtin.IndexError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "IndexError",
        self.Sk.builtin.IndexError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.KeyError = function(a) {
        if (!(this instanceof self.Sk.builtin.KeyError)) {
          var b = Object.create(self.Sk.builtin.KeyError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "KeyError",
        self.Sk.builtin.KeyError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.NameError = function(a) {
        if (!(this instanceof self.Sk.builtin.NameError)) {
          var b = Object.create(self.Sk.builtin.NameError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "NameError",
        self.Sk.builtin.NameError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.UnboundLocalError = function(a) {
        if (!(this instanceof self.Sk.builtin.UnboundLocalError)) {
          var b = Object.create(self.Sk.builtin.UnboundLocalError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "UnboundLocalError",
        self.Sk.builtin.UnboundLocalError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.OverflowError = function(a) {
        if (!(this instanceof self.Sk.builtin.OverflowError)) {
          var b = Object.create(self.Sk.builtin.OverflowError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "OverflowError",
        self.Sk.builtin.OverflowError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.SyntaxError = function(a) {
        if (!(this instanceof self.Sk.builtin.SyntaxError)) {
          var b = Object.create(self.Sk.builtin.SyntaxError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "SyntaxError",
        self.Sk.builtin.SyntaxError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.RuntimeError = function(a) {
        if (!(this instanceof self.Sk.builtin.RuntimeError)) {
          var b = Object.create(self.Sk.builtin.RuntimeError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "RuntimeError",
        self.Sk.builtin.RuntimeError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.RuntimeError", self.Sk.builtin.RuntimeError)
      self.Sk.builtin.SuspensionError = function(a) {
        if (!(this instanceof self.Sk.builtin.SuspensionError)) {
          var b = Object.create(self.Sk.builtin.SuspensionError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "SuspensionError",
        self.Sk.builtin.SuspensionError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.SuspensionError", self.Sk.builtin.SuspensionError)
      self.Sk.builtin.SystemExit = function(a) {
        if (!(this instanceof self.Sk.builtin.SystemExit)) {
          var b = Object.create(self.Sk.builtin.SystemExit.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.BaseException.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "SystemExit",
        self.Sk.builtin.SystemExit,
        self.Sk.builtin.BaseException,
      )
      self.Sk.exportSymbol("Sk.builtin.SystemExit", self.Sk.builtin.SystemExit)
      self.Sk.builtin.TypeError = function(a) {
        if (!(this instanceof self.Sk.builtin.TypeError)) {
          var b = Object.create(self.Sk.builtin.TypeError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "TypeError",
        self.Sk.builtin.TypeError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.TypeError", self.Sk.builtin.TypeError)
      self.Sk.builtin.ValueError = function(a) {
        if (!(this instanceof self.Sk.builtin.ValueError)) {
          var b = Object.create(self.Sk.builtin.ValueError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "ValueError",
        self.Sk.builtin.ValueError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.ValueError", self.Sk.builtin.ValueError)
      self.Sk.builtin.ZeroDivisionError = function(a) {
        if (!(this instanceof self.Sk.builtin.ZeroDivisionError)) {
          var b = Object.create(self.Sk.builtin.ZeroDivisionError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "ZeroDivisionError",
        self.Sk.builtin.ZeroDivisionError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.builtin.TimeLimitError = function(a) {
        if (!(this instanceof self.Sk.builtin.TimeLimitError)) {
          var b = Object.create(self.Sk.builtin.TimeLimitError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "TimeLimitError",
        self.Sk.builtin.TimeLimitError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.TimeLimitError", self.Sk.builtin.TimeLimitError)
      self.Sk.builtin.IOError = function(a) {
        if (!(this instanceof self.Sk.builtin.IOError)) {
          var b = Object.create(self.Sk.builtin.IOError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "IOError",
        self.Sk.builtin.IOError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.IOError", self.Sk.builtin.IOError)
      self.Sk.builtin.NotImplementedError = function(a) {
        if (!(this instanceof self.Sk.builtin.NotImplementedError)) {
          var b = Object.create(self.Sk.builtin.NotImplementedError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "NotImplementedError",
        self.Sk.builtin.NotImplementedError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol(
        "Sk.builtin.NotImplementedError",
        self.Sk.builtin.NotImplementedError,
      )
      self.Sk.builtin.NegativePowerError = function(a) {
        if (!(this instanceof self.Sk.builtin.NegativePowerError)) {
          var b = Object.create(self.Sk.builtin.NegativePowerError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "NegativePowerError",
        self.Sk.builtin.NegativePowerError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol(
        "Sk.builtin.NegativePowerError",
        self.Sk.builtin.NegativePowerError,
      )
      self.Sk.builtin.ExternalError = function(a, b) {
        if (!(this instanceof self.Sk.builtin.ExternalError)) {
          var c = Object.create(self.Sk.builtin.ExternalError.prototype)
          c.constructor.apply(c, arguments)
          return c
        }
        b = Array.prototype.slice.call(arguments)
        this.nativeError = b[0]
        b[0] instanceof self.Sk.builtin.str || (b[0] = "" + b[0])
        self.Sk.builtin.StandardError.apply(this, b)
      }
      self.Sk.abstr.setUpInheritance(
        "ExternalError",
        self.Sk.builtin.ExternalError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.ExternalError", self.Sk.builtin.ExternalError)
      self.Sk.builtin.OperationError = function(a) {
        if (!(this instanceof self.Sk.builtin.OperationError)) {
          var b = Object.create(self.Sk.builtin.OperationError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "OperationError",
        self.Sk.builtin.OperationError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.OperationError", self.Sk.builtin.OperationError)
      self.Sk.builtin.SystemError = function(a) {
        if (!(this instanceof self.Sk.builtin.SystemError)) {
          var b = Object.create(self.Sk.builtin.SystemError.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.StandardError.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "SystemError",
        self.Sk.builtin.SystemError,
        self.Sk.builtin.StandardError,
      )
      self.Sk.exportSymbol("Sk.builtin.SystemError", self.Sk.builtin.SystemError)
      self.Sk.builtin.StopIteration = function(a) {
        if (!(this instanceof self.Sk.builtin.StopIteration)) {
          var b = Object.create(self.Sk.builtin.StopIteration.prototype)
          b.constructor.apply(b, arguments)
          return b
        }
        self.Sk.builtin.Exception.apply(this, arguments)
      }
      self.Sk.abstr.setUpInheritance(
        "StopIteration",
        self.Sk.builtin.StopIteration,
        self.Sk.builtin.Exception,
      )
      self.Sk.exportSymbol("Sk.builtin.StopIteration", self.Sk.builtin.StopIteration)
      self.Sk.builtin.getExcInfo = function(a) {
        return new self.Sk.builtin.tuple([
          a.ob$type || self.Sk.builtin.none.none$,
          a,
          self.Sk.builtin.none.none$,
        ])
      }
    },
    function(m, p) {
      self.Sk.builtin.method = function(a, b, c, d) {
        if (!(this instanceof self.Sk.builtin.method)) {
          self.Sk.builtin.pyCheckArgsLen("method", arguments.length, 3, 3)
          if (!self.Sk.builtin.checkCallable(a))
            throw new self.Sk.builtin.TypeError("First argument must be callable")
          if (void 0 === b.ob$type)
            throw new self.Sk.builtin.TypeError(
              "Second argument must be object of known type",
            )
          return new self.Sk.builtin.method(a, b, c)
        }
        this.tp$name = a.tp$name
        this.im_func = a
        this.im_self = b || self.Sk.builtin.none.none$
        this.im_class = c || self.Sk.builtin.none.none$
        this.im_builtin = d
        this.$d = { im_func: a, im_self: b, im_class: c }
      }
      self.Sk.exportSymbol("Sk.builtin.method", self.Sk.builtin.method)
      self.Sk.abstr.setUpInheritance(
        "instancemethod",
        self.Sk.builtin.method,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.method.prototype.tp$name = "method"
      self.Sk.builtin.method.prototype.ob$eq = function(a) {
        if (
          (this.im_self == self.Sk.builtin.none.none$ &&
            a.im_self != self.Sk.builtin.none.none$) ||
          (a.im_self == self.Sk.builtin.none.none$ &&
            this.im_self != self.Sk.builtin.none.none$)
        )
          return !1
        try {
          return (
            self.Sk.misceval.richCompareBool(this.im_self, a.im_self, "Eq", !1) &&
            this.im_func == a.im_func
          )
        } catch (b) {
          return !1
        }
      }
      self.Sk.builtin.method.prototype.ob$ne = function(a) {
        return !this.ob$eq(a)
      }
      self.Sk.builtin.method.prototype.tp$hash = function() {
        var a =
          this.im_self == self.Sk.builtin.none.none$
            ? 0
            : self.Sk.builtin.asnum$(self.Sk.builtin.hash(this.im_self))
        var b = self.Sk.builtin.asnum$(self.Sk.builtin.hash(this.im_func))
        return new self.Sk.builtin.int_(a + b)
      }
      self.Sk.builtin.method.prototype.tp$call = function(a, b) {
        this.im_self !== self.Sk.builtin.none.none$ && a.unshift(this.im_self)
        if (this.im_self === self.Sk.builtin.none.none$) {
          var c = function(a) {
            return (
              "unbound method " +
              this.tp$name +
              "() must be called with " +
              self.Sk.abstr.typeName(this.im_class) +
              " instance as first argument (got " +
              a +
              " instead)"
            )
          }.bind(this)
          if (0 < a.length) {
            if (
              this.im_class != self.Sk.builtin.none.none$ &&
              !self.Sk.builtin.issubclass(a[0].ob$type, this.im_class) &&
              !this.im_builtin
            )
              throw new self.Sk.builtin.TypeError(
                c(self.Sk.abstr.typeName(a[0].ob$type) + " instance"),
              )
          } else throw new self.Sk.builtin.TypeError(c("nothing"))
        }
        return this.im_func.tp$call(a, b)
      }
      self.Sk.builtin.method.prototype.tp$descr_get = function(a, b) {
        self.Sk.asserts.assert(void 0 !== a && void 0 !== b)
        return new self.Sk.builtin.method(this, a, b, this.im_builtin)
      }
      self.Sk.builtin.method.pythonFunctions = ["__get__"]
      self.Sk.builtin.method.prototype.__get__ = function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("__get__", arguments.length, 1, 2, !1, !0)
        if (b === self.Sk.builtin.none.none$ && c === self.Sk.builtin.none.none$)
          throw new self.Sk.builtin.TypeError("__get__(None, None) is invalid")
        return c && c !== self.Sk.builtin.none.none$
          ? self.Sk.builtin.issubclass(c, a.im_class)
            ? a.tp$descr_get(b, c)
            : a
          : a.tp$descr_get(b, self.Sk.builtin.none.none$)
      }
      self.Sk.builtin.method.prototype.$r = function() {
        if (this.im_builtin)
          return new self.Sk.builtin.str(
            "<built-in method " + this.tp$name + " of type object>",
          )
        if (this.im_self === self.Sk.builtin.none.none$)
          return new self.Sk.builtin.str(
            "<unbound method " +
              self.Sk.abstr.typeName(this.im_class) +
              "." +
              this.tp$name +
              ">",
          )
        var a =
          this.im_class !== self.Sk.builtin.none.none$
            ? self.Sk.abstr.typeName(this.im_class)
            : "?"
        return new self.Sk.builtin.str(
          "<bound method " +
            a +
            "." +
            this.tp$name +
            " of " +
            self.Sk.ffi.remapToJs(self.Sk.misceval.objectRepr(this.im_self)) +
            ">",
        )
      }
    },
    function(m, p) {
      self.Sk.misceval = {}
      self.Sk.misceval.Suspension = function(a, b, c) {
        this.$isSuspension = !0
        void 0 !== a &&
          void 0 !== b &&
          (this.resume = function() {
            return a(b.resume())
          })
        this.child = b
        this.optional = void 0 !== b && b.optional
        this.data = void 0 === c && void 0 !== b ? b.data : c
      }
      self.Sk.exportSymbol("Sk.misceval.Suspension", self.Sk.misceval.Suspension)
      self.Sk.misceval.retryOptionalSuspensionOrThrow = function(a, b) {
        for (; a instanceof self.Sk.misceval.Suspension; ) {
          if (!a.optional)
            throw new self.Sk.builtin.SuspensionError(
              b || "Cannot call a function that blocks or suspends here",
            )
          a = a.resume()
        }
        return a
      }
      self.Sk.exportSymbol(
        "Sk.misceval.retryOptionalSuspensionOrThrow",
        self.Sk.misceval.retryOptionalSuspensionOrThrow,
      )
      self.Sk.misceval.isIndex = function(a) {
        return self.Sk.builtin.checkInt(a) ||
          self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$index)
          ? !0
          : !1
      }
      self.Sk.exportSymbol("Sk.misceval.isIndex", self.Sk.misceval.isIndex)
      self.Sk.misceval.asIndex = function(a) {
        var b
        if (self.Sk.misceval.isIndex(a) && null !== a) {
          if (!0 === a) return 1
          if (!1 === a) return 0
          if ("number" === typeof a) return a
          if (a.constructor === self.Sk.builtin.int_) return a.v
          if (a.constructor === self.Sk.builtin.lng) return a.tp$index()
          if (a.constructor === self.Sk.builtin.bool) return self.Sk.builtin.asnum$(a)
          if ((b = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$index))) {
            a = self.Sk.misceval.callsimArray(b, [a])
            if (!self.Sk.builtin.checkInt(a))
              throw new self.Sk.builtin.TypeError(
                "__index__ returned non-(int,long) (type " +
                  self.Sk.abstr.typeName(a) +
                  ")",
              )
            return self.Sk.builtin.asnum$(a)
          }
          self.Sk.asserts.fail("todo asIndex;")
        }
      }
      self.Sk.misceval.applySlice = function(a, b, c, d) {
        return a.sq$slice && self.Sk.misceval.isIndex(b) && self.Sk.misceval.isIndex(c)
          ? ((b = self.Sk.misceval.asIndex(b)),
            void 0 === b && (b = 0),
            (c = self.Sk.misceval.asIndex(c)),
            void 0 === c && (c = 1e100),
            self.Sk.abstr.sequenceGetSlice(a, b, c))
          : self.Sk.abstr.objectGetItem(a, new self.Sk.builtin.slice(b, c, null), d)
      }
      self.Sk.exportSymbol("Sk.misceval.applySlice", self.Sk.misceval.applySlice)
      self.Sk.misceval.assignSlice = function(a, b, c, d, e) {
        if (a.sq$ass_slice && self.Sk.misceval.isIndex(b) && self.Sk.misceval.isIndex(c))
          (e = self.Sk.misceval.asIndex(b) || 0),
            (c = self.Sk.misceval.asIndex(c) || 1e100),
            null === d
              ? self.Sk.abstr.sequenceDelSlice(a, e, c)
              : self.Sk.abstr.sequenceSetSlice(a, e, c, d)
        else
          return (
            (c = new self.Sk.builtin.slice(b, c)),
            null === d
              ? self.Sk.abstr.objectDelItem(a, c)
              : self.Sk.abstr.objectSetItem(a, c, d, e)
          )
      }
      self.Sk.exportSymbol("Sk.misceval.assignSlice", self.Sk.misceval.assignSlice)
      self.Sk.misceval.arrayFromArguments = function(a) {
        var b
        if (1 != a.length) return a
        var c = a[0]
        c instanceof self.Sk.builtin.set
          ? (c = c.tp$iter().$obj)
          : c instanceof self.Sk.builtin.dict &&
            (c = self.Sk.builtin.dict.prototype.keys.func_code(c))
        if (c instanceof self.Sk.builtin.list || c instanceof self.Sk.builtin.tuple)
          return c.v
        if (self.Sk.builtin.checkIterable(c)) {
          a = []
          c = self.Sk.abstr.iter(c)
          for (b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext()) a.push(b)
          return a
        }
        throw new self.Sk.builtin.TypeError(
          "'" + self.Sk.abstr.typeName(c) + "' object is not iterable",
        )
      }
      self.Sk.exportSymbol(
        "Sk.misceval.arrayFromArguments",
        self.Sk.misceval.arrayFromArguments,
      )
      self.Sk.misceval.swappedOp_ = {
        Eq: "Eq",
        NotEq: "NotEq",
        Lt: "GtE",
        LtE: "Gt",
        Gt: "LtE",
        GtE: "Lt",
        Is: "IsNot",
        IsNot: "Is",
        In_: "NotIn",
        NotIn: "In_",
      }
      self.Sk.misceval.opSymbols = {
        Eq: "==",
        NotEq: "!=",
        Lt: "<",
        LtE: "<=",
        Gt: ">",
        GtE: ">=",
        Is: "is",
        IsNot: "is not",
        In_: "in",
        NotIn: "not in",
      }
      self.Sk.misceval.richCompareBool = function(a, b, c, d) {
        var e
        self.Sk.asserts.assert(
          null !== a && void 0 !== a,
          "passed null or undefined parameter to self.Sk.misceval.richCompareBool",
        )
        self.Sk.asserts.assert(
          null !== b && void 0 !== b,
          "passed null or undefined parameter to self.Sk.misceval.richCompareBool",
        )
        var f = new self.Sk.builtin.type(a)
        var g = new self.Sk.builtin.type(b)
        if (
          !self.Sk.__future__.python3 &&
          f !== g &&
          ("GtE" === c || "Gt" === c || "LtE" === c || "Lt" === c)
        ) {
          var h = [
            self.Sk.builtin.float_.prototype.ob$type,
            self.Sk.builtin.int_.prototype.ob$type,
            self.Sk.builtin.lng.prototype.ob$type,
            self.Sk.builtin.bool.prototype.ob$type,
          ]
          var k = [
            self.Sk.builtin.dict.prototype.ob$type,
            self.Sk.builtin.enumerate.prototype.ob$type,
            self.Sk.builtin.filter_.prototype.ob$type,
            self.Sk.builtin.list.prototype.ob$type,
            self.Sk.builtin.map_.prototype.ob$type,
            self.Sk.builtin.str.prototype.ob$type,
            self.Sk.builtin.tuple.prototype.ob$type,
            self.Sk.builtin.zip_.prototype.ob$type,
          ]
          var l = h.indexOf(f)
          var r = k.indexOf(f)
          h = h.indexOf(g)
          k = k.indexOf(g)
          if (f === self.Sk.builtin.none.prototype.ob$type)
            switch (c) {
              case "Lt":
                return !0
              case "LtE":
                return !0
              case "Gt":
                return !1
              case "GtE":
                return !1
            }
          if (g === self.Sk.builtin.none.prototype.ob$type)
            switch (c) {
              case "Lt":
                return !1
              case "LtE":
                return !1
              case "Gt":
                return !0
              case "GtE":
                return !0
            }
          if (-1 !== l && -1 !== k)
            switch (c) {
              case "Lt":
                return !0
              case "LtE":
                return !0
              case "Gt":
                return !1
              case "GtE":
                return !1
            }
          if (-1 !== r && -1 !== h)
            switch (c) {
              case "Lt":
                return !1
              case "LtE":
                return !1
              case "Gt":
                return !0
              case "GtE":
                return !0
            }
          if (-1 !== r && -1 !== k)
            switch (c) {
              case "Lt":
                return r < k
              case "LtE":
                return r <= k
              case "Gt":
                return r > k
              case "GtE":
                return r >= k
            }
        }
        if ("Is" === c)
          return a instanceof self.Sk.builtin.int_ && b instanceof self.Sk.builtin.int_
            ? 0 === a.numberCompare(b)
            : a instanceof self.Sk.builtin.float_ && b instanceof self.Sk.builtin.float_
            ? 0 === a.numberCompare(b)
            : a instanceof self.Sk.builtin.lng && b instanceof self.Sk.builtin.lng
            ? 0 === a.longCompare(b)
            : a === b
        if ("IsNot" === c)
          return a instanceof self.Sk.builtin.int_ && b instanceof self.Sk.builtin.int_
            ? 0 !== a.numberCompare(b)
            : a instanceof self.Sk.builtin.float_ && b instanceof self.Sk.builtin.float_
            ? 0 !== a.numberCompare(b)
            : a instanceof self.Sk.builtin.lng && b instanceof self.Sk.builtin.lng
            ? 0 !== a.longCompare(b)
            : a !== b
        if ("In" === c)
          return self.Sk.misceval.chain(
            self.Sk.abstr.sequenceContains(b, a, d),
            self.Sk.misceval.isTrue,
          )
        if ("NotIn" === c)
          return self.Sk.misceval.chain(self.Sk.abstr.sequenceContains(b, a, d), function(
            a,
          ) {
            return !self.Sk.misceval.isTrue(a)
          })
        l = {
          Eq: "ob$eq",
          NotEq: "ob$ne",
          Gt: "ob$gt",
          GtE: "ob$ge",
          Lt: "ob$lt",
          LtE: "ob$le",
        }
        r = l[c]
        if (
          (d = a.constructor.prototype.hasOwnProperty(r)) &&
          (e = a[r](b)) !== self.Sk.builtin.NotImplemented.NotImplemented$
        )
          return self.Sk.misceval.isTrue(e)
        l = l[self.Sk.misceval.swappedOp_[c]]
        if (
          (r = b.constructor.prototype.hasOwnProperty(l)) &&
          (e = b[l](a)) !== self.Sk.builtin.NotImplemented.NotImplemented$
        )
          return self.Sk.misceval.isTrue(e)
        if (
          (a.tp$richcompare &&
            void 0 !== (e = a.tp$richcompare(b, c)) &&
            e != self.Sk.builtin.NotImplemented.NotImplemented$) ||
          (b.tp$richcompare &&
            void 0 !== (e = b.tp$richcompare(a, self.Sk.misceval.swappedOp_[c])) &&
            e != self.Sk.builtin.NotImplemented.NotImplemented$)
        )
          return self.Sk.misceval.isTrue(e)
        if (
          ((l = self.Sk.abstr.lookupSpecial(a, self.Sk.misceval.op2method_[c])) &&
            !d &&
            ((e = self.Sk.misceval.callsimArray(l, [a, b])),
            e != self.Sk.builtin.NotImplemented.NotImplemented$)) ||
          ((d = self.Sk.abstr.lookupSpecial(
            b,
            self.Sk.misceval.op2method_[self.Sk.misceval.swappedOp_[c]],
          )) &&
            !r &&
            ((e = self.Sk.misceval.callsimArray(d, [b, a])),
            e != self.Sk.builtin.NotImplemented.NotImplemented$))
        )
          return self.Sk.misceval.isTrue(e)
        if (!self.Sk.__future__.python3) {
          if ((d = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$cmp)))
            try {
              e = self.Sk.misceval.callsimArray(d, [a, b])
              if (self.Sk.builtin.checkNumber(e)) {
                e = self.Sk.builtin.asnum$(e)
                if ("Eq" === c) return 0 === e
                if ("NotEq" === c) return 0 !== e
                if ("Lt" === c) return 0 > e
                if ("Gt" === c) return 0 < e
                if ("LtE" === c) return 0 >= e
                if ("GtE" === c) return 0 <= e
              }
              if (e !== self.Sk.builtin.NotImplemented.NotImplemented$)
                throw new self.Sk.builtin.TypeError(
                  "comparison did not return an int",
                )
            } catch (n) {
              throw new self.Sk.builtin.TypeError("comparison did not return an int")
            }
          if ((d = self.Sk.abstr.lookupSpecial(b, self.Sk.builtin.str.$cmp)))
            try {
              e = self.Sk.misceval.callsimArray(d, [b, a])
              if (self.Sk.builtin.checkNumber(e)) {
                e = self.Sk.builtin.asnum$(e)
                if ("Eq" === c) return 0 === e
                if ("NotEq" === c) return 0 !== e
                if ("Lt" === c) return 0 < e
                if ("Gt" === c) return 0 > e
                if ("LtE" === c) return 0 <= e
                if ("GtE" === c) return 0 >= e
              }
              if (e !== self.Sk.builtin.NotImplemented.NotImplemented$)
                throw new self.Sk.builtin.TypeError(
                  "comparison did not return an int",
                )
            } catch (n) {
              throw new self.Sk.builtin.TypeError("comparison did not return an int")
            }
        }
        if (
          (a instanceof self.Sk.builtin.none && b instanceof self.Sk.builtin.none) ||
          (a instanceof self.Sk.builtin.bool && b instanceof self.Sk.builtin.bool)
        ) {
          if ("Eq" === c) return a.v === b.v
          if ("NotEq" === c) return a.v !== b.v
          if ("Gt" === c) return a.v > b.v
          if ("GtE" === c) return a.v >= b.v
          if ("Lt" === c) return a.v < b.v
          if ("LtE" === c) return a.v <= b.v
        }
        if ("Eq" === c)
          return a instanceof self.Sk.builtin.str && b instanceof self.Sk.builtin.str
            ? a.v === b.v
            : a === b
        if ("NotEq" === c)
          return a instanceof self.Sk.builtin.str && b instanceof self.Sk.builtin.str
            ? a.v !== b.v
            : a !== b
        a = self.Sk.abstr.typeName(a)
        b = self.Sk.abstr.typeName(b)
        throw new self.Sk.builtin.TypeError(
          "'" +
            self.Sk.misceval.opSymbols[c] +
            "' not supported between instances of '" +
            a +
            "' and '" +
            b +
            "'",
        )
      }
      self.Sk.exportSymbol(
        "Sk.misceval.richCompareBool",
        self.Sk.misceval.richCompareBool,
      )
      self.Sk.misceval.objectRepr = function(a) {
        self.Sk.asserts.assert(void 0 !== a, "trying to repr undefined")
        return null === a || a instanceof self.Sk.builtin.none
          ? new self.Sk.builtin.str("None")
          : !0 === a
          ? new self.Sk.builtin.str("True")
          : !1 === a
          ? new self.Sk.builtin.str("False")
          : "number" === typeof a
          ? new self.Sk.builtin.str("" + a)
          : "string" === typeof a
          ? new self.Sk.builtin.str(a)
          : a.$r
          ? a.constructor === self.Sk.builtin.float_
            ? Infinity === a.v
              ? new self.Sk.builtin.str("inf")
              : -Infinity === a.v
              ? new self.Sk.builtin.str("-inf")
              : a.$r()
            : a.$r()
          : a.tp$name
          ? new self.Sk.builtin.str("<" + a.tp$name + " object>")
          : new self.Sk.builtin.str("<unknown>")
      }
      self.Sk.exportSymbol("Sk.misceval.objectRepr", self.Sk.misceval.objectRepr)
      self.Sk.misceval.opAllowsEquality = function(a) {
        switch (a) {
          case "LtE":
          case "Eq":
          case "GtE":
            return !0
        }
        return !1
      }
      self.Sk.exportSymbol(
        "Sk.misceval.opAllowsEquality",
        self.Sk.misceval.opAllowsEquality,
      )
      self.Sk.misceval.isTrue = function(a) {
        if (!0 === a) return !0
        if (
          !1 === a ||
          null === a ||
          a.constructor === self.Sk.builtin.none ||
          a.constructor === self.Sk.builtin.NotImplemented
        )
          return !1
        if (a.constructor === self.Sk.builtin.bool) return a.v
        if ("number" === typeof a) return 0 !== a
        if (a instanceof self.Sk.builtin.lng) return a.nb$nonzero()
        if (
          a.constructor === self.Sk.builtin.int_ ||
          a.constructor === self.Sk.builtin.float_
        )
          return 0 !== a.v
        if (self.Sk.__future__.python3) {
          if (a.__bool__) {
            a = self.Sk.misceval.callsimArray(a.__bool__, [a])
            if (!(a instanceof self.Sk.builtin.bool))
              throw new self.Sk.builtin.TypeError(
                "__bool__ should return bool, returned " + self.Sk.abstr.typeName(a),
              )
            return a.v
          }
        } else if (a.__nonzero__) {
          a = self.Sk.misceval.callsimArray(a.__nonzero__, [a])
          if (!self.Sk.builtin.checkInt(a))
            throw new self.Sk.builtin.TypeError("__nonzero__ should return an int")
          return 0 !== self.Sk.builtin.asnum$(a)
        }
        if (a.__len__) {
          a = self.Sk.misceval.callsimArray(a.__len__, [a])
          if (!self.Sk.builtin.checkInt(a))
            throw new self.Sk.builtin.TypeError("__len__ should return an int")
          return 0 !== self.Sk.builtin.asnum$(a)
        }
        return a.mp$length
          ? 0 !== self.Sk.builtin.asnum$(a.mp$length())
          : a.sq$length
          ? 0 !== self.Sk.builtin.asnum$(a.sq$length())
          : !0
      }
      self.Sk.exportSymbol("Sk.misceval.isTrue", self.Sk.misceval.isTrue)
      self.Sk.misceval.softspace_ = !1
      self.Sk.misceval.print_ = function(a) {
        self.Sk.misceval.softspace_ &&
          ("\n" !== a && self.Sk.output(" "), (self.Sk.misceval.softspace_ = !1))
        var b = new self.Sk.builtin.str(a)
        return self.Sk.misceval.chain(
          self.Sk.importModule("sys", !1, !0),
          function(a) {
            return self.Sk.misceval.apply(
              a.$d.stdout.write,
              void 0,
              void 0,
              void 0,
              [a.$d.stdout, b],
            )
          },
          function() {
            var a
            ;(a = 0 === b.v.length) ||
              ((a = b.v[b.v.length - 1]),
              (a = !("\n" === a || "\t" === a || "\r" === a)))
            if (a || " " === b.v[b.v.length - 1]) self.Sk.misceval.softspace_ = !0
          },
        )
      }
      self.Sk.exportSymbol("Sk.misceval.print_", self.Sk.misceval.print_)
      self.Sk.misceval.loadname = function(a, b) {
        b = b[a]
        if (void 0 !== b)
          return "function" === typeof b &&
            void 0 === b.$d &&
            void 0 === b.tp$name
            ? b()
            : b
        b = self.Sk.builtins[a]
        if (void 0 !== b) return b
        throw new self.Sk.builtin.NameError(
          "name '" + self.Sk.unfixReserved(a) + "' is not defined",
        )
      }
      self.Sk.exportSymbol("Sk.misceval.loadname", self.Sk.misceval.loadname)
      self.Sk.misceval.call = function(a, b, c, d, e) {
        e = Array.prototype.slice.call(arguments, 4)
        return self.Sk.misceval.apply(a, b, c, d, e)
      }
      self.Sk.exportSymbol("Sk.misceval.call", self.Sk.misceval.call)
      self.Sk.misceval.callAsync = function(a, b, c, d, e, f) {
        f = Array.prototype.slice.call(arguments, 5)
        return self.Sk.misceval.applyAsync(a, b, c, d, e, f)
      }
      self.Sk.exportSymbol("Sk.misceval.callAsync", self.Sk.misceval.callAsync)
      self.Sk.misceval.callOrSuspend = function(a, b, c, d, e) {
        e = Array.prototype.slice.call(arguments, 4)
        return self.Sk.misceval.applyOrSuspend(a, b, c, d, e)
      }
      self.Sk.exportSymbol("Sk.misceval.callOrSuspend", self.Sk.misceval.callOrSuspend)
      self.Sk.misceval.callsim = function(a, b) {
        b = Array.prototype.slice.call(arguments, 1)
        return self.Sk.misceval.apply(a, void 0, void 0, void 0, b)
      }
      self.Sk.exportSymbol("Sk.misceval.callsim", self.Sk.misceval.callsim)
      self.Sk.misceval.callsimArray = function(a, b) {
        return self.Sk.misceval.apply(a, void 0, void 0, void 0, b ? b : [])
      }
      self.Sk.exportSymbol("Sk.misceval.callsimArray", self.Sk.misceval.callsimArray)
      self.Sk.misceval.callsimAsync = function(a, b, c) {
        c = Array.prototype.slice.call(arguments, 2)
        return self.Sk.misceval.applyAsync(a, b, void 0, void 0, void 0, c)
      }
      self.Sk.exportSymbol("Sk.misceval.callsimAsync", self.Sk.misceval.callsimAsync)
      self.Sk.misceval.callsimOrSuspend = function(a, b) {
        b = Array.prototype.slice.call(arguments, 1)
        return self.Sk.misceval.applyOrSuspend(a, void 0, void 0, void 0, b)
      }
      self.Sk.exportSymbol(
        "Sk.misceval.callsimOrSuspend",
        self.Sk.misceval.callsimOrSuspend,
      )
      self.Sk.misceval.callsimOrSuspendArray = function(a, b) {
        return self.Sk.misceval.applyOrSuspend(a, void 0, void 0, void 0, b ? b : [])
      }
      self.Sk.exportSymbol(
        "Sk.misceval.callsimOrSuspendArray",
        self.Sk.misceval.callsimOrSuspendArray,
      )
      self.Sk.misceval.apply = function(a, b, c, d, e) {
        a = self.Sk.misceval.applyOrSuspend(a, b, c, d, e)
        return a instanceof self.Sk.misceval.Suspension
          ? self.Sk.misceval.retryOptionalSuspensionOrThrow(a)
          : a
      }
      self.Sk.exportSymbol("Sk.misceval.apply", self.Sk.misceval.apply)
      self.Sk.misceval.asyncToPromise = function(a, b) {
        return new Promise(function(c, d) {
          try {
            ;(function g(a) {
              try {
                for (
                  var f = function() {
                      try {
                        g(a.resume())
                      } catch (q) {
                        d(q)
                      }
                    },
                    k = function(b) {
                      try {
                        ;(a.data.result = b), f()
                      } catch (D) {
                        d(D)
                      }
                    },
                    l = function(b) {
                      try {
                        ;(a.data.error = b), f()
                      } catch (D) {
                        d(D)
                      }
                    };
                  a instanceof self.Sk.misceval.Suspension;

                ) {
                  var r = b && (b[a.data.type] || b["*"])
                  if (r) {
                    var n = r(a)
                    if (n) {
                      n.then(g, d)
                      return
                    }
                  }
                  if ("Sk.promise" == a.data.type) {
                    a.data.promise.then(k, l)
                    return
                  }
                  if ("Sk.yield" == a.data.type) {
                    self.Sk.global.setImmediate(f)
                    return
                  }
                  if ("Sk.delay" == a.data.type) {
                    self.Sk.global.setImmediate(f)
                    return
                  }
                  if (a.optional) a = a.resume()
                  else
                    throw new self.Sk.builtin.SuspensionError(
                      "Unhandled non-optional suspension of type '" +
                        a.data.type +
                        "'",
                    )
                }
                c(a)
              } catch (q) {
                d(q)
              }
            })(a())
          } catch (e) {
            d(e)
          }
        })
      }
      self.Sk.exportSymbol("Sk.misceval.asyncToPromise", self.Sk.misceval.asyncToPromise)
      self.Sk.misceval.applyAsync = function(a, b, c, d, e, f) {
        return self.Sk.misceval.asyncToPromise(function() {
          return self.Sk.misceval.applyOrSuspend(b, c, d, e, f)
        }, a)
      }
      self.Sk.exportSymbol("Sk.misceval.applyAsync", self.Sk.misceval.applyAsync)
      self.Sk.misceval.chain = function(a, b) {
        for (var c = 1, d = a, e, f; ; ) {
          if (c == arguments.length) return d
          if (d && d.$isSuspension) break
          d = arguments[c](d)
          c++
        }
        f = Array(arguments.length - c)
        for (e = 0; e < arguments.length - c; e++) f[e] = arguments[c + e]
        e = 0
        return (function k(a) {
          for (; e < f.length; ) {
            if (a instanceof self.Sk.misceval.Suspension)
              return new self.Sk.misceval.Suspension(k, a)
            a = f[e](a)
            e++
          }
          return a
        })(d)
      }
      self.Sk.exportSymbol("Sk.misceval.chain", self.Sk.misceval.chain)
      self.Sk.misceval.tryCatch = function(a, b) {
        try {
          var c = a()
        } catch (d) {
          return b(d)
        }
        return c instanceof self.Sk.misceval.Suspension
          ? ((a = new self.Sk.misceval.Suspension(void 0, c)),
            (a.resume = function() {
              return self.Sk.misceval.tryCatch(c.resume, b)
            }),
            a)
          : c
      }
      self.Sk.exportSymbol("Sk.misceval.tryCatch", self.Sk.misceval.tryCatch)
      self.Sk.misceval.iterFor = function(a, b, c) {
        var d = c,
          e = function(b) {
            d = b
            return b instanceof self.Sk.misceval.Break ? b : a.tp$iternext(!0)
          }
        return (function h(a) {
          for (; void 0 !== a; ) {
            if (a instanceof self.Sk.misceval.Suspension)
              return new self.Sk.misceval.Suspension(h, a)
            if (a === self.Sk.misceval.Break || a instanceof self.Sk.misceval.Break)
              return a.brValue
            a = self.Sk.misceval.chain(b(a, d), e)
          }
          return d
        })(a.tp$iternext(!0))
      }
      self.Sk.exportSymbol("Sk.misceval.iterFor", self.Sk.misceval.iterFor)
      self.Sk.misceval.Break = function(a) {
        if (!(this instanceof self.Sk.misceval.Break))
          return new self.Sk.misceval.Break(a)
        this.brValue = a
      }
      self.Sk.exportSymbol("Sk.misceval.Break", self.Sk.misceval.Break)
      self.Sk.misceval.applyOrSuspend = function(a, b, c, d, e) {
        var f
        if (null === a || a instanceof self.Sk.builtin.none)
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not callable",
          )
        "function" === typeof a &&
          void 0 === a.tp$call &&
          (a = new self.Sk.builtin.func(a))
        var g = a.tp$call
        if (void 0 !== g) {
          if (c)
            for (
              c = c.tp$iter(), f = c.tp$iternext();
              void 0 !== f;
              f = c.tp$iternext()
            )
              e.push(f)
          if (b)
            for (
              c = self.Sk.abstr.iter(b), f = c.tp$iternext();
              void 0 !== f;
              f = c.tp$iternext()
            ) {
              if (!self.Sk.builtin.checkString(f))
                throw new self.Sk.builtin.TypeError(
                  "Function keywords must be strings",
                )
              d.push(f.v)
              d.push(self.Sk.abstr.objectGetItem(b, f, !1))
            }
          return g.call(a, e, d, b)
        }
        g = a.__call__
        if (void 0 !== g) return e.unshift(a), self.Sk.misceval.apply(g, b, c, d, e)
        throw new self.Sk.builtin.TypeError(
          "'" + self.Sk.abstr.typeName(a) + "' object is not callable",
        )
      }
      self.Sk.exportSymbol("Sk.misceval.applyOrSuspend", self.Sk.misceval.applyOrSuspend)
      self.Sk.misceval.promiseToSuspension = function(a) {
        var b = new self.Sk.misceval.Suspension()
        b.resume = function() {
          if (b.data.error) throw b.data.error
          return b.data.result
        }
        b.data = { type: "Sk.promise", promise: a }
        return b
      }
      self.Sk.exportSymbol(
        "Sk.misceval.promiseToSuspension",
        self.Sk.misceval.promiseToSuspension,
      )
      self.Sk.misceval.buildClass = function(a, b, c, d, e) {
        var f = self.Sk.builtin.type,
          g = {}
        b(a, g, void 0 === e ? {} : e)
        g.__module__ = a.__name__
        a = new self.Sk.builtin.str(c)
        d = new self.Sk.builtin.tuple(d)
        b = []
        for (var h in g)
          g.hasOwnProperty(h) && (b.push(new self.Sk.builtin.str(h)), b.push(g[h]))
        b = new self.Sk.builtin.dict(b)
        return self.Sk.misceval.callsimArray(f, [a, d, b])
      }
      self.Sk.exportSymbol("Sk.misceval.buildClass", self.Sk.misceval.buildClass)
    },
    function(m, p) {
      self.Sk.builtin.seqtype = function() {
        throw new self.Sk.builtin.ExternalError(
          "Cannot instantiate abstract self.Sk.builtin.seqtype class",
        )
      }
      self.Sk.abstr.setUpInheritance(
        "SequenceType",
        self.Sk.builtin.seqtype,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.seqtype.sk$abstract = !0
      self.Sk.builtin.seqtype.prototype.__len__ = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("__len__", arguments.length, 0, 0, !1, !0)
        return new self.Sk.builtin.int_(a.sq$length())
      })
      self.Sk.builtin.seqtype.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("__iter__", arguments.length, 0, 0, !1, !0)
        return a.tp$iter()
      })
      self.Sk.builtin.seqtype.prototype.__contains__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        self.Sk.builtin.pyCheckArgsLen(
          "__contains__",
          arguments.length,
          1,
          1,
          !1,
          !0,
        )
        return a.sq$contains(b) ? self.Sk.builtin.bool.true$ : self.Sk.builtin.bool.false$
      })
      self.Sk.builtin.seqtype.prototype.__getitem__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__getitem__", arguments.length, 1, 1, !1, !0)
        return a.mp$subscript(b)
      })
      self.Sk.builtin.seqtype.prototype.__add__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__add__", arguments.length, 1, 1, !1, !0)
        return a.sq$concat(b)
      })
      self.Sk.builtin.seqtype.prototype.__mul__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__mul__", arguments.length, 1, 1, !1, !0)
        if (!self.Sk.misceval.isIndex(b))
          throw new self.Sk.builtin.TypeError(
            "can't multiply sequence by non-int of type '" +
              self.Sk.abstr.typeName(b) +
              "'",
          )
        return a.sq$repeat(b)
      })
      self.Sk.builtin.seqtype.prototype.__rmul__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__rmul__", arguments.length, 1, 1, !1, !0)
        return a.sq$repeat(b)
      })
    },
    function(m, p) {
      self.Sk.builtin.list = function(a, b) {
        if (this instanceof self.Sk.builtin.list) b = b || !1
        else return new self.Sk.builtin.list(a, b || !0)
        this.__class__ = self.Sk.builtin.list
        if (void 0 === a) var c = []
        else if ("[object Array]" === Object.prototype.toString.apply(a)) c = a
        else {
          if (self.Sk.builtin.checkIterable(a)) {
            c = []
            var d = self.Sk.abstr.iter(a)
            var e = this
            return (function h(a) {
              for (;;) {
                if (a instanceof self.Sk.misceval.Suspension)
                  return new self.Sk.misceval.Suspension(h, a)
                if (void 0 === a) return (e.v = c), e
                c.push(a)
                a = d.tp$iternext(b)
              }
            })(d.tp$iternext(b))
          }
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not iterable",
          )
        }
        this.v = this.v = c
        return this
      }
      self.Sk.abstr.setUpInheritance("list", self.Sk.builtin.list, self.Sk.builtin.seqtype)
      self.Sk.abstr.markUnhashable(self.Sk.builtin.list)
      self.Sk.builtin.list.prototype.list_concat_ = function(a) {
        var b
        if (!a.__class__ || a.__class__ != self.Sk.builtin.list)
          throw new self.Sk.builtin.TypeError("can only concatenate list to list")
        var c = this.v.slice()
        for (b = 0; b < a.v.length; ++b) c.push(a.v[b])
        return new self.Sk.builtin.list(c, !1)
      }
      self.Sk.builtin.list.prototype.list_extend_ = function(a) {
        var b
        if (!self.Sk.builtin.checkIterable(a))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not iterable",
          )
        if (this == a) {
          var c = []
          a = self.Sk.abstr.iter(a)
          for (b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext()) c.push(b)
          this.v.push.apply(this.v, c)
        } else
          for (
            a = self.Sk.abstr.iter(a), b = a.tp$iternext();
            void 0 !== b;
            b = a.tp$iternext()
          )
            this.v.push(b)
        return this
      }
      self.Sk.builtin.list.prototype.list_del_item_ = function(a) {
        a = self.Sk.builtin.asnum$(a)
        if (0 > a || a >= this.v.length)
          throw new self.Sk.builtin.IndexError("list assignment index out of range")
        this.list_del_slice_(a, a + 1)
      }
      self.Sk.builtin.list.prototype.list_del_slice_ = function(a, b) {
        a = self.Sk.builtin.asnum$(a)
        b = self.Sk.builtin.asnum$(b)
        var c = []
        c.unshift(b - a)
        c.unshift(a)
        this.v.splice.apply(this.v, c)
      }
      self.Sk.builtin.list.prototype.list_ass_item_ = function(a, b) {
        a = self.Sk.builtin.asnum$(a)
        if (0 > a || a >= this.v.length)
          throw new self.Sk.builtin.IndexError("list assignment index out of range")
        this.v[a] = b
      }
      self.Sk.builtin.list.prototype.list_ass_slice_ = function(a, b, c) {
        a = self.Sk.builtin.asnum$(a)
        b = self.Sk.builtin.asnum$(b)
        if (self.Sk.builtin.checkIterable(c))
          c = new self.Sk.builtin.list(c, !1).v.slice(0)
        else throw new self.Sk.builtin.TypeError("can only assign an iterable")
        c.unshift(b - a)
        c.unshift(a)
        this.v.splice.apply(this.v, c)
      }
      self.Sk.builtin.list.prototype.$r = function() {
        var a,
          b = []
        var c = self.Sk.abstr.iter(this)
        for (a = c.tp$iternext(); void 0 !== a; a = c.tp$iternext())
          a === this ? b.push("[...]") : b.push(self.Sk.misceval.objectRepr(a).v)
        return new self.Sk.builtin.str("[" + b.join(", ") + "]")
      }
      self.Sk.builtin.list.prototype.tp$richcompare = function(a, b) {
        var c
        if (this === a && self.Sk.misceval.opAllowsEquality(b)) return !0
        if (!a.__class__ || a.__class__ != self.Sk.builtin.list)
          return "Eq" === b
            ? !1
            : "NotEq" === b
            ? !0
            : self.Sk.__future__.python3
            ? self.Sk.builtin.NotImplemented.NotImplemented$
            : !1
        var d = this.v
        a = a.v
        var e = d.length
        var f = a.length
        for (c = 0; c < e && c < f; ++c) {
          var g = self.Sk.misceval.richCompareBool(d[c], a[c], "Eq")
          if (!g) break
        }
        if (c >= e || c >= f)
          switch (b) {
            case "Lt":
              return e < f
            case "LtE":
              return e <= f
            case "Eq":
              return e === f
            case "NotEq":
              return e !== f
            case "Gt":
              return e > f
            case "GtE":
              return e >= f
            default:
              self.Sk.asserts.fail()
          }
        return "Eq" === b
          ? !1
          : "NotEq" === b
          ? !0
          : self.Sk.misceval.richCompareBool(d[c], a[c], b)
      }
      self.Sk.builtin.list.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("__iter__", arguments.length, 0, 0, !0, !1)
        return new self.Sk.builtin.list_iter_(a)
      })
      self.Sk.builtin.list.prototype.tp$iter = function() {
        return new self.Sk.builtin.list_iter_(this)
      }
      self.Sk.builtin.list.prototype.sq$length = function() {
        return this.v.length
      }
      self.Sk.builtin.list.prototype.sq$concat =
        self.Sk.builtin.list.prototype.list_concat_
      self.Sk.builtin.list.prototype.nb$add = self.Sk.builtin.list.prototype.list_concat_
      self.Sk.builtin.list.prototype.nb$inplace_add =
        self.Sk.builtin.list.prototype.list_extend_
      self.Sk.builtin.list.prototype.sq$repeat = function(a) {
        var b, c
        if (!self.Sk.misceval.isIndex(a))
          throw new self.Sk.builtin.TypeError(
            "can't multiply sequence by non-int of type '" +
              self.Sk.abstr.typeName(a) +
              "'",
          )
        a = self.Sk.misceval.asIndex(a)
        var d = []
        for (c = 0; c < a; ++c)
          for (b = 0; b < this.v.length; ++b) d.push(this.v[b])
        return new self.Sk.builtin.list(d, !1)
      }
      self.Sk.builtin.list.prototype.nb$multiply =
        self.Sk.builtin.list.prototype.sq$repeat
      self.Sk.builtin.list.prototype.nb$inplace_multiply = function(a) {
        var b, c
        if (!self.Sk.misceval.isIndex(a))
          throw new self.Sk.builtin.TypeError(
            "can't multiply sequence by non-int of type '" +
              self.Sk.abstr.typeName(a) +
              "'",
          )
        a = self.Sk.misceval.asIndex(a)
        var d = this.v.length
        for (c = 1; c < a; ++c) for (b = 0; b < d; ++b) this.v.push(this.v[b])
        return this
      }
      self.Sk.builtin.list.prototype.sq$ass_item =
        self.Sk.builtin.list.prototype.list_ass_item_
      self.Sk.builtin.list.prototype.sq$del_item =
        self.Sk.builtin.list.prototype.list_del_item_
      self.Sk.builtin.list.prototype.sq$ass_slice =
        self.Sk.builtin.list.prototype.list_ass_slice_
      self.Sk.builtin.list.prototype.sq$del_slice =
        self.Sk.builtin.list.prototype.list_del_slice_
      self.Sk.builtin.list.prototype.sq$contains = function(a) {
        var b
        var c = this.tp$iter()
        for (b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
          if (self.Sk.misceval.richCompareBool(b, a, "Eq")) return !0
        return !1
      }
      self.Sk.builtin.list.prototype.__contains__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__contains__", arguments.length, 2, 2)
        return new self.Sk.builtin.bool(a.sq$contains(b))
      })
      self.Sk.builtin.list.prototype.list_subscript_ = function(a) {
        if (self.Sk.misceval.isIndex(a)) {
          var b = self.Sk.misceval.asIndex(a)
          if (void 0 !== b) {
            0 > b && (b = this.v.length + b)
            if (0 > b || b >= this.v.length)
              throw new self.Sk.builtin.IndexError("list index out of range")
            return this.v[b]
          }
        } else if (a instanceof self.Sk.builtin.slice) {
          var c = []
          a.sssiter$(this, function(a, b) {
            c.push(b.v[a])
          })
          return new self.Sk.builtin.list(c, !1)
        }
        throw new self.Sk.builtin.TypeError(
          "list indices must be integers, not " + self.Sk.abstr.typeName(a),
        )
      }
      self.Sk.builtin.list.prototype.list_ass_subscript_ = function(a, b) {
        if (self.Sk.misceval.isIndex(a)) {
          var c = self.Sk.misceval.asIndex(a)
          if (void 0 !== c) {
            0 > c && (c = this.v.length + c)
            this.list_ass_item_(c, b)
            return
          }
        } else if (a instanceof self.Sk.builtin.slice) {
          c = a.slice_indices_(this.v.length)
          if (1 === c[2]) this.list_ass_slice_(c[0], c[1], b)
          else {
            var d = []
            a.sssiter$(this, function(a, b) {
              d.push(a)
            })
            a = 0
            if (d.length !== b.v.length)
              throw new self.Sk.builtin.ValueError(
                "attempt to assign sequence of size " +
                  b.v.length +
                  " to extended slice of size " +
                  d.length,
              )
            for (c = 0; c < d.length; ++c)
              this.v.splice(d[c], 1, b.v[a]), (a += 1)
          }
          return
        }
        throw new self.Sk.builtin.TypeError(
          "list indices must be integers, not " + self.Sk.abstr.typeName(a),
        )
      }
      self.Sk.builtin.list.prototype.list_del_subscript_ = function(a) {
        if (self.Sk.misceval.isIndex(a)) {
          var b = self.Sk.misceval.asIndex(a)
          if (void 0 !== b) {
            0 > b && (b = this.v.length + b)
            this.list_del_item_(b)
            return
          }
        } else if (a instanceof self.Sk.builtin.slice) {
          b = a.slice_indices_(this.v.length)
          if (1 === b[2]) this.list_del_slice_(b[0], b[1])
          else {
            var c = this
            var d = 0
            var e = 0 < b[2] ? 1 : 0
            a.sssiter$(this, function(a, b) {
              c.v.splice(a - d, 1)
              d += e
            })
          }
          return
        }
        throw new self.Sk.builtin.TypeError(
          "list indices must be integers, not " + typeof a,
        )
      }
      self.Sk.builtin.list.prototype.mp$subscript =
        self.Sk.builtin.list.prototype.list_subscript_
      self.Sk.builtin.list.prototype.mp$ass_subscript =
        self.Sk.builtin.list.prototype.list_ass_subscript_
      self.Sk.builtin.list.prototype.mp$del_subscript =
        self.Sk.builtin.list.prototype.list_del_subscript_
      self.Sk.builtin.list.prototype.__getitem__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        return self.Sk.builtin.list.prototype.list_subscript_.call(a, b)
      })
      self.Sk.builtin.list.prototype.__setitem__ = new self.Sk.builtin.func(function(
        a,
        b,
        c,
      ) {
        return self.Sk.builtin.list.prototype.list_ass_subscript_.call(a, b, c)
      })
      self.Sk.builtin.list.prototype.__delitem__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        return self.Sk.builtin.list.prototype.list_del_subscript_.call(a, b)
      })
      self.Sk.builtin.list.prototype.list_sort_ = function(a, b, c, d) {
        var e,
          f = void 0 !== c && null !== c && c !== self.Sk.builtin.none.none$
        var g = void 0 !== b && null !== b && b !== self.Sk.builtin.none.none$
        if (void 0 === d) var h = !1
        else {
          if (d === self.Sk.builtin.none.none$)
            throw new self.Sk.builtin.TypeError("an integer is required")
          h = self.Sk.misceval.isTrue(d)
        }
        d = new self.Sk.builtin.timSort(a)
        a.v = []
        var k = new self.Sk.builtin.int_(0)
        if (f)
          for (
            d.lt = g
              ? function(a, c) {
                  a = self.Sk.misceval.callsimArray(b, [a[0], c[0]])
                  return self.Sk.misceval.richCompareBool(a, k, "Lt")
                }
              : function(a, b) {
                  return self.Sk.misceval.richCompareBool(a[0], b[0], "Lt")
                },
              e = 0;
            e < d.listlength;
            e++
          ) {
            g = d.list.v[e]
            var l = self.Sk.misceval.callsimArray(c, [g])
            d.list.v[e] = [l, g]
          }
        else
          g &&
            (d.lt = function(a, c) {
              a = self.Sk.misceval.callsimArray(b, [a, c])
              return self.Sk.misceval.richCompareBool(a, k, "Lt")
            })
        h && d.list.list_reverse_(d.list)
        d.sort()
        h && d.list.list_reverse_(d.list)
        if (f)
          for (c = 0; c < d.listlength; c++)
            (g = d.list.v[c][1]), (d.list.v[c] = g)
        c = 0 < a.sq$length()
        a.v = d.list.v
        if (c) throw new self.Sk.builtin.OperationError("list modified during sort")
        return self.Sk.builtin.none.none$
      }
      self.Sk.builtin.list.prototype.list_sort_.co_varnames = [
        "__self__",
        "cmp",
        "key",
        "reverse",
      ]
      self.Sk.builtin.list.prototype.list_sort_.$defaults = [
        self.Sk.builtin.none.none$,
        self.Sk.builtin.none.none$,
        !1,
      ]
      self.Sk.builtin.list.prototype.list_reverse_ = function(a) {
        self.Sk.builtin.pyCheckArgsLen("reverse", arguments.length, 1, 1)
        var b = a.v.length
        var c = a.v
        var d = []
        for (--b; -1 < b; --b) d.push(c[b])
        a.v = d
        return self.Sk.builtin.none.none$
      }
      self.Sk.builtin.list.prototype.append = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("append", arguments.length, 2, 2)
        a.v.push(b)
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.list.prototype.insert = new self.Sk.builtin.func(function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("insert", arguments.length, 3, 3)
        if (!self.Sk.builtin.checkNumber(b))
          throw new self.Sk.builtin.TypeError("an integer is required")
        b = self.Sk.builtin.asnum$(b)
        0 > b && (b += a.v.length)
        0 > b ? (b = 0) : b > a.v.length && (b = a.v.length)
        a.v.splice(b, 0, c)
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.list.prototype.extend = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("extend", arguments.length, 2, 2)
        a.list_extend_(b)
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.list.prototype.pop = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("pop", arguments.length, 1, 2)
        void 0 === b && (b = a.v.length - 1)
        if (!self.Sk.builtin.checkNumber(b))
          throw new self.Sk.builtin.TypeError("an integer is required")
        b = self.Sk.builtin.asnum$(b)
        0 > b && (b += a.v.length)
        if (0 > b || b >= a.v.length)
          throw new self.Sk.builtin.IndexError("pop index out of range")
        var c = a.v[b]
        a.v.splice(b, 1)
        return c
      })
      self.Sk.builtin.list.prototype.remove = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("remove", arguments.length, 2, 2)
        var c = self.Sk.builtin.list.prototype.index.func_code(a, b)
        a.v.splice(self.Sk.builtin.asnum$(c), 1)
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.list.prototype.clear$ = function(a) {
        self.Sk.builtin.pyCheckArgsLen("clear", arguments.length, 1, 1)
        a.v = []
        return self.Sk.builtin.none.none$
      }
      self.Sk.builtin.list.prototype.index = new self.Sk.builtin.func(function(
        a,
        b,
        c,
        d,
      ) {
        self.Sk.builtin.pyCheckArgsLen("index", arguments.length, 2, 4)
        if (void 0 !== c && !self.Sk.builtin.checkInt(c))
          throw new self.Sk.builtin.TypeError("slice indices must be integers")
        if (void 0 !== d && !self.Sk.builtin.checkInt(d))
          throw new self.Sk.builtin.TypeError("slice indices must be integers")
        var e = a.v.length
        var f = a.v
        c = void 0 === c ? 0 : c.v
        0 > c && (c = 0 <= c + e ? c + e : 0)
        d = void 0 === d ? e : d.v
        0 > d && (d = 0 <= d + e ? d + e : 0)
        for (e = c; e < d; ++e)
          if (self.Sk.misceval.richCompareBool(f[e], b, "Eq"))
            return new self.Sk.builtin.int_(e)
        throw new self.Sk.builtin.ValueError("list.index(x): x not in list")
      })
      self.Sk.builtin.list.prototype.count = new self.Sk.builtin.func(function(a, b) {
        var c, d
        self.Sk.builtin.pyCheckArgsLen("count", arguments.length, 2, 2)
        var e = a.v.length
        var f = a.v
        for (c = d = 0; c < e; ++c)
          self.Sk.misceval.richCompareBool(f[c], b, "Eq") && (d += 1)
        return new self.Sk.builtin.int_(d)
      })
      self.Sk.builtin.list.prototype.copy = new self.Sk.builtin.func(function(a) {
        var b
        self.Sk.builtin.pyCheckArgsLen("copy", arguments.length - 1, 0, 0)
        var c = []
        var d = self.Sk.abstr.iter(a)
        for (b = d.tp$iternext(); void 0 !== b; b = d.tp$iternext()) c.push(b)
        return new self.Sk.builtin.list(c)
      })
      self.Sk.builtin.list.prototype.reverse = new self.Sk.builtin.func(
        self.Sk.builtin.list.prototype.list_reverse_,
      )
      self.Sk.builtin.list.prototype.sort = new self.Sk.builtin.func(
        self.Sk.builtin.list.prototype.list_sort_,
      )
      self.Sk.exportSymbol("Sk.builtin.list", self.Sk.builtin.list)
      self.Sk.builtin.list_iter_ = function(a) {
        if (!(this instanceof self.Sk.builtin.list_iter_))
          return new self.Sk.builtin.list_iter_(a)
        this.$index = 0
        this.lst = a.v.slice()
        this.sq$length = this.lst.length
        this.tp$iter = this
        this.tp$iternext = function() {
          if (!(this.$index >= this.sq$length)) return this.lst[this.$index++]
        }
        this.$r = function() {
          return new self.Sk.builtin.str("listiterator")
        }
        return this
      }
      self.Sk.abstr.setUpInheritance(
        "listiterator",
        self.Sk.builtin.list_iter_,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.list_iter_.prototype.__class__ = self.Sk.builtin.list_iter_
      self.Sk.builtin.list_iter_.prototype.__iter__ = new self.Sk.builtin.func(function(
        a,
      ) {
        return a
      })
      self.Sk.builtin.list_iter_.prototype.next$ = function(a) {
        a = a.tp$iternext()
        if (void 0 === a) throw new self.Sk.builtin.StopIteration()
        return a
      }
    },
    function(m, p) {
      self.Sk.builtin.interned = {}
      self.Sk.builtin.str = function(a) {
        self.Sk.builtin.pyCheckArgsLen("str", arguments.length, 0, 1)
        void 0 === a && (a = "")
        if (a instanceof self.Sk.builtin.str) return a
        if (!(this instanceof self.Sk.builtin.str)) return new self.Sk.builtin.str(a)
        if (!0 === a) var b = "True"
        else if (!1 === a) b = "False"
        else if (null === a || a instanceof self.Sk.builtin.none) b = "None"
        else if (a instanceof self.Sk.builtin.bool) b = a.v ? "True" : "False"
        else if ("number" === typeof a)
          (b = a.toString()),
            "Infinity" === b ? (b = "inf") : "-Infinity" === b && (b = "-inf")
        else if ("string" === typeof a) b = a
        else {
          if (void 0 !== a.tp$str) {
            b = a.tp$str()
            if (!(b instanceof self.Sk.builtin.str))
              throw new self.Sk.builtin.ValueError("__str__ didn't return a str")
            return b
          }
          return self.Sk.misceval.objectRepr(a)
        }
        if (self.Sk.builtin.interned["1" + b]) return self.Sk.builtin.interned["1" + b]
        this.__class__ = self.Sk.builtin.str
        this.v = this.v = b
        self.Sk.builtin.interned["1" + b] = this
        return this
      }
      self.Sk.exportSymbol("Sk.builtin.str", self.Sk.builtin.str)
      self.Sk.abstr.setUpInheritance("str", self.Sk.builtin.str, self.Sk.builtin.seqtype)
      self.Sk.builtin.str.prototype.$jsstr = function() {
        return this.v
      }
      self.Sk.builtin.str.prototype.mp$subscript = function(a) {
        if (self.Sk.misceval.isIndex(a)) {
          a = self.Sk.misceval.asIndex(a)
          0 > a && (a = this.v.length + a)
          if (0 > a || a >= this.v.length)
            throw new self.Sk.builtin.IndexError("string index out of range")
          return new self.Sk.builtin.str(this.v.charAt(a))
        }
        if (a instanceof self.Sk.builtin.slice) {
          var b = ""
          a.sssiter$(this, function(a, d) {
            0 <= a && a < d.v.length && (b += d.v.charAt(a))
          })
          return new self.Sk.builtin.str(b)
        }
        throw new self.Sk.builtin.TypeError(
          "string indices must be integers, not " + self.Sk.abstr.typeName(a),
        )
      }
      self.Sk.builtin.str.prototype.sq$length = function() {
        return this.v.length
      }
      self.Sk.builtin.str.prototype.sq$concat = function(a) {
        if (!a || !self.Sk.builtin.checkString(a))
          throw ((a = self.Sk.abstr.typeName(a)),
          new self.Sk.builtin.TypeError(
            "cannot concatenate 'str' and '" + a + "' objects",
          ))
        return new self.Sk.builtin.str(this.v + a.v)
      }
      self.Sk.builtin.str.prototype.nb$add = self.Sk.builtin.str.prototype.sq$concat
      self.Sk.builtin.str.prototype.nb$inplace_add =
        self.Sk.builtin.str.prototype.sq$concat
      self.Sk.builtin.str.prototype.sq$repeat = function(a) {
        var b
        if (!self.Sk.misceval.isIndex(a))
          throw new self.Sk.builtin.TypeError(
            "can't multiply sequence by non-int of type '" +
              self.Sk.abstr.typeName(a) +
              "'",
          )
        a = self.Sk.misceval.asIndex(a)
        var c = ""
        for (b = 0; b < a; ++b) c += this.v
        return new self.Sk.builtin.str(c)
      }
      self.Sk.builtin.str.prototype.nb$multiply = self.Sk.builtin.str.prototype.sq$repeat
      self.Sk.builtin.str.prototype.nb$inplace_multiply =
        self.Sk.builtin.str.prototype.sq$repeat
      self.Sk.builtin.str.prototype.sq$item = function() {
        self.Sk.asserts.fail()
      }
      self.Sk.builtin.str.prototype.sq$slice = function(a, b) {
        a = self.Sk.builtin.asnum$(a)
        b = self.Sk.builtin.asnum$(b)
        0 > a && (a = 0)
        return new self.Sk.builtin.str(this.v.substr(a, b - a))
      }
      self.Sk.builtin.str.prototype.sq$contains = function(a) {
        if (!(a instanceof self.Sk.builtin.str))
          throw new self.Sk.builtin.TypeError(
            "TypeError: 'In <string> requires string as left operand",
          )
        return -1 != this.v.indexOf(a.v)
      }
      self.Sk.builtin.str.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        return new self.Sk.builtin.str_iter_(a)
      })
      self.Sk.builtin.str.prototype.tp$iter = function() {
        return new self.Sk.builtin.str_iter_(this)
      }
      self.Sk.builtin.str.prototype.tp$richcompare = function(a, b) {
        if (!(a instanceof self.Sk.builtin.str))
          return self.Sk.__future__.python3
            ? self.Sk.builtin.NotImplemented.NotImplemented$
            : !1
        switch (b) {
          case "Lt":
            return this.v < a.v
          case "LtE":
            return this.v <= a.v
          case "Eq":
            return this.v === a.v
          case "NotEq":
            return this.v !== a.v
          case "Gt":
            return this.v > a.v
          case "GtE":
            return this.v >= a.v
          default:
            self.Sk.asserts.fail()
        }
      }
      self.Sk.builtin.str.prototype.$r = function() {
        var a,
          b = "'"
        ;-1 !== this.v.indexOf("'") && -1 === this.v.indexOf('"') && (b = '"')
        var c = this.v.length
        var d = b
        for (a = 0; a < c; ++a) {
          var e = this.v.charAt(a)
          e === b || "\\" === e
            ? (d += "\\" + e)
            : "\t" === e
            ? (d += "\\t")
            : "\n" === e
            ? (d += "\\n")
            : "\r" === e
            ? (d += "\\r")
            : " " > e || 127 <= e
            ? ((e = e.charCodeAt(0).toString(16)),
              2 > e.length && (e = "0" + e),
              (d += "\\x" + e))
            : (d += e)
        }
        return new self.Sk.builtin.str(d + b)
      }
      self.Sk.builtin.str.re_escape_ = function(a) {
        var b,
          c = [],
          d = /^[A-Za-z0-9]+$/
        for (b = 0; b < a.length; ++b) {
          var e = a.charAt(b)
          d.test(e)
            ? c.push(e)
            : "\\000" === e
            ? c.push("\\000")
            : c.push("\\" + e)
        }
        return c.join("")
      }
      self.Sk.builtin.str.prototype.lower = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("lower", arguments.length, 1, 1)
        return new self.Sk.builtin.str(a.v.toLowerCase())
      })
      self.Sk.builtin.str.prototype.upper = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("upper", arguments.length, 1, 1)
        return new self.Sk.builtin.str(a.v.toUpperCase())
      })
      self.Sk.builtin.str.prototype.capitalize = new self.Sk.builtin.func(function(a) {
        var b
        self.Sk.builtin.pyCheckArgsLen("capitalize", arguments.length, 1, 1)
        var c = a.v
        if (0 === c.length) return new self.Sk.builtin.str("")
        var d = c.charAt(0).toUpperCase()
        for (b = 1; b < c.length; b++) d += c.charAt(b).toLowerCase()
        return new self.Sk.builtin.str(d)
      })
      self.Sk.builtin.str.prototype.join = new self.Sk.builtin.func(function(a, b) {
        var c
        self.Sk.builtin.pyCheckArgsLen("join", arguments.length, 2, 2)
        self.Sk.builtin.pyCheckType("seq", "iterable", self.Sk.builtin.checkIterable(b))
        var d = []
        var e = b.tp$iter()
        for (c = e.tp$iternext(); void 0 !== c; c = e.tp$iternext()) {
          if (c.constructor !== self.Sk.builtin.str)
            throw new self.Sk.builtin.TypeError(
              "TypeError: sequence item " +
                d.length +
                ": expected string, " +
                typeof c +
                " found",
            )
          d.push(c.v)
        }
        return new self.Sk.builtin.str(d.join(a.v))
      })
      self.Sk.builtin.str.prototype.split = new self.Sk.builtin.func(function(a, b, c) {
        var d, e
        self.Sk.builtin.pyCheckArgsLen("split", arguments.length, 1, 3)
        if (void 0 === b || b instanceof self.Sk.builtin.none) b = null
        if (null !== b && !self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError("expected a string")
        if (null !== b && "" === b.v)
          throw new self.Sk.builtin.ValueError("empty separator")
        if (void 0 !== c && !self.Sk.builtin.checkInt(c))
          throw new self.Sk.builtin.TypeError("an integer is required")
        c = self.Sk.builtin.asnum$(c)
        var f = /[\s\xa0]+/g
        var g = a.v
        if (null === b) g = g.replace(/^[\s\xa0]+/, "")
        else {
          var h = b.v.replace(/([.*+?=|\\\/()\[\]\{\}^$])/g, "\\$1")
          f = new RegExp(h, "g")
        }
        var k = []
        for (
          h = d = 0;
          null != (e = f.exec(g)) &&
          e.index !== f.lastIndex &&
          !(k.push(new self.Sk.builtin.str(g.substring(d, e.index))),
          (d = f.lastIndex),
          (h += 1),
          c && h >= c);

        );
        g = g.substring(d)
        ;(null !== b || 0 < g.length) && k.push(new self.Sk.builtin.str(g))
        return new self.Sk.builtin.list(k)
      })
      self.Sk.builtin.str.prototype.strip = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("strip", arguments.length, 1, 2)
        if (void 0 !== b && !self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError("strip arg must be None or str")
        if (void 0 === b) var c = /^\s+|\s+$/g
        else
          (c = self.Sk.builtin.str.re_escape_(b.v)),
            (c = new RegExp("^[" + c + "]+|[" + c + "]+$", "g"))
        return new self.Sk.builtin.str(a.v.replace(c, ""))
      })
      self.Sk.builtin.str.prototype.lstrip = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("lstrip", arguments.length, 1, 2)
        if (void 0 !== b && !self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError("lstrip arg must be None or str")
        if (void 0 === b) var c = /^\s+/g
        else
          (c = self.Sk.builtin.str.re_escape_(b.v)),
            (c = new RegExp("^[" + c + "]+", "g"))
        return new self.Sk.builtin.str(a.v.replace(c, ""))
      })
      self.Sk.builtin.str.prototype.rstrip = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("rstrip", arguments.length, 1, 2)
        if (void 0 !== b && !self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError("rstrip arg must be None or str")
        if (void 0 === b) var c = /\s+$/g
        else
          (c = self.Sk.builtin.str.re_escape_(b.v)),
            (c = new RegExp("[" + c + "]+$", "g"))
        return new self.Sk.builtin.str(a.v.replace(c, ""))
      })
      self.Sk.builtin.str.prototype.__format__ = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__format__", arguments.length, 2, 2)
        if (self.Sk.builtin.checkString(b)) {
          var c = self.Sk.ffi.remapToJs(b)
          if ("" !== c && "s" !== c)
            throw new self.Sk.builtin.NotImplementedError(
              "format spec is not yet implemented",
            )
        } else {
          if (self.Sk.__future__.exceptions)
            throw new self.Sk.builtin.TypeError(
              "format() argument 2 must be str, not " + self.Sk.abstr.typeName(b),
            )
          throw new self.Sk.builtin.TypeError(
            "format expects arg 2 to be string or unicode, not " +
              self.Sk.abstr.typeName(b),
          )
        }
        return new self.Sk.builtin.str(a)
      })
      self.Sk.builtin.str.prototype.partition = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("partition", arguments.length, 2, 2)
        self.Sk.builtin.pyCheckType("sep", "string", self.Sk.builtin.checkString(b))
        var c = new self.Sk.builtin.str(b)
        var d = a.v.indexOf(c.v)
        return 0 > d
          ? new self.Sk.builtin.tuple([
              a,
              self.Sk.builtin.str.$emptystr,
              self.Sk.builtin.str.$emptystr,
            ])
          : new self.Sk.builtin.tuple([
              new self.Sk.builtin.str(a.v.substring(0, d)),
              c,
              new self.Sk.builtin.str(a.v.substring(d + c.v.length)),
            ])
      })
      self.Sk.builtin.str.prototype.rpartition = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("rpartition", arguments.length, 2, 2)
        self.Sk.builtin.pyCheckType("sep", "string", self.Sk.builtin.checkString(b))
        var c = new self.Sk.builtin.str(b)
        var d = a.v.lastIndexOf(c.v)
        return 0 > d
          ? new self.Sk.builtin.tuple([
              self.Sk.builtin.str.$emptystr,
              self.Sk.builtin.str.$emptystr,
              a,
            ])
          : new self.Sk.builtin.tuple([
              new self.Sk.builtin.str(a.v.substring(0, d)),
              c,
              new self.Sk.builtin.str(a.v.substring(d + c.v.length)),
            ])
      })
      self.Sk.builtin.str.prototype.count = new self.Sk.builtin.func(function(
        a,
        b,
        c,
        d,
      ) {
        self.Sk.builtin.pyCheckArgsLen("count", arguments.length, 2, 4)
        if (!self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError("expected a character buffer object")
        if (void 0 !== c && !self.Sk.builtin.checkInt(c))
          throw new self.Sk.builtin.TypeError(
            "slice indices must be integers or None or have an __index__ method",
          )
        if (void 0 !== d && !self.Sk.builtin.checkInt(d))
          throw new self.Sk.builtin.TypeError(
            "slice indices must be integers or None or have an __index__ method",
          )
        void 0 === c
          ? (c = 0)
          : ((c = self.Sk.builtin.asnum$(c)), (c = 0 <= c ? c : a.v.length + c))
        void 0 === d
          ? (d = a.v.length)
          : ((d = self.Sk.builtin.asnum$(d)), (d = 0 <= d ? d : a.v.length + d))
        var e = b.v.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
        e = new RegExp(e, "g")
        return (e = a.v.slice(c, d).match(e))
          ? new self.Sk.builtin.int_(e.length)
          : new self.Sk.builtin.int_(0)
      })
      self.Sk.builtin.str.prototype.ljust = new self.Sk.builtin.func(function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("ljust", arguments.length, 2, 3)
        if (!self.Sk.builtin.checkInt(b))
          throw new self.Sk.builtin.TypeError(
            "integer argument exepcted, got " + self.Sk.abstr.typeName(b),
          )
        if (void 0 !== c && (!self.Sk.builtin.checkString(c) || 1 !== c.v.length))
          throw new self.Sk.builtin.TypeError(
            "must be char, not " + self.Sk.abstr.typeName(c),
          )
        c = void 0 === c ? " " : c.v
        b = self.Sk.builtin.asnum$(b)
        if (a.v.length >= b) return a
        var d = Array.prototype.join.call(
          { length: Math.floor(b - a.v.length) + 1 },
          c,
        )
        return new self.Sk.builtin.str(a.v + d)
      })
      self.Sk.builtin.str.prototype.rjust = new self.Sk.builtin.func(function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("rjust", arguments.length, 2, 3)
        if (!self.Sk.builtin.checkInt(b))
          throw new self.Sk.builtin.TypeError(
            "integer argument exepcted, got " + self.Sk.abstr.typeName(b),
          )
        if (void 0 !== c && (!self.Sk.builtin.checkString(c) || 1 !== c.v.length))
          throw new self.Sk.builtin.TypeError(
            "must be char, not " + self.Sk.abstr.typeName(c),
          )
        c = void 0 === c ? " " : c.v
        b = self.Sk.builtin.asnum$(b)
        if (a.v.length >= b) return a
        var d = Array.prototype.join.call(
          { length: Math.floor(b - a.v.length) + 1 },
          c,
        )
        return new self.Sk.builtin.str(d + a.v)
      })
      self.Sk.builtin.str.prototype.center = new self.Sk.builtin.func(function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("center", arguments.length, 2, 3)
        if (!self.Sk.builtin.checkInt(b))
          throw new self.Sk.builtin.TypeError(
            "integer argument exepcted, got " + self.Sk.abstr.typeName(b),
          )
        if (void 0 !== c && (!self.Sk.builtin.checkString(c) || 1 !== c.v.length))
          throw new self.Sk.builtin.TypeError(
            "must be char, not " + self.Sk.abstr.typeName(c),
          )
        c = void 0 === c ? " " : c.v
        b = self.Sk.builtin.asnum$(b)
        if (a.v.length >= b) return a
        var d = Array.prototype.join.call(
          { length: Math.floor((b - a.v.length) / 2) + 1 },
          c,
        )
        d = d + a.v + d
        d.length < b && (d += c)
        return new self.Sk.builtin.str(d)
      })
      self.Sk.builtin.str.prototype.find = new self.Sk.builtin.func(function(a, b, c, d) {
        self.Sk.builtin.pyCheckArgsLen("find", arguments.length, 2, 4)
        if (!self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError("expected a character buffer object")
        if (void 0 !== c && !self.Sk.builtin.checkInt(c))
          throw new self.Sk.builtin.TypeError(
            "slice indices must be integers or None or have an __index__ method",
          )
        if (void 0 !== d && !self.Sk.builtin.checkInt(d))
          throw new self.Sk.builtin.TypeError(
            "slice indices must be integers or None or have an __index__ method",
          )
        void 0 === c
          ? (c = 0)
          : ((c = self.Sk.builtin.asnum$(c)), (c = 0 <= c ? c : a.v.length + c))
        void 0 === d
          ? (d = a.v.length)
          : ((d = self.Sk.builtin.asnum$(d)), (d = 0 <= d ? d : a.v.length + d))
        var e = a.v.indexOf(b.v, c)
        return new self.Sk.builtin.int_(e >= c && e < d ? e : -1)
      })
      self.Sk.builtin.str.prototype.index = new self.Sk.builtin.func(function(
        a,
        b,
        c,
        d,
      ) {
        self.Sk.builtin.pyCheckArgsLen("index", arguments.length, 2, 4)
        var e = self.Sk.misceval.callsimArray(a.find, [a, b, c, d])
        if (-1 === self.Sk.builtin.asnum$(e))
          throw new self.Sk.builtin.ValueError("substring not found")
        return e
      })
      self.Sk.builtin.str.prototype.rfind = new self.Sk.builtin.func(function(
        a,
        b,
        c,
        d,
      ) {
        self.Sk.builtin.pyCheckArgsLen("rfind", arguments.length, 2, 4)
        if (!self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError("expected a character buffer object")
        if (void 0 !== c && !self.Sk.builtin.checkInt(c))
          throw new self.Sk.builtin.TypeError(
            "slice indices must be integers or None or have an __index__ method",
          )
        if (void 0 !== d && !self.Sk.builtin.checkInt(d))
          throw new self.Sk.builtin.TypeError(
            "slice indices must be integers or None or have an __index__ method",
          )
        void 0 === c
          ? (c = 0)
          : ((c = self.Sk.builtin.asnum$(c)), (c = 0 <= c ? c : a.v.length + c))
        void 0 === d
          ? (d = a.v.length)
          : ((d = self.Sk.builtin.asnum$(d)), (d = 0 <= d ? d : a.v.length + d))
        var e = a.v.lastIndexOf(b.v, d)
        e = e !== d ? e : a.v.lastIndexOf(b.v, d - 1)
        return new self.Sk.builtin.int_(e >= c && e < d ? e : -1)
      })
      self.Sk.builtin.str.prototype.rindex = new self.Sk.builtin.func(function(
        a,
        b,
        c,
        d,
      ) {
        self.Sk.builtin.pyCheckArgsLen("rindex", arguments.length, 2, 4)
        var e = self.Sk.misceval.callsimArray(a.rfind, [a, b, c, d])
        if (-1 === self.Sk.builtin.asnum$(e))
          throw new self.Sk.builtin.ValueError("substring not found")
        return e
      })
      self.Sk.builtin.str.prototype.startswith = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("startswith", arguments.length, 2, 2)
        self.Sk.builtin.pyCheckType("tgt", "string", self.Sk.builtin.checkString(b))
        return new self.Sk.builtin.bool(0 === a.v.indexOf(b.v))
      })
      self.Sk.builtin.str.prototype.endswith = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("endswith", arguments.length, 2, 2)
        self.Sk.builtin.pyCheckType("tgt", "string", self.Sk.builtin.checkString(b))
        return new self.Sk.builtin.bool(
          -1 !== a.v.indexOf(b.v, a.v.length - b.v.length),
        )
      })
      self.Sk.builtin.str.prototype.replace = new self.Sk.builtin.func(function(
        a,
        b,
        c,
        d,
      ) {
        self.Sk.builtin.pyCheckArgsLen("replace", arguments.length, 3, 4)
        self.Sk.builtin.pyCheckType("oldS", "string", self.Sk.builtin.checkString(b))
        self.Sk.builtin.pyCheckType("newS", "string", self.Sk.builtin.checkString(c))
        if (void 0 !== d && !self.Sk.builtin.checkInt(d))
          throw new self.Sk.builtin.TypeError(
            "integer argument expected, got " + self.Sk.abstr.typeName(d),
          )
        d = self.Sk.builtin.asnum$(d)
        var e = new RegExp(self.Sk.builtin.str.re_escape_(b.v), "g")
        if (void 0 === d || 0 > d)
          return new self.Sk.builtin.str(a.v.replace(e, c.v))
        var f = 0
        return new self.Sk.builtin.str(
          a.v.replace(e, function(a) {
            f++
            return f <= d ? c.v : a
          }),
        )
      })
      self.Sk.builtin.str.prototype.zfill = new self.Sk.builtin.func(function(a, b) {
        var c = a.v,
          d = ""
        self.Sk.builtin.pyCheckArgsLen("zfill", arguments.length, 2, 2)
        if (!self.Sk.builtin.checkInt(b))
          throw new self.Sk.builtin.TypeError(
            "integer argument exepected, got " + self.Sk.abstr.typeName(b),
          )
        var e = b.v - c.length
        var f = "+" === c[0] || "-" === c[0] ? 1 : 0
        for (var g = 0; g < e; g++) d += "0"
        c = c.substr(0, f) + d + c.substr(f)
        return new self.Sk.builtin.str(c)
      })
      self.Sk.builtin.str.prototype.isdigit = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("isdigit", arguments.length, 1, 1)
        return new self.Sk.builtin.bool(/^\d+$/.test(a.v))
      })
      self.Sk.builtin.str.prototype.isspace = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("isspace", arguments.length, 1, 1)
        return new self.Sk.builtin.bool(/^\s+$/.test(a.v))
      })
      self.Sk.builtin.str.prototype.expandtabs = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("expandtabs", arguments.length, 1, 2)
        if (void 0 !== b && !self.Sk.builtin.checkInt(b))
          throw new self.Sk.builtin.TypeError(
            "integer argument exepected, got " + self.Sk.abstr.typeName(b),
          )
        b = void 0 === b ? 8 : self.Sk.builtin.asnum$(b)
        var c = Array(b + 1).join(" ")
        var d = a.v.replace(/([^\r\n\t]*)\t/g, function(a, d) {
          return d + c.slice(d.length % b)
        })
        return new self.Sk.builtin.str(d)
      })
      self.Sk.builtin.str.prototype.swapcase = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("swapcase", arguments.length, 1, 1)
        var b = a.v.replace(/[a-z]/gi, function(a) {
          var b = a.toLowerCase()
          return b === a ? a.toUpperCase() : b
        })
        return new self.Sk.builtin.str(b)
      })
      self.Sk.builtin.str.prototype.splitlines = new self.Sk.builtin.func(function(a, b) {
        var c = a.v,
          d,
          e = a.v.length,
          f = [],
          g = 0
        self.Sk.builtin.pyCheckArgsLen("splitlines", arguments.length, 1, 2)
        if (void 0 !== b && !self.Sk.builtin.checkBool(b))
          throw new self.Sk.builtin.TypeError(
            "boolean argument expected, got " + self.Sk.abstr.typeName(b),
          )
        b = void 0 === b ? !1 : b.v
        for (d = 0; d < e; d++) {
          var h = c.charAt(d)
          if ("\n" === c.charAt(d + 1) && "\r" === h)
            (h = d + 2),
              (g = c.slice(g, h)),
              b || (g = g.replace(/(\r|\n)/g, "")),
              f.push(new self.Sk.builtin.str(g)),
              (g = h)
          else if (("\n" === h && "\r" !== c.charAt(d - 1)) || "\r" === h)
            (h = d + 1),
              (g = c.slice(g, h)),
              b || (g = g.replace(/(\r|\n)/g, "")),
              f.push(new self.Sk.builtin.str(g)),
              (g = h)
        }
        g < e &&
          ((g = c.slice(g, e)),
          b || (g = g.replace(/(\r|\n)/g, "")),
          f.push(new self.Sk.builtin.str(g)))
        return new self.Sk.builtin.list(f)
      })
      self.Sk.builtin.str.prototype.title = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("title", arguments.length, 1, 1)
        var b = a.v.replace(/[a-z][a-z]*/gi, function(a) {
          return a[0].toUpperCase() + a.substr(1).toLowerCase()
        })
        return new self.Sk.builtin.str(b)
      })
      self.Sk.builtin.str.prototype.isalpha = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("isalpha", arguments.length, 1, 1)
        return new self.Sk.builtin.bool(a.v.length && !/[^a-zA-Z]/.test(a.v))
      })
      self.Sk.builtin.str.prototype.isalnum = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("isalnum", arguments.length, 1, 1)
        return new self.Sk.builtin.bool(a.v.length && !/[^a-zA-Z0-9]/.test(a.v))
      })
      self.Sk.builtin.str.prototype.isnumeric = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("isnumeric", arguments.length, 1, 1)
        return new self.Sk.builtin.bool(a.v.length && !/[^0-9]/.test(a.v))
      })
      self.Sk.builtin.str.prototype.islower = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("islower", arguments.length, 1, 1)
        return new self.Sk.builtin.bool(
          a.v.length && /[a-z]/.test(a.v) && !/[A-Z]/.test(a.v),
        )
      })
      self.Sk.builtin.str.prototype.isupper = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("isupper", arguments.length, 1, 1)
        return new self.Sk.builtin.bool(
          a.v.length && !/[a-z]/.test(a.v) && /[A-Z]/.test(a.v),
        )
      })
      self.Sk.builtin.str.prototype.istitle = new self.Sk.builtin.func(function(a) {
        var b = a.v,
          c = !1,
          d = !1,
          e
        self.Sk.builtin.pyCheckArgsLen("istitle", arguments.length, 1, 1)
        for (e = 0; e < b.length; e++) {
          var f = b.charAt(e)
          if (!/[a-z]/.test(f) && /[A-Z]/.test(f)) {
            if (d) return new self.Sk.builtin.bool(!1)
            c = d = !0
          } else if (/[a-z]/.test(f) && !/[A-Z]/.test(f)) {
            if (!d) return new self.Sk.builtin.bool(!1)
            c = !0
          } else d = !1
        }
        return new self.Sk.builtin.bool(c)
      })
      self.Sk.builtin.str.prototype.nb$remainder = function(a) {
        var b
        a.constructor === self.Sk.builtin.tuple ||
          (void 0 !== a.mp$subscript && a.constructor !== self.Sk.builtin.str) ||
          (a = new self.Sk.builtin.tuple([a]))
        var c = 0
        var d = this.v.replace(
          /%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g,
          function(d, f, g, h, k, l, r) {
            var e, q, m, x, p
            h = self.Sk.builtin.asnum$(h)
            k = self.Sk.builtin.asnum$(k)
            ;(void 0 !== f && "" !== f) || "%" == r || (e = c++)
            "" === k && (k = void 0)
            var J = (q = m = x = p = !1)
            g &&
              (-1 !== g.indexOf("-")
                ? (x = !0)
                : -1 !== g.indexOf("0") && (p = !0),
              -1 !== g.indexOf("+")
                ? (q = !0)
                : -1 !== g.indexOf(" ") && (m = !0),
              (J = -1 !== g.indexOf("#")))
            k && (k = parseInt(k.substr(1), 10))
            g = function(a, b) {
              var c
              b = self.Sk.builtin.asnum$(b)
              var d = !1
              if ("number" === typeof a) {
                0 > a && ((a = -a), (d = !0))
                var e = a.toString(b)
              } else
                a instanceof self.Sk.builtin.float_
                  ? ((e = a.str$(b, !1)),
                    2 < e.length &&
                      ".0" === e.substr(-2) &&
                      (e = e.substr(0, e.length - 2)),
                    (d = a.nb$isnegative()))
                  : a instanceof self.Sk.builtin.int_
                  ? ((e = a.str$(b, !1)), (d = a.nb$isnegative()))
                  : a instanceof self.Sk.builtin.lng &&
                    ((e = a.str$(b, !1)), (d = a.nb$isnegative()))
              self.Sk.asserts.assert(void 0 !== e, "unhandled number format")
              a = !1
              if (k) for (c = e.length; c < k; ++c) (e = "0" + e), (a = !0)
              c = ""
              d ? (c = "-") : q ? (c = "+" + c) : m && (c = " " + c)
              J &&
                (16 === b
                  ? (c += "0x")
                  : 8 !== b || a || "0" === e || (c += "0"))
              return [c, e]
            }
            d = function(a) {
              var b = a[0]
              a = a[1]
              if (h) {
                h = parseInt(h, 10)
                var c = a.length + b.length
                if (p) for (; c < h; ++c) a = "0" + a
                else if (x) for (; c < h; ++c) a += " "
                else for (; c < h; ++c) b = " " + b
              }
              return b + a
            }
            if (a.constructor === self.Sk.builtin.tuple) f = a.v[e]
            else if (void 0 !== a.mp$subscript && void 0 !== f)
              (f = f.substring(1, f.length - 1)),
                (f = a.mp$subscript(new self.Sk.builtin.str(f)))
            else if (
              a.constructor === self.Sk.builtin.dict ||
              a.constructor === self.Sk.builtin.list
            )
              f = a
            else
              throw new self.Sk.builtin.AttributeError(
                a.tp$name + " instance has no attribute 'mp$subscript'",
              )
            if ("d" === r || "i" === r) return d(g(f, 10))
            if ("o" === r) return d(g(f, 8))
            if ("x" === r) return d(g(f, 16))
            if ("X" === r) return d(g(f, 16)).toUpperCase()
            if (
              "f" === r ||
              "F" === r ||
              "e" === r ||
              "E" === r ||
              "g" === r ||
              "G" === r
            ) {
              e = self.Sk.builtin.asnum$(f)
              "string" === typeof e && (e = Number(e))
              if (Infinity === e) return "inf"
              if (-Infinity === e) return "-inf"
              if (isNaN(e)) return "nan"
              g = ["toExponential", "toFixed", "toPrecision"][
                "efg".indexOf(r.toLowerCase())
              ]
              if (void 0 === k || "" === k)
                if ("e" === r || "E" === r) k = 6
                else if ("f" === r || "F" === r)
                  k = self.Sk.__future__.python3 ? 6 : 7
              g = e[g](k)
              self.Sk.builtin.checkFloat(f) &&
                0 === e &&
                -Infinity === 1 / e &&
                (g = "-" + g)
              self.Sk.__future__.python3 &&
                (7 <= g.length &&
                  "0.0000" == g.slice(0, 6) &&
                  ((b = parseFloat(g)), (g = b.toExponential())),
                "-" == g.charAt(g.length - 2) &&
                  (g = g.slice(0, g.length - 1) + "0" + g.charAt(g.length - 1)))
              ;-1 !== "EFG".indexOf(r) && (g = g.toUpperCase())
              return d(["", g])
            }
            if ("c" === r) {
              if ("number" === typeof f) return String.fromCharCode(f)
              if (f instanceof self.Sk.builtin.int_) return String.fromCharCode(f.v)
              if (f instanceof self.Sk.builtin.float_)
                return String.fromCharCode(f.v)
              if (f instanceof self.Sk.builtin.lng)
                return String.fromCharCode(f.str$(10, !1)[0])
              if (f.constructor === self.Sk.builtin.str) return f.v.substr(0, 1)
              throw new self.Sk.builtin.TypeError("an integer is required")
            }
            if ("r" === r)
              return (r = self.Sk.builtin.repr(f)), k ? r.v.substr(0, k) : r.v
            if ("s" === r) {
              r = new self.Sk.builtin.str(f)
              r = r.$jsstr()
              if (k) return r.substr(0, k)
              h && (r = d([" ", r]))
              return r
            }
            if ("%" === r) return "%"
          },
        )
        return new self.Sk.builtin.str(d)
      }
      self.Sk.builtin.str_iter_ = function(a) {
        if (!(this instanceof self.Sk.builtin.str_iter_))
          return new self.Sk.builtin.str_iter_(a)
        this.$index = 0
        this.$obj = a.v.slice()
        this.sq$length = this.$obj.length
        this.tp$iter = this
        this.tp$iternext = function() {
          if (!(this.$index >= this.sq$length))
            return new self.Sk.builtin.str(this.$obj.substr(this.$index++, 1))
        }
        this.$r = function() {
          return new self.Sk.builtin.str("iterator")
        }
        return this
      }
      self.Sk.abstr.setUpInheritance(
        "iterator",
        self.Sk.builtin.str_iter_,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.str_iter_.prototype.__class__ = self.Sk.builtin.str_iter_
      self.Sk.builtin.str_iter_.prototype.__iter__ = new self.Sk.builtin.func(function(
        a,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__iter__", arguments.length, 0, 0, !0, !1)
        return a
      })
      self.Sk.builtin.str_iter_.prototype.next$ = function(a) {
        a = a.tp$iternext()
        if (void 0 === a) throw new self.Sk.builtin.StopIteration()
        return a
      }
    },
    function(m, p) {
      m = function(a) {
        var b = {}
        self.Sk.builtin.pyCheckArgsLen(
          "format",
          arguments.length,
          0,
          Infinity,
          !0,
          !0,
        )
        var c = new self.Sk.builtins.tuple(Array.prototype.slice.call(arguments, 1))
        var d = new self.Sk.builtins.dict(a)
        if (void 0 === arguments[1]) return c.v
        var e = 0
        if (0 !== d.size) {
          d = self.Sk.misceval.callsimArray(self.Sk.builtin.dict.prototype.items, [d])
          for (var f in d.v) b[d.v[f].v[0].v] = d.v[f].v[1]
        }
        for (var g in c.v) "0" !== g && (b[g - 1] = c.v[g])
        c = c.v[0].v.replace(
          /{(((?:\d+)|(?:\w+))?((?:\.(\w+))|(?:\[((?:\d+)|(?:\w+))\])?))?(?:!([rs]))?(?::((?:(.)?([<>=\^]))?([\+\-\s])?(#)?(0)?(\d+)?(,)?(?:\.(\d+))?([bcdeEfFgGnosxX%])?))?}/g,
          function(a, c, d, g, f, q, m, x, p, J, A, C, K, B, S, G, z, P, V) {
            var k, l, h, r
            B = self.Sk.builtin.asnum$(B)
            G = self.Sk.builtin.asnum$(G)
            if (void 0 !== q && "" !== q) {
              a = b[d]
              var n =
                a.constructor === Array
                  ? a[q]
                  : a instanceof self.Sk.builtin.dict
                  ? self.Sk.abstr.objectGetItem(a, new self.Sk.builtin.str(q), !1)
                  : self.Sk.abstr.objectGetItem(
                      a,
                      new self.Sk.builtin.int_(parseInt(q, 10)),
                      !1,
                    )
              e++
            } else if (void 0 !== f && "" !== f) (n = b[d][f]), e++
            else if (void 0 !== d && "" !== d) (n = b[d]), e++
            else if (void 0 === c || "" === c) (q = b[e]), e++, (n = q)
            else if (
              c instanceof self.Sk.builtin.int_ ||
              c instanceof self.Sk.builtin.float_ ||
              c instanceof self.Sk.builtin.lng ||
              !isNaN(parseInt(c, 10))
            )
              (q = b[c]), e++, (n = q)
            "" === G && (G = void 0)
            if (void 0 === p || "" === p) p = " "
            var D = (k = l = h = !1)
            x &&
              (void 0 !== A &&
                "" !== A &&
                (-1 !== "-".indexOf(A)
                  ? (h = !0)
                  : -1 !== "+".indexOf(A)
                  ? (k = !0)
                  : -1 !== " ".indexOf(A) && (l = !0)),
              C && (D = -1 !== "#".indexOf(C)),
              void 0 === B ||
                "" === B ||
                (void 0 !== p && "" !== p) ||
                (p = " "),
              -1 !== "%".indexOf(z) && (r = !0))
            G && (G = parseInt(G, 10))
            var H = function(a) {
              if (void 0 === m || "" === m || "s" == m)
                return (a = new self.Sk.builtin.str(a)), a.v
              if ("r" == m) return (a = self.Sk.builtin.repr(a)), a.v
            }
            var N = function(a, b) {
              b = self.Sk.ffi.remapToJs(b)
              r && (b += "%")
              if (void 0 !== B && "" !== B) {
                B = parseInt(B, 10)
                var c = b.length + a.length
                if (h) for (; c < B; ++c) b += p
                else if (-1 !== ">".indexOf(J)) for (; c < B; ++c) a = p + a
                else if (-1 !== "^".indexOf(J))
                  for (; c < B; ++c)
                    0 === c % 2 ? (a = p + a) : 1 === c % 2 && (b += p)
                else if (-1 !== "=".indexOf(J)) for (; c < B; ++c) b = p + b
                else for (; c < B; ++c) b += p
              }
              return H(a + b)
            }
            A = function(a, b) {
              b = self.Sk.builtin.asnum$(b)
              var c = !1
              if (void 0 === x) return H(n)
              if ("number" === typeof a) {
                0 > a && ((a = -a), (c = !0))
                var d = a.toString(b)
              } else
                a instanceof self.Sk.builtin.float_
                  ? ((d = a.str$(b, !1)),
                    2 < d.length &&
                      ".0" === d.substr(-2) &&
                      (d = d.substr(0, d.length - 2)),
                    (c = a.nb$isnegative()))
                  : a instanceof self.Sk.builtin.int_
                  ? ((d = a.str$(b, !1)), (c = a.nb$isnegative()))
                  : a instanceof self.Sk.builtin.lng
                  ? ((d = a.str$(b, !1)), (c = a.nb$isnegative()))
                  : (d = a)
              G &&
                ((a = Number(d)),
                0 > a && ((a = -a), (c = !0)),
                (d = a.toFixed(G)))
              a = ""
              c ? (a = "-") : k ? (a = "+") : l && (a = " ")
              D &&
                (16 === b
                  ? (a += "0x")
                  : 8 === b && "0" !== d
                  ? (a += "0o")
                  : 2 === b && "0" !== d && (a += "0b"))
              "n" === z
                ? (d = d.toLocaleString())
                : -1 !== ",".indexOf(S) &&
                  ((b = d.toString().split(".")),
                  (b[0] = b[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",")),
                  (d = b.join(".")))
              return N(a, d)
            }
            if ("d" === z || "n" === z || "" === z || void 0 === z)
              return A(n, 10)
            if ("b" === z) return A(n, 2)
            if ("o" === z) return A(n, 8)
            if ("x" === z) return A(n, 16)
            if ("X" === z) return A(n, 16).toUpperCase()
            if (
              "f" === z ||
              "F" === z ||
              "e" === z ||
              "E" === z ||
              "g" === z ||
              "G" === z
            ) {
              if (D)
                throw new self.Sk.builtin.ValueError(
                  "Alternate form (#) not allowed in float format specifier",
                )
              q = self.Sk.builtin.asnum$(n)
              "string" === typeof q && (q = Number(q))
              if (Infinity === q) return N("", "inf")
              if (-Infinity === q) return N("-", "inf")
              if (isNaN(q)) return N("", "nan")
              C = ["toExponential", "toFixed", "toPrecision"][
                "efg".indexOf(z.toLowerCase())
              ]
              if (void 0 === G || "" === G)
                if ("e" === z || "E" === z || "%" === z) G = 6
                else if ("f" === z || "F" === z) G = 6
              C = q[C](G)
              ;-1 !== "EFG".indexOf(z) && (C = C.toUpperCase())
              return A(C, 10)
            }
            if ("c" === z) {
              if ("number" === typeof n) return N("", String.fromCharCode(n))
              if (
                n instanceof self.Sk.builtin.int_ ||
                n instanceof self.Sk.builtin.float_
              )
                return N("", String.fromCharCode(n.v))
              if (n instanceof self.Sk.builtin.lng)
                return N("", String.fromCharCode(n.str$(10, !1)[0]))
              if (n.constructor === self.Sk.builtin.str)
                return N("", n.v.substr(0, 1))
              throw new self.Sk.builtin.TypeError("an integer is required")
            }
            if (r)
              return (
                void 0 === G && (G = 7),
                A(n.nb$multiply(new self.Sk.builtin.int_(100)), 10)
              )
          },
        )
        return new self.Sk.builtin.str(c)
      }
      m.co_kwargs = !0
      self.Sk.builtin.str.prototype.format = new self.Sk.builtin.func(m)
    },
    function(m, p) {
      self.Sk.builtin.tuple = function(a) {
        var b
        if (!(this instanceof self.Sk.builtin.tuple))
          return (
            self.Sk.builtin.pyCheckArgsLen("tuple", arguments.length, 0, 1),
            new self.Sk.builtin.tuple(a)
          )
        void 0 === a && (a = [])
        if ("[object Array]" === Object.prototype.toString.apply(a)) this.v = a
        else if (self.Sk.builtin.checkIterable(a)) {
          this.v = []
          var c = self.Sk.abstr.iter(a)
          for (b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
            this.v.push(b)
        } else throw new self.Sk.builtin.TypeError("expecting Array or iterable")
        this.__class__ = self.Sk.builtin.tuple
        this.v = this.v
        return this
      }
      self.Sk.abstr.setUpInheritance("tuple", self.Sk.builtin.tuple, self.Sk.builtin.seqtype)
      self.Sk.builtin.tuple.prototype.$r = function() {
        var a
        if (0 === this.v.length) return new self.Sk.builtin.str("()")
        var b = []
        for (a = 0; a < this.v.length; ++a)
          b[a] = self.Sk.misceval.objectRepr(this.v[a]).v
        a = b.join(", ")
        1 === this.v.length && (a += ",")
        return new self.Sk.builtin.str("(" + a + ")")
      }
      self.Sk.builtin.tuple.prototype.mp$subscript = function(a) {
        if (self.Sk.misceval.isIndex(a)) {
          var b = self.Sk.misceval.asIndex(a)
          if (void 0 !== b) {
            0 > b && (b = this.v.length + b)
            if (0 > b || b >= this.v.length)
              throw new self.Sk.builtin.IndexError("tuple index out of range")
            return this.v[b]
          }
        } else if (a instanceof self.Sk.builtin.slice) {
          var c = []
          a.sssiter$(this, function(a, b) {
            c.push(b.v[a])
          })
          return new self.Sk.builtin.tuple(c)
        }
        throw new self.Sk.builtin.TypeError(
          "tuple indices must be integers, not " + self.Sk.abstr.typeName(a),
        )
      }
      self.Sk.builtin.tuple.prototype.tp$hash = function() {
        var a,
          b = 1000003,
          c = 3430008,
          d = this.v.length
        for (a = 0; a < d; ++a) {
          var e = self.Sk.builtin.hash(this.v[a]).v
          if (-1 === e) return new self.Sk.builtin.int_(-1)
          c = (c ^ e) * b
          b += 82520 + d + d
        }
        c += 97531
        ;-1 === c && (c = -2)
        return new self.Sk.builtin.int_(c | 0)
      }
      self.Sk.builtin.tuple.prototype.sq$repeat = function(a) {
        var b, c
        a = self.Sk.misceval.asIndex(a)
        var d = []
        for (c = 0; c < a; ++c)
          for (b = 0; b < this.v.length; ++b) d.push(this.v[b])
        return new self.Sk.builtin.tuple(d)
      }
      self.Sk.builtin.tuple.prototype.nb$multiply =
        self.Sk.builtin.tuple.prototype.sq$repeat
      self.Sk.builtin.tuple.prototype.nb$inplace_multiply =
        self.Sk.builtin.tuple.prototype.sq$repeat
      self.Sk.builtin.tuple.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("__iter__", arguments.length, 1, 1)
        return new self.Sk.builtin.tuple_iter_(a)
      })
      self.Sk.builtin.tuple.prototype.tp$iter = function() {
        return new self.Sk.builtin.tuple_iter_(this)
      }
      self.Sk.builtin.tuple.prototype.tp$richcompare = function(a, b) {
        var c
        if (
          !a.__class__ ||
          !self.Sk.misceval.isTrue(self.Sk.builtin.isinstance(a, self.Sk.builtin.tuple))
        )
          return "Eq" === b
            ? !1
            : "NotEq" === b
            ? !0
            : self.Sk.__future__.python3
            ? self.Sk.builtin.NotImplemented.NotImplemented$
            : !1
        var d = this.v
        a = a.v
        var e = d.length
        var f = a.length
        for (c = 0; c < e && c < f; ++c) {
          var g = self.Sk.misceval.richCompareBool(d[c], a[c], "Eq")
          if (!g) break
        }
        if (c >= e || c >= f)
          switch (b) {
            case "Lt":
              return e < f
            case "LtE":
              return e <= f
            case "Eq":
              return e === f
            case "NotEq":
              return e !== f
            case "Gt":
              return e > f
            case "GtE":
              return e >= f
            default:
              self.Sk.asserts.fail()
          }
        return "Eq" === b
          ? !1
          : "NotEq" === b
          ? !0
          : self.Sk.misceval.richCompareBool(d[c], a[c], b)
      }
      self.Sk.builtin.tuple.prototype.sq$concat = function(a) {
        if (a.__class__ != self.Sk.builtin.tuple)
          throw ((a =
            'can only concatenate tuple (not "' +
            (self.Sk.abstr.typeName(a) + '") to tuple')),
          new self.Sk.builtin.TypeError(a))
        return new self.Sk.builtin.tuple(this.v.concat(a.v))
      }
      self.Sk.builtin.tuple.prototype.sq$contains = function(a) {
        var b
        var c = this.tp$iter()
        for (b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
          if (self.Sk.misceval.richCompareBool(b, a, "Eq")) return !0
        return !1
      }
      self.Sk.builtin.tuple.prototype.nb$add = self.Sk.builtin.tuple.prototype.sq$concat
      self.Sk.builtin.tuple.prototype.nb$inplace_add =
        self.Sk.builtin.tuple.prototype.sq$concat
      self.Sk.builtin.tuple.prototype.sq$length = function() {
        return this.v.length
      }
      self.Sk.builtin.tuple.prototype.index = new self.Sk.builtin.func(function(a, b) {
        var c = a.v.length,
          d = a.v
        for (a = 0; a < c; ++a)
          if (self.Sk.misceval.richCompareBool(d[a], b, "Eq"))
            return new self.Sk.builtin.int_(a)
        throw new self.Sk.builtin.ValueError("tuple.index(x): x not in tuple")
      })
      self.Sk.builtin.tuple.prototype.count = new self.Sk.builtin.func(function(a, b) {
        var c = a.v.length,
          d = a.v,
          e = 0
        for (a = 0; a < c; ++a)
          self.Sk.misceval.richCompareBool(d[a], b, "Eq") && (e += 1)
        return new self.Sk.builtin.int_(e)
      })
      self.Sk.exportSymbol("Sk.builtin.tuple", self.Sk.builtin.tuple)
      self.Sk.builtin.tuple_iter_ = function(a) {
        if (!(this instanceof self.Sk.builtin.tuple_iter_))
          return new self.Sk.builtin.tuple_iter_(a)
        this.$index = 0
        this.$obj = a.v.slice()
        this.sq$length = this.$obj.length
        this.tp$iter = this
        this.tp$iternext = function() {
          if (!(this.$index >= this.sq$length)) return this.$obj[this.$index++]
        }
        this.$r = function() {
          return new self.Sk.builtin.str("tupleiterator")
        }
        return this
      }
      self.Sk.abstr.setUpInheritance(
        "tupleiterator",
        self.Sk.builtin.tuple_iter_,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.tuple_iter_.prototype.__class__ = self.Sk.builtin.tuple_iter_
      self.Sk.builtin.tuple_iter_.prototype.__iter__ = new self.Sk.builtin.func(function(
        a,
      ) {
        return a
      })
      self.Sk.builtin.tuple_iter_.prototype.next$ = function(a) {
        a = a.tp$iternext()
        if (void 0 === a) throw new self.Sk.builtin.StopIteration()
        return a
      }
    },
    function(m, p) {
      self.Sk.builtin.dict = function(a) {
        var b, d
        if (!(this instanceof self.Sk.builtin.dict)) return new self.Sk.builtin.dict(a)
        void 0 === a && (a = [])
        this.size = 0
        this.buckets = {}
        if ("[object Array]" === Object.prototype.toString.apply(a))
          for (b = 0; b < a.length; b += 2)
            this.mp$ass_subscript(a[b], a[b + 1])
        else if (a instanceof self.Sk.builtin.dict) {
          var e = self.Sk.abstr.iter(a)
          for (d = e.tp$iternext(); void 0 !== d; d = e.tp$iternext())
            (b = a.mp$subscript(d)),
              void 0 === b && (b = null),
              this.mp$ass_subscript(d, b)
        } else if (self.Sk.builtin.checkIterable(a))
          for (
            e = self.Sk.abstr.iter(a), b = e.tp$iternext();
            void 0 !== b;
            b = e.tp$iternext()
          )
            if (b.mp$subscript)
              this.mp$ass_subscript(b.mp$subscript(0), b.mp$subscript(1))
            else
              throw new self.Sk.builtin.TypeError(
                "element " + this.size + " is not a sequence",
              )
        else throw new self.Sk.builtin.TypeError("object is not iterable")
        this.__class__ = self.Sk.builtin.dict
        this.tp$call = void 0
        return this
      }
      self.Sk.builtin.dict.tp$call = function(a, c) {
        var b
        self.Sk.builtin.pyCheckArgsLen("dict", a, 0, 1)
        a = new self.Sk.builtin.dict(a[0])
        if (c)
          for (b = 0; b < c.length; b += 2)
            a.mp$ass_subscript(new self.Sk.builtin.str(c[b]), c[b + 1])
        return a
      }
      self.Sk.abstr.setUpInheritance("dict", self.Sk.builtin.dict, self.Sk.builtin.object)
      self.Sk.abstr.markUnhashable(self.Sk.builtin.dict)
      var a = self.Sk.builtin.hash
      self.Sk.builtin.dict.prototype.key$lookup = function(a, c) {
        var b, e
        for (e = 0; e < a.items.length; e++) {
          var f = a.items[e]
          if ((b = self.Sk.misceval.richCompareBool(f.lhs, c, "Eq"))) return f
        }
        return null
      }
      self.Sk.builtin.dict.prototype.key$pop = function(a, c) {
        var b, e
        for (e = 0; e < a.items.length; e++) {
          var f = a.items[e]
          if ((b = self.Sk.misceval.richCompareBool(f.lhs, c, "Eq")))
            return a.items.splice(e, 1), --this.size, f
        }
      }
      self.Sk.builtin.dict.prototype.mp$lookup = function(b) {
        var c = a(b)
        c = this.buckets[c.v]
        if (void 0 !== c && (b = this.key$lookup(c, b))) return b.rhs
      }
      self.Sk.builtin.dict.prototype.mp$subscript = function(a) {
        self.Sk.builtin.pyCheckArgsLen("[]", arguments.length, 1, 2, !1, !1)
        var b = this.mp$lookup(a)
        if (void 0 !== b) return b
        b = new self.Sk.builtin.str(a)
        throw new self.Sk.builtin.KeyError(b.v)
      }
      self.Sk.builtin.dict.prototype.sq$contains = function(a) {
        return void 0 !== this.mp$lookup(a)
      }
      self.Sk.builtin.dict.prototype.mp$ass_subscript = function(b, c) {
        var d = a(b),
          e = this.buckets[d.v]
        void 0 === e
          ? ((e = { $hash: d, items: [{ lhs: b, rhs: c }] }),
            (this.buckets[d.v] = e),
            (this.size += 1))
          : (d = this.key$lookup(e, b))
          ? (d.rhs = c)
          : (e.items.push({ lhs: b, rhs: c }), (this.size += 1))
      }
      self.Sk.builtin.dict.prototype.mp$del_subscript = function(b) {
        self.Sk.builtin.pyCheckArgsLen("del", arguments.length, 1, 1, !1, !1)
        var c = a(b)
        c = this.buckets[c.v]
        if (void 0 !== c && ((c = this.key$pop(c, b)), void 0 !== c)) return
        c = new self.Sk.builtin.str(b)
        throw new self.Sk.builtin.KeyError(c.v)
      }
      self.Sk.builtin.dict.prototype.$r = function() {
        var a,
          c = []
        var d = self.Sk.abstr.iter(this)
        for (a = d.tp$iternext(); void 0 !== a; a = d.tp$iternext()) {
          var e = this.mp$subscript(a)
          void 0 === e && (e = null)
          e === this
            ? c.push(self.Sk.misceval.objectRepr(a).v + ": {...}")
            : c.push(
                self.Sk.misceval.objectRepr(a).v +
                  ": " +
                  self.Sk.misceval.objectRepr(e).v,
              )
        }
        return new self.Sk.builtin.str("{" + c.join(", ") + "}")
      }
      self.Sk.builtin.dict.prototype.mp$length = function() {
        return this.size
      }
      self.Sk.builtin.dict.prototype.get = new self.Sk.builtin.func(function(a, c, d) {
        self.Sk.builtin.pyCheckArgsLen("get()", arguments.length, 1, 2, !1, !0)
        void 0 === d && (d = self.Sk.builtin.none.none$)
        var b = a.mp$lookup(c)
        void 0 === b && (b = d)
        return b
      })
      self.Sk.builtin.dict.prototype.pop = new self.Sk.builtin.func(function(b, c, d) {
        self.Sk.builtin.pyCheckArgsLen("pop()", arguments.length, 1, 2, !1, !0)
        var e = a(c)
        e = b.buckets[e.v]
        if (void 0 !== e && ((e = b.key$pop(e, c)), void 0 !== e)) return e.rhs
        if (void 0 !== d) return d
        e = new self.Sk.builtin.str(c)
        throw new self.Sk.builtin.KeyError(e.v)
      })
      self.Sk.builtin.dict.prototype.has_key = new self.Sk.builtin.func(function(a, c) {
        self.Sk.builtin.pyCheckArgsLen("has_key()", arguments.length, 1, 1, !1, !0)
        return new self.Sk.builtin.bool(a.sq$contains(c))
      })
      self.Sk.builtin.dict.prototype.items = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("items()", arguments.length, 0, 0, !1, !0)
        var b,
          d = []
        var e = self.Sk.abstr.iter(a)
        for (b = e.tp$iternext(); void 0 !== b; b = e.tp$iternext()) {
          var f = a.mp$subscript(b)
          void 0 === f && (f = null)
          d.push(new self.Sk.builtin.tuple([b, f]))
        }
        return new self.Sk.builtin.list(d)
      })
      self.Sk.builtin.dict.prototype.keys = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("keys()", arguments.length, 0, 0, !1, !0)
        var b,
          d = []
        var e = self.Sk.abstr.iter(a)
        for (b = e.tp$iternext(); void 0 !== b; b = e.tp$iternext()) d.push(b)
        return new self.Sk.builtin.list(d)
      })
      self.Sk.builtin.dict.prototype.values = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("values()", arguments.length, 0, 0, !1, !0)
        var b,
          d = []
        var e = self.Sk.abstr.iter(a)
        for (b = e.tp$iternext(); void 0 !== b; b = e.tp$iternext())
          (b = a.mp$subscript(b)), void 0 === b && (b = null), d.push(b)
        return new self.Sk.builtin.list(d)
      })
      self.Sk.builtin.dict.prototype.clear = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("clear()", arguments.length, 0, 0, !1, !0)
        var b
        var d = self.Sk.abstr.iter(a)
        for (b = d.tp$iternext(); void 0 !== b; b = d.tp$iternext())
          a.mp$del_subscript(b)
      })
      self.Sk.builtin.dict.prototype.setdefault = new self.Sk.builtin.func(function(
        a,
        c,
        d,
      ) {
        try {
          return a.mp$subscript(c)
        } catch (e) {
          return (
            void 0 === d && (d = self.Sk.builtin.none.none$),
            a.mp$ass_subscript(c, d),
            d
          )
        }
      })
      self.Sk.builtin.dict.prototype.dict_merge = function(a) {
        var b
        if (a instanceof self.Sk.builtin.dict) {
          var d = a.tp$iter()
          for (b = d.tp$iternext(); void 0 !== b; b = d.tp$iternext()) {
            var e = a.mp$subscript(b)
            if (void 0 === e)
              throw new self.Sk.builtin.AttributeError(
                "cannot get item for key: " + b.v,
              )
            this.mp$ass_subscript(b, e)
          }
        } else
          for (
            d = self.Sk.misceval.callsimArray(a.keys, [a]),
              d = self.Sk.abstr.iter(d),
              b = d.tp$iternext();
            void 0 !== b;
            b = d.tp$iternext()
          ) {
            e = a.tp$getitem(b)
            if (void 0 === e)
              throw new self.Sk.builtin.AttributeError(
                "cannot get item for key: " + b.v,
              )
            this.mp$ass_subscript(b, e)
          }
      }
      m = function(a, c, d) {
        if (void 0 !== d && ("dict" === d.tp$name || d.keys)) c.dict_merge(d)
        else if (void 0 !== d && self.Sk.builtin.checkIterable(d)) {
          var b,
            f = 0
          d = self.Sk.abstr.iter(d)
          for (b = d.tp$iternext(); void 0 !== b; b = d.tp$iternext(), f++) {
            if (!self.Sk.builtin.checkIterable(b))
              throw new self.Sk.builtin.TypeError(
                "cannot convert dictionary update sequence element #" +
                  f +
                  " to a sequence",
              )
            if (2 === b.sq$length()) {
              var g = self.Sk.abstr.iter(b)
              b = g.tp$iternext()
              g = g.tp$iternext()
              c.mp$ass_subscript(b, g)
            } else
              throw new self.Sk.builtin.ValueError(
                "dictionary update sequence element #" +
                  f +
                  " has length " +
                  b.sq$length() +
                  "; 2 is required",
              )
          }
        } else if (void 0 !== d)
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(d) + "' object is not iterable",
          )
        a = new self.Sk.builtins.dict(a)
        c.dict_merge(a)
        return self.Sk.builtin.none.none$
      }
      m.co_kwargs = !0
      self.Sk.builtin.dict.prototype.update = new self.Sk.builtin.func(m)
      self.Sk.builtin.dict.prototype.__contains__ = new self.Sk.builtin.func(function(
        a,
        c,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__contains__", arguments.length, 2, 2)
        return new self.Sk.builtin.bool(a.sq$contains(c))
      })
      self.Sk.builtin.dict.prototype.__cmp__ = new self.Sk.builtin.func(function(
        a,
        c,
        d,
      ) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      })
      self.Sk.builtin.dict.prototype.__delitem__ = new self.Sk.builtin.func(function(
        a,
        c,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__delitem__", arguments.length, 1, 1, !1, !0)
        return self.Sk.builtin.dict.prototype.mp$del_subscript.call(a, c)
      })
      self.Sk.builtin.dict.prototype.__getitem__ = new self.Sk.builtin.func(function(
        a,
        c,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__getitem__", arguments.length, 1, 1, !1, !0)
        return self.Sk.builtin.dict.prototype.mp$subscript.call(a, c)
      })
      self.Sk.builtin.dict.prototype.__setitem__ = new self.Sk.builtin.func(function(
        a,
        c,
        d,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__setitem__", arguments.length, 2, 2, !1, !0)
        return self.Sk.builtin.dict.prototype.mp$ass_subscript.call(a, c, d)
      })
      self.Sk.builtin.dict.prototype.__hash__ = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("__hash__", arguments.length, 0, 0, !1, !0)
        return self.Sk.builtin.dict.prototype.tp$hash.call(a)
      })
      self.Sk.builtin.dict.prototype.__len__ = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("__len__", arguments.length, 0, 0, !1, !0)
        return self.Sk.builtin.dict.prototype.mp$length.call(a)
      })
      self.Sk.builtin.dict.prototype.__getattribute__ = new self.Sk.builtin.func(function(
        a,
        c,
      ) {
        self.Sk.builtin.pyCheckArgsLen(
          "__getattribute__",
          arguments.length,
          1,
          1,
          !1,
          !0,
        )
        if (!self.Sk.builtin.checkString(c))
          throw new self.Sk.builtin.TypeError("__getattribute__ requires a string")
        return self.Sk.builtin.dict.prototype.tp$getattr.call(a, c)
      })
      self.Sk.builtin.dict.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("__iter__", arguments.length, 0, 0, !1, !0)
        return new self.Sk.builtin.dict_iter_(a)
      })
      self.Sk.builtin.dict.prototype.tp$iter = function() {
        return new self.Sk.builtin.dict_iter_(this)
      }
      self.Sk.builtin.dict.prototype.__repr__ = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("__repr__", arguments.length, 0, 0, !1, !0)
        return self.Sk.builtin.dict.prototype.$r.call(a)
      })
      self.Sk.builtin.dict.prototype.ob$eq = function(a) {
        var b
        if (this === a) return self.Sk.builtin.bool.true$
        if (!(a instanceof self.Sk.builtin.dict))
          return self.Sk.builtin.NotImplemented.NotImplemented$
        if (this.size !== a.size) return self.Sk.builtin.bool.false$
        var d = this.tp$iter()
        for (b = d.tp$iternext(); void 0 !== b; b = d.tp$iternext()) {
          var e = this.mp$subscript(b)
          b = a.mp$subscript(b)
          if (!self.Sk.misceval.richCompareBool(e, b, "Eq"))
            return self.Sk.builtin.bool.false$
        }
        return self.Sk.builtin.bool.true$
      }
      self.Sk.builtin.dict.prototype.ob$ne = function(a) {
        a = this.ob$eq(a)
        return a instanceof self.Sk.builtin.NotImplemented
          ? a
          : a.v
          ? self.Sk.builtin.bool.false$
          : self.Sk.builtin.bool.true$
      }
      self.Sk.builtin.dict.prototype.copy = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("copy", arguments.length, 0, 0, !1, !0)
        var b,
          d = new self.Sk.builtin.dict([])
        var e = self.Sk.abstr.iter(a)
        for (b = e.tp$iternext(); void 0 !== b; b = e.tp$iternext()) {
          var f = a.mp$subscript(b)
          void 0 === f && (f = null)
          d.mp$ass_subscript(b, f)
        }
        return d
      })
      self.Sk.builtin.dict.$fromkeys = function(a, c, d) {
        if (a instanceof self.Sk.builtin.dict) {
          self.Sk.builtin.pyCheckArgsLen("fromkeys", arguments.length, 1, 2, !1, !0)
          var b = a
          var f = c
          var g = void 0 === d ? self.Sk.builtin.none.none$ : d
        } else
          self.Sk.builtin.pyCheckArgsLen("fromkeys", arguments.length, 1, 2, !1, !1),
            (b = new self.Sk.builtin.dict([])),
            (f = a),
            (g = void 0 === c ? self.Sk.builtin.none.none$ : c)
        if (!self.Sk.builtin.checkIterable(f))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(f) + "' object is not iterable",
          )
        var h = self.Sk.abstr.iter(f)
        for (f = h.tp$iternext(); void 0 !== f; f = h.tp$iternext())
          b.mp$ass_subscript(f, g)
        return b
      }
      self.Sk.builtin.dict.prototype.iteritems = new self.Sk.builtin.func(function(a) {
        throw new self.Sk.builtin.NotImplementedError(
          "dict.iteritems is not yet implemented in Skulpt",
        )
      })
      self.Sk.builtin.dict.prototype.iterkeys = new self.Sk.builtin.func(function(a) {
        throw new self.Sk.builtin.NotImplementedError(
          "dict.iterkeys is not yet implemented in Skulpt",
        )
      })
      self.Sk.builtin.dict.prototype.itervalues = new self.Sk.builtin.func(function(a) {
        throw new self.Sk.builtin.NotImplementedError(
          "dict.itervalues is not yet implemented in Skulpt",
        )
      })
      self.Sk.builtin.dict.prototype.popitem = new self.Sk.builtin.func(function(a) {
        throw new self.Sk.builtin.NotImplementedError(
          "dict.popitem is not yet implemented in Skulpt",
        )
      })
      self.Sk.builtin.dict.prototype.viewitems = new self.Sk.builtin.func(function(a) {
        throw new self.Sk.builtin.NotImplementedError(
          "dict.viewitems is not yet implemented in Skulpt",
        )
      })
      self.Sk.builtin.dict.prototype.viewkeys = new self.Sk.builtin.func(function(a) {
        throw new self.Sk.builtin.NotImplementedError(
          "dict.viewkeys is not yet implemented in Skulpt",
        )
      })
      self.Sk.builtin.dict.prototype.viewvalues = new self.Sk.builtin.func(function(a) {
        throw new self.Sk.builtin.NotImplementedError(
          "dict.viewvalues is not yet implemented in Skulpt",
        )
      })
      self.Sk.exportSymbol("Sk.builtin.dict", self.Sk.builtin.dict)
      self.Sk.builtin.dict_iter_ = function(a) {
        var b, d
        if (!(this instanceof self.Sk.builtin.dict_iter_))
          return new self.Sk.builtin.dict_iter_(a)
        this.$index = 0
        this.$obj = a
        var e = []
        var f = a.buckets
        for (b in f)
          if (
            f.hasOwnProperty(b) &&
            (d = f[b]) &&
            void 0 !== d.$hash &&
            void 0 !== d.items
          )
            for (a = 0; a < d.items.length; a++) e.push(d.items[a].lhs)
        this.$keys = e
        this.tp$iter = this
        this.tp$iternext = function() {
          if (!(this.$index >= this.$keys.length))
            return this.$keys[this.$index++]
        }
        this.$r = function() {
          return new self.Sk.builtin.str("dictionary-keyiterator")
        }
        return this
      }
      self.Sk.abstr.setUpInheritance(
        "dictionary-keyiterator",
        self.Sk.builtin.dict_iter_,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.dict_iter_.prototype.__class__ = self.Sk.builtin.dict_iter_
      self.Sk.builtin.dict_iter_.prototype.__iter__ = new self.Sk.builtin.func(function(
        a,
      ) {
        return a
      })
      self.Sk.builtin.dict_iter_.prototype.next$ = function(a) {
        a = a.tp$iternext()
        if (void 0 === a) throw new self.Sk.builtin.StopIteration()
        return a
      }
    },
    function(m, p) {
      self.Sk.builtin.numtype = function() {
        throw new self.Sk.builtin.ExternalError(
          "Cannot instantiate abstract self.Sk.builtin.numtype class",
        )
      }
      self.Sk.abstr.setUpInheritance(
        "NumericType",
        self.Sk.builtin.numtype,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.numtype.sk$abstract = !0
      self.Sk.builtin.numtype.prototype.__abs__ = new self.Sk.builtin.func(function(a) {
        if (void 0 === a.nb$abs)
          throw new self.Sk.builtin.NotImplementedError(
            "__abs__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__abs__", arguments.length, 0, 0, !1, !0)
        return a.nb$abs()
      })
      self.Sk.builtin.numtype.prototype.__neg__ = new self.Sk.builtin.func(function(a) {
        if (void 0 === a.nb$negative)
          throw new self.Sk.builtin.NotImplementedError(
            "__neg__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__neg__", arguments.length, 0, 0, !1, !0)
        return a.nb$negative()
      })
      self.Sk.builtin.numtype.prototype.__pos__ = new self.Sk.builtin.func(function(a) {
        if (void 0 === a.nb$positive)
          throw new self.Sk.builtin.NotImplementedError(
            "__pos__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__pos__", arguments.length, 0, 0, !1, !0)
        return a.nb$positive()
      })
      self.Sk.builtin.numtype.prototype.__int__ = new self.Sk.builtin.func(function(a) {
        if (void 0 === a.nb$int_)
          throw new self.Sk.builtin.NotImplementedError(
            "__int__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__int__", arguments.length, 0, 0, !1, !0)
        return a.nb$int_()
      })
      self.Sk.builtin.numtype.prototype.__long__ = new self.Sk.builtin.func(function(a) {
        if (void 0 === a.nb$lng)
          throw new self.Sk.builtin.NotImplementedError(
            "__long__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__long__", arguments.length, 0, 0, !1, !0)
        return a.nb$lng()
      })
      self.Sk.builtin.numtype.prototype.__float__ = new self.Sk.builtin.func(function(a) {
        if (void 0 === a.nb$float_)
          throw new self.Sk.builtin.NotImplementedError(
            "__float__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__float__", arguments.length, 0, 0, !1, !0)
        return a.nb$float_()
      })
      self.Sk.builtin.numtype.prototype.__add__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$add)
          throw new self.Sk.builtin.NotImplementedError(
            "__add__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__add__", arguments.length, 1, 1, !1, !0)
        return a.nb$add(b)
      })
      self.Sk.builtin.numtype.prototype.__radd__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$reflected_add)
          throw new self.Sk.builtin.NotImplementedError(
            "__radd__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__radd__", arguments.length, 1, 1, !1, !0)
        return a.nb$reflected_add(b)
      })
      self.Sk.builtin.numtype.prototype.__sub__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$subtract)
          throw new self.Sk.builtin.NotImplementedError(
            "__sub__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__sub__", arguments.length, 1, 1, !1, !0)
        return a.nb$subtract(b)
      })
      self.Sk.builtin.numtype.prototype.__rsub__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$reflected_subtract)
          throw new self.Sk.builtin.NotImplementedError(
            "__rsub__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__rsub__", arguments.length, 1, 1, !1, !0)
        return a.nb$reflected_subtract(b)
      })
      self.Sk.builtin.numtype.prototype.__mul__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$multiply)
          throw new self.Sk.builtin.NotImplementedError(
            "__mul__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__mul__", arguments.length, 1, 1, !1, !0)
        return a.nb$multiply(b)
      })
      self.Sk.builtin.numtype.prototype.__rmul__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$reflected_multiply)
          throw new self.Sk.builtin.NotImplementedError(
            "__rmul__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__rmul__", arguments.length, 1, 1, !1, !0)
        return a.nb$reflected_multiply(b)
      })
      self.Sk.builtin.numtype.prototype.__div__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$divide)
          throw new self.Sk.builtin.NotImplementedError(
            "__div__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__div__", arguments.length, 1, 1, !1, !0)
        return a.nb$divide(b)
      })
      self.Sk.builtin.numtype.prototype.__rdiv__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$reflected_divide)
          throw new self.Sk.builtin.NotImplementedError(
            "__rdiv__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__rdiv__", arguments.length, 1, 1, !1, !0)
        return a.nb$reflected_divide(b)
      })
      self.Sk.builtin.numtype.prototype.__floordiv__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$floor_divide)
          throw new self.Sk.builtin.NotImplementedError(
            "__floordiv__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen(
          "__floordiv__",
          arguments.length,
          1,
          1,
          !1,
          !0,
        )
        return a.nb$floor_divide(b)
      })
      self.Sk.builtin.numtype.prototype.__rfloordiv__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$reflected_floor_divide)
          throw new self.Sk.builtin.NotImplementedError(
            "__rfloordiv__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen(
          "__rfloordiv__",
          arguments.length,
          1,
          1,
          !1,
          !0,
        )
        return a.nb$reflected_floor_divide(b)
      })
      self.Sk.builtin.numtype.prototype.__mod__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$remainder)
          throw new self.Sk.builtin.NotImplementedError(
            "__mod__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__mod__", arguments.length, 1, 1, !1, !0)
        return a.nb$remainder(b)
      })
      self.Sk.builtin.numtype.prototype.__rmod__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$reflected_remainder)
          throw new self.Sk.builtin.NotImplementedError(
            "__rmod__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__rmod__", arguments.length, 1, 1, !1, !0)
        return a.nb$reflected_remainder(b)
      })
      self.Sk.builtin.numtype.prototype.__divmod__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$divmod)
          throw new self.Sk.builtin.NotImplementedError(
            "__divmod__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__divmod__", arguments.length, 1, 1, !1, !0)
        return a.nb$divmod(b)
      })
      self.Sk.builtin.numtype.prototype.__rdivmod__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$reflected_divmod)
          throw new self.Sk.builtin.NotImplementedError(
            "__rdivmod__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__rdivmod__", arguments.length, 1, 1, !1, !0)
        return a.nb$reflected_divmod(b)
      })
      self.Sk.builtin.numtype.prototype.__pow__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$power)
          throw new self.Sk.builtin.NotImplementedError(
            "__pow__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__pow__", arguments.length, 1, 1, !1, !0)
        return a.nb$power(b)
      })
      self.Sk.builtin.numtype.prototype.__rpow__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        if (void 0 === a.nb$reflected_power)
          throw new self.Sk.builtin.NotImplementedError(
            "__rpow__ is not yet implemented",
          )
        self.Sk.builtin.pyCheckArgsLen("__rpow__", arguments.length, 1, 1, !1, !0)
        return a.nb$reflected_power(b)
      })
      self.Sk.builtin.numtype.prototype.__coerce__ = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        throw new self.Sk.builtin.NotImplementedError(
          "__coerce__ is not yet implemented",
        )
      })
      self.Sk.builtin.numtype.prototype.nb$add = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$reflected_add = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$inplace_add = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$subtract = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$reflected_subtract = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$inplace_subtract = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$multiply = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$reflected_multiply = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$inplace_multiply = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$divide = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$reflected_divide = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$inplace_divide = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$floor_divide = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$reflected_floor_divide = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$inplace_floor_divide = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$remainder = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$reflected_remainder = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$inplace_remainder = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$divmod = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$reflected_divmod = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$power = function(a, b) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$reflected_power = function(a, b) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$inplace_power = function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$abs = function() {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$negative = function() {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$positive = function() {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$nonzero = function() {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$isnegative = function() {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.numtype.prototype.nb$ispositive = function() {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
    },
    function(m, p) {
      self.Sk.builtin.biginteger = function(a, b, c) {
        null != a &&
          ("number" == typeof a
            ? this.fromNumber(a, b, c)
            : null == b && "string" != typeof a
            ? this.fromString(a, 256)
            : this.fromString(a, b))
      }
      self.Sk.builtin.biginteger.canary = 0xdeadbeefcafe
      self.Sk.builtin.biginteger.j_lm =
        15715070 == (self.Sk.builtin.biginteger.canary & 16777215)
      self.Sk.builtin.biginteger.nbi = function() {
        return new self.Sk.builtin.biginteger(null)
      }
      self.Sk.builtin.biginteger.prototype.am1 = function(a, b, c, d, e, f) {
        for (var g; 0 <= --f; )
          (g = b * this[a++] + c[d] + e),
            (e = Math.floor(g / 67108864)),
            (c[d++] = g & 67108863)
        return e
      }
      self.Sk.builtin.biginteger.prototype.am2 = function(a, b, c, d, e, f) {
        for (var g, h, k = b & 32767, l = b >> 15; 0 <= --f; )
          (h = this[a] & 32767),
            (g = this[a++] >> 15),
            (b = l * h + g * k),
            (h = k * h + ((b & 32767) << 15) + c[d] + (e & 1073741823)),
            (e = (h >>> 30) + (b >>> 15) + l * g + (e >>> 30)),
            (c[d++] = h & 1073741823)
        return e
      }
      self.Sk.builtin.biginteger.prototype.am3 = function(a, b, c, d, e, f) {
        for (var g, h, k = b & 16383, l = b >> 14; 0 <= --f; )
          (h = this[a] & 16383),
            (g = this[a++] >> 14),
            (b = l * h + g * k),
            (h = k * h + ((b & 16383) << 14) + c[d] + e),
            (e = (h >> 28) + (b >> 14) + l * g),
            (c[d++] = h & 268435455)
        return e
      }
      self.Sk.builtin.biginteger.prototype.am = self.Sk.builtin.biginteger.prototype.am3
      self.Sk.builtin.biginteger.dbits = 28
      self.Sk.builtin.biginteger.prototype.DB = self.Sk.builtin.biginteger.dbits
      self.Sk.builtin.biginteger.prototype.DM =
        (1 << self.Sk.builtin.biginteger.dbits) - 1
      self.Sk.builtin.biginteger.prototype.DV = 1 << self.Sk.builtin.biginteger.dbits
      self.Sk.builtin.biginteger.BI_FP = 52
      self.Sk.builtin.biginteger.prototype.FV = Math.pow(
        2,
        self.Sk.builtin.biginteger.BI_FP,
      )
      self.Sk.builtin.biginteger.prototype.F1 =
        self.Sk.builtin.biginteger.BI_FP - self.Sk.builtin.biginteger.dbits
      self.Sk.builtin.biginteger.prototype.F2 =
        2 * self.Sk.builtin.biginteger.dbits - self.Sk.builtin.biginteger.BI_FP
      self.Sk.builtin.biginteger.BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"
      self.Sk.builtin.biginteger.BI_RC = []
      m = 48
      for (p = 0; 9 >= p; ++p) self.Sk.builtin.biginteger.BI_RC[m++] = p
      m = 97
      for (p = 10; 36 > p; ++p) self.Sk.builtin.biginteger.BI_RC[m++] = p
      m = 65
      for (p = 10; 36 > p; ++p) self.Sk.builtin.biginteger.BI_RC[m++] = p
      self.Sk.builtin.biginteger.int2char = function(a) {
        return self.Sk.builtin.biginteger.BI_RM.charAt(a)
      }
      self.Sk.builtin.biginteger.intAt = function(a, b) {
        a = self.Sk.builtin.biginteger.BI_RC[a.charCodeAt(b)]
        return null == a ? -1 : a
      }
      self.Sk.builtin.biginteger.prototype.bnpCopyTo = function(a) {
        var b
        for (b = this.t - 1; 0 <= b; --b) a[b] = this[b]
        a.t = this.t
        a.s = this.s
      }
      self.Sk.builtin.biginteger.prototype.bnpFromInt = function(a) {
        this.t = 1
        this.s = 0 > a ? -1 : 0
        0 < a ? (this[0] = a) : -1 > a ? (this[0] = a + this.DV) : (this.t = 0)
      }
      self.Sk.builtin.biginteger.nbv = function(a) {
        var b = new self.Sk.builtin.biginteger(null)
        b.bnpFromInt(a)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnpFromString = function(a, b) {
        var c
        if (16 == b) var d = 4
        else if (8 == b) d = 3
        else if (256 == b) d = 8
        else if (2 == b) d = 1
        else if (32 == b) d = 5
        else if (4 == b) d = 2
        else {
          this.fromRadix(a, b)
          return
        }
        this.s = this.t = 0
        var e = a.length
        var f = !1
        for (c = 0; 0 <= --e; )
          (b = 8 == d ? a[e] & 255 : self.Sk.builtin.biginteger.intAt(a, e)),
            0 > b
              ? "-" == a.charAt(e) && (f = !0)
              : ((f = !1),
                0 === c
                  ? (this[this.t++] = b)
                  : c + d > this.DB
                  ? ((this[this.t - 1] |=
                      (b & ((1 << (this.DB - c)) - 1)) << c),
                    (this[this.t++] = b >> (this.DB - c)))
                  : (this[this.t - 1] |= b << c),
                (c += d),
                c >= this.DB && (c -= this.DB))
        8 == d &&
          0 !== (a[0] & 128) &&
          ((this.s = -1),
          0 < c && (this[this.t - 1] |= ((1 << (this.DB - c)) - 1) << c))
        this.clamp()
        f && self.Sk.builtin.biginteger.ZERO.subTo(this, this)
      }
      self.Sk.builtin.biginteger.prototype.bnpClamp = function() {
        for (var a = this.s & this.DM; 0 < this.t && this[this.t - 1] == a; )
          --this.t
      }
      self.Sk.builtin.biginteger.prototype.bnToString = function(a) {
        var b
        if (0 > this.s) return "-" + this.negate().toString(a)
        if (16 == a) var c = 4
        else if (8 == a) c = 3
        else if (2 == a) c = 1
        else if (32 == a) c = 5
        else if (4 == a) c = 2
        else return this.toRadix(a)
        var d = (1 << c) - 1
        var e = !1
        var f = ""
        var g = this.t
        a = this.DB - ((g * this.DB) % c)
        if (0 < g--)
          for (
            a < this.DB &&
            0 < (b = this[g] >> a) &&
            ((e = !0), (f = self.Sk.builtin.biginteger.int2char(b)));
            0 <= g;

          )
            a < c
              ? ((b = (this[g] & ((1 << a) - 1)) << (c - a)),
                (b |= this[--g] >> (a += this.DB - c)))
              : ((b = (this[g] >> (a -= c)) & d),
                0 >= a && ((a += this.DB), --g)),
              0 < b && (e = !0),
              e && (f += self.Sk.builtin.biginteger.int2char(b))
        return e ? f : "0"
      }
      self.Sk.builtin.biginteger.prototype.bnNegate = function() {
        var a = self.Sk.builtin.biginteger.nbi()
        self.Sk.builtin.biginteger.ZERO.subTo(this, a)
        return a
      }
      self.Sk.builtin.biginteger.prototype.bnAbs = function() {
        return 0 > this.s ? this.negate() : this
      }
      self.Sk.builtin.biginteger.prototype.bnCompareTo = function(a) {
        var b = this.s - a.s
        if (0 !== b) return b
        var c = this.t
        b = c - a.t
        if (0 !== b) return 0 > this.s ? -b : b
        for (; 0 <= --c; ) if (0 !== (b = this[c] - a[c])) return b
        return 0
      }
      self.Sk.builtin.biginteger.nbits = function(a) {
        var b = 1,
          c
        0 !== (c = a >>> 16) && ((a = c), (b += 16))
        0 !== (c = a >> 8) && ((a = c), (b += 8))
        0 !== (c = a >> 4) && ((a = c), (b += 4))
        0 !== (c = a >> 2) && ((a = c), (b += 2))
        0 !== a >> 1 && (b += 1)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnBitLength = function() {
        return 0 >= this.t
          ? 0
          : this.DB * (this.t - 1) +
              self.Sk.builtin.biginteger.nbits(this[this.t - 1] ^ (this.s & this.DM))
      }
      self.Sk.builtin.biginteger.prototype.bnpDLShiftTo = function(a, b) {
        var c
        for (c = this.t - 1; 0 <= c; --c) b[c + a] = this[c]
        for (c = a - 1; 0 <= c; --c) b[c] = 0
        b.t = this.t + a
        b.s = this.s
      }
      self.Sk.builtin.biginteger.prototype.bnpDRShiftTo = function(a, b) {
        var c
        for (c = a; c < this.t; ++c) b[c - a] = this[c]
        b.t = Math.max(this.t - a, 0)
        b.s = this.s
      }
      self.Sk.builtin.biginteger.prototype.bnpLShiftTo = function(a, b) {
        var c = a % this.DB,
          d = this.DB - c,
          e = (1 << d) - 1
        a = Math.floor(a / this.DB)
        var f = (this.s << c) & this.DM,
          g
        for (g = this.t - 1; 0 <= g; --g)
          (b[g + a + 1] = (this[g] >> d) | f), (f = (this[g] & e) << c)
        for (g = a - 1; 0 <= g; --g) b[g] = 0
        b[a] = f
        b.t = this.t + a + 1
        b.s = this.s
        b.clamp()
      }
      self.Sk.builtin.biginteger.prototype.bnpRShiftTo = function(a, b) {
        b.s = this.s
        var c = Math.floor(a / this.DB)
        if (c >= this.t) b.t = 0
        else {
          var d = a % this.DB
          var e = this.DB - d
          var f = (1 << d) - 1
          b[0] = this[c] >> d
          for (a = c + 1; a < this.t; ++a)
            (b[a - c - 1] |= (this[a] & f) << e), (b[a - c] = this[a] >> d)
          0 < d && (b[this.t - c - 1] |= (this.s & f) << e)
          b.t = this.t - c
          b.clamp()
        }
      }
      self.Sk.builtin.biginteger.prototype.bnpSubTo = function(a, b) {
        for (var c = 0, d = 0, e = Math.min(a.t, this.t); c < e; )
          (d += this[c] - a[c]), (b[c++] = d & this.DM), (d >>= this.DB)
        if (a.t < this.t) {
          for (d -= a.s; c < this.t; )
            (d += this[c]), (b[c++] = d & this.DM), (d >>= this.DB)
          d += this.s
        } else {
          for (d += this.s; c < a.t; )
            (d -= a[c]), (b[c++] = d & this.DM), (d >>= this.DB)
          d -= a.s
        }
        b.s = 0 > d ? -1 : 0
        ;-1 > d ? (b[c++] = this.DV + d) : 0 < d && (b[c++] = d)
        b.t = c
        b.clamp()
      }
      self.Sk.builtin.biginteger.prototype.bnpMultiplyTo = function(a, b) {
        var c = this.abs(),
          d = a.abs(),
          e = c.t
        for (b.t = e + d.t; 0 <= --e; ) b[e] = 0
        for (e = 0; e < d.t; ++e) b[e + c.t] = c.am(0, d[e], b, e, 0, c.t)
        b.s = 0
        b.clamp()
        this.s != a.s && self.Sk.builtin.biginteger.ZERO.subTo(b, b)
      }
      self.Sk.builtin.biginteger.prototype.bnpSquareTo = function(a) {
        for (var b, c = this.abs(), d = (a.t = 2 * c.t); 0 <= --d; ) a[d] = 0
        for (d = 0; d < c.t - 1; ++d)
          (b = c.am(d, c[d], a, 2 * d, 0, 1)),
            (a[d + c.t] += c.am(
              d + 1,
              2 * c[d],
              a,
              2 * d + 1,
              b,
              c.t - d - 1,
            )) >= c.DV && ((a[d + c.t] -= c.DV), (a[d + c.t + 1] = 1))
        0 < a.t && (a[a.t - 1] += c.am(d, c[d], a, 2 * d, 0, 1))
        a.s = 0
        a.clamp()
      }
      self.Sk.builtin.biginteger.prototype.bnpDivRemTo = function(a, b, c) {
        var d = a.abs()
        if (!(0 >= d.t)) {
          var e = this.abs()
          if (e.t < d.t) null != b && b.fromInt(0), null != c && this.copyTo(c)
          else {
            null == c && (c = self.Sk.builtin.biginteger.nbi())
            var f = self.Sk.builtin.biginteger.nbi()
            var g = this.s
            var h = a.s
            a = this.DB - self.Sk.builtin.biginteger.nbits(d[d.t - 1])
            0 < a
              ? (d.lShiftTo(a, f), e.lShiftTo(a, c))
              : (d.copyTo(f), e.copyTo(c))
            var k = f.t
            d = f[k - 1]
            if (0 !== d) {
              var l = d * (1 << this.F1) + (1 < k ? f[k - 2] >> this.F2 : 0)
              e = this.FV / l
              var r = (1 << this.F1) / l
              var n = 1 << this.F2
              var q = c.t
              var m = q - k
              var p = null == b ? self.Sk.builtin.biginteger.nbi() : b
              f.dlShiftTo(m, p)
              0 <= c.compareTo(p) && ((c[c.t++] = 1), c.subTo(p, c))
              self.Sk.builtin.biginteger.ONE.dlShiftTo(k, p)
              for (p.subTo(f, f); f.t < k; ) f[f.t++] = 0
              for (; 0 <= --m; )
                if (
                  ((l =
                    c[--q] == d
                      ? this.DM
                      : Math.floor(c[q] * e + (c[q - 1] + n) * r)),
                  (c[q] += f.am(0, l, c, m, 0, k)) < l)
                )
                  for (f.dlShiftTo(m, p), c.subTo(p, c); c[q] < --l; )
                    c.subTo(p, c)
              null != b &&
                (c.drShiftTo(k, b),
                g != h && self.Sk.builtin.biginteger.ZERO.subTo(b, b))
              c.t = k
              c.clamp()
              0 < a && c.rShiftTo(a, c)
              0 > g && self.Sk.builtin.biginteger.ZERO.subTo(c, c)
            }
          }
        }
      }
      self.Sk.builtin.biginteger.prototype.bnMod = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.abs().divRemTo(a, null, b)
        0 > this.s &&
          0 < b.compareTo(self.Sk.builtin.biginteger.ZERO) &&
          a.subTo(b, b)
        return b
      }
      self.Sk.builtin.biginteger.Classic = function(a) {
        this.m = a
      }
      self.Sk.builtin.biginteger.prototype.cConvert = function(a) {
        return 0 > a.s || 0 <= a.compareTo(this.m) ? a.mod(this.m) : a
      }
      self.Sk.builtin.biginteger.prototype.cRevert = function(a) {
        return a
      }
      self.Sk.builtin.biginteger.prototype.cReduce = function(a) {
        a.divRemTo(this.m, null, a)
      }
      self.Sk.builtin.biginteger.prototype.cMulTo = function(a, b, c) {
        a.multiplyTo(b, c)
        this.reduce(c)
      }
      self.Sk.builtin.biginteger.prototype.cSqrTo = function(a, b) {
        a.squareTo(b)
        this.reduce(b)
      }
      self.Sk.builtin.biginteger.Classic.prototype.convert =
        self.Sk.builtin.biginteger.prototype.cConvert
      self.Sk.builtin.biginteger.Classic.prototype.revert =
        self.Sk.builtin.biginteger.prototype.cRevert
      self.Sk.builtin.biginteger.Classic.prototype.reduce =
        self.Sk.builtin.biginteger.prototype.cReduce
      self.Sk.builtin.biginteger.Classic.prototype.mulTo =
        self.Sk.builtin.biginteger.prototype.cMulTo
      self.Sk.builtin.biginteger.Classic.prototype.sqrTo =
        self.Sk.builtin.biginteger.prototype.cSqrTo
      self.Sk.builtin.biginteger.prototype.bnpInvDigit = function() {
        if (1 > this.t) return 0
        var a = this[0]
        if (0 === (a & 1)) return 0
        var b = a & 3
        b = (b * (2 - (a & 15) * b)) & 15
        b = (b * (2 - (a & 255) * b)) & 255
        b = (b * (2 - (((a & 65535) * b) & 65535))) & 65535
        b = (b * (2 - ((a * b) % this.DV))) % this.DV
        return 0 < b ? this.DV - b : -b
      }
      self.Sk.builtin.biginteger.Montgomery = function(a) {
        this.m = a
        this.mp = a.invDigit()
        this.mpl = this.mp & 32767
        this.mph = this.mp >> 15
        this.um = (1 << (a.DB - 15)) - 1
        this.mt2 = 2 * a.t
      }
      self.Sk.builtin.biginteger.prototype.montConvert = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        a.abs().dlShiftTo(this.m.t, b)
        b.divRemTo(this.m, null, b)
        0 > a.s &&
          0 < b.compareTo(self.Sk.builtin.biginteger.ZERO) &&
          this.m.subTo(b, b)
        return b
      }
      self.Sk.builtin.biginteger.prototype.montRevert = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        a.copyTo(b)
        this.reduce(b)
        return b
      }
      self.Sk.builtin.biginteger.prototype.montReduce = function(a) {
        for (var b, c, d; a.t <= this.mt2; ) a[a.t++] = 0
        for (d = 0; d < this.m.t; ++d)
          for (
            c = a[d] & 32767,
              b =
                (c * this.mpl +
                  (((c * this.mph + (a[d] >> 15) * this.mpl) & this.um) <<
                    15)) &
                a.DM,
              c = d + this.m.t,
              a[c] += this.m.am(0, b, a, d, 0, this.m.t);
            a[c] >= a.DV;

          )
            (a[c] -= a.DV), a[++c]++
        a.clamp()
        a.drShiftTo(this.m.t, a)
        0 <= a.compareTo(this.m) && a.subTo(this.m, a)
      }
      self.Sk.builtin.biginteger.prototype.montSqrTo = function(a, b) {
        a.squareTo(b)
        this.reduce(b)
      }
      self.Sk.builtin.biginteger.prototype.montMulTo = function(a, b, c) {
        a.multiplyTo(b, c)
        this.reduce(c)
      }
      self.Sk.builtin.biginteger.Montgomery.prototype.convert =
        self.Sk.builtin.biginteger.prototype.montConvert
      self.Sk.builtin.biginteger.Montgomery.prototype.revert =
        self.Sk.builtin.biginteger.prototype.montRevert
      self.Sk.builtin.biginteger.Montgomery.prototype.reduce =
        self.Sk.builtin.biginteger.prototype.montReduce
      self.Sk.builtin.biginteger.Montgomery.prototype.mulTo =
        self.Sk.builtin.biginteger.prototype.montMulTo
      self.Sk.builtin.biginteger.Montgomery.prototype.sqrTo =
        self.Sk.builtin.biginteger.prototype.montSqrTo
      self.Sk.builtin.biginteger.prototype.bnpIsEven = function() {
        return 0 === (0 < this.t ? this[0] & 1 : this.s)
      }
      self.Sk.builtin.biginteger.prototype.bnpExp = function(a, b) {
        if (4294967295 < a || 1 > a) return self.Sk.builtin.biginteger.ONE
        var c = self.Sk.builtin.biginteger.nbi()
        var d = self.Sk.builtin.biginteger.nbi()
        var e = b.convert(this)
        var f = self.Sk.builtin.biginteger.nbits(a) - 1
        for (e.copyTo(c); 0 <= --f; )
          if ((b.sqrTo(c, d), 0 < (a & (1 << f)))) b.mulTo(d, e, c)
          else {
            var g = c
            c = d
            d = g
          }
        return b.revert(c)
      }
      self.Sk.builtin.biginteger.prototype.bnModPowInt = function(a, b) {
        b =
          256 > a || b.isEven()
            ? new self.Sk.builtin.biginteger.Classic(b)
            : new self.Sk.builtin.biginteger.Montgomery(b)
        return this.exp(a, b)
      }
      self.Sk.builtin.biginteger.prototype.copyTo =
        self.Sk.builtin.biginteger.prototype.bnpCopyTo
      self.Sk.builtin.biginteger.prototype.fromInt =
        self.Sk.builtin.biginteger.prototype.bnpFromInt
      self.Sk.builtin.biginteger.prototype.fromString =
        self.Sk.builtin.biginteger.prototype.bnpFromString
      self.Sk.builtin.biginteger.prototype.clamp =
        self.Sk.builtin.biginteger.prototype.bnpClamp
      self.Sk.builtin.biginteger.prototype.dlShiftTo =
        self.Sk.builtin.biginteger.prototype.bnpDLShiftTo
      self.Sk.builtin.biginteger.prototype.drShiftTo =
        self.Sk.builtin.biginteger.prototype.bnpDRShiftTo
      self.Sk.builtin.biginteger.prototype.lShiftTo =
        self.Sk.builtin.biginteger.prototype.bnpLShiftTo
      self.Sk.builtin.biginteger.prototype.rShiftTo =
        self.Sk.builtin.biginteger.prototype.bnpRShiftTo
      self.Sk.builtin.biginteger.prototype.subTo =
        self.Sk.builtin.biginteger.prototype.bnpSubTo
      self.Sk.builtin.biginteger.prototype.multiplyTo =
        self.Sk.builtin.biginteger.prototype.bnpMultiplyTo
      self.Sk.builtin.biginteger.prototype.squareTo =
        self.Sk.builtin.biginteger.prototype.bnpSquareTo
      self.Sk.builtin.biginteger.prototype.divRemTo =
        self.Sk.builtin.biginteger.prototype.bnpDivRemTo
      self.Sk.builtin.biginteger.prototype.invDigit =
        self.Sk.builtin.biginteger.prototype.bnpInvDigit
      self.Sk.builtin.biginteger.prototype.isEven =
        self.Sk.builtin.biginteger.prototype.bnpIsEven
      self.Sk.builtin.biginteger.prototype.exp =
        self.Sk.builtin.biginteger.prototype.bnpExp
      self.Sk.builtin.biginteger.prototype.toString =
        self.Sk.builtin.biginteger.prototype.bnToString
      self.Sk.builtin.biginteger.prototype.negate =
        self.Sk.builtin.biginteger.prototype.bnNegate
      self.Sk.builtin.biginteger.prototype.abs =
        self.Sk.builtin.biginteger.prototype.bnAbs
      self.Sk.builtin.biginteger.prototype.compareTo =
        self.Sk.builtin.biginteger.prototype.bnCompareTo
      self.Sk.builtin.biginteger.prototype.bitLength =
        self.Sk.builtin.biginteger.prototype.bnBitLength
      self.Sk.builtin.biginteger.prototype.mod =
        self.Sk.builtin.biginteger.prototype.bnMod
      self.Sk.builtin.biginteger.prototype.modPowInt =
        self.Sk.builtin.biginteger.prototype.bnModPowInt
      self.Sk.builtin.biginteger.ZERO = self.Sk.builtin.biginteger.nbv(0)
      self.Sk.builtin.biginteger.ONE = self.Sk.builtin.biginteger.nbv(1)
      self.Sk.builtin.biginteger.prototype.bnClone = function() {
        var a = self.Sk.builtin.biginteger.nbi()
        this.copyTo(a)
        return a
      }
      self.Sk.builtin.biginteger.prototype.bnIntValue = function() {
        if (0 > this.s) {
          if (1 == this.t) return this[0] - this.DV
          if (0 === this.t) return -1
        } else {
          if (1 == this.t) return this[0]
          if (0 === this.t) return 0
        }
        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0]
      }
      self.Sk.builtin.biginteger.prototype.bnByteValue = function() {
        return 0 === this.t ? this.s : (this[0] << 24) >> 24
      }
      self.Sk.builtin.biginteger.prototype.bnShortValue = function() {
        return 0 === this.t ? this.s : (this[0] << 16) >> 16
      }
      self.Sk.builtin.biginteger.prototype.bnpChunkSize = function(a) {
        return Math.floor((Math.LN2 * this.DB) / Math.log(a))
      }
      self.Sk.builtin.biginteger.prototype.bnSigNum = function() {
        return 0 > this.s
          ? -1
          : 0 >= this.t || (1 == this.t && 0 >= this[0])
          ? 0
          : 1
      }
      self.Sk.builtin.biginteger.prototype.bnpToRadix = function(a) {
        null == a && (a = 10)
        if (0 === this.signum() || 2 > a || 36 < a) return "0"
        var b = this.chunkSize(a)
        var c = Math.pow(a, b)
        b = self.Sk.builtin.biginteger.nbv(c)
        var d = self.Sk.builtin.biginteger.nbi()
        var e = self.Sk.builtin.biginteger.nbi()
        var f = ""
        for (this.divRemTo(b, d, e); 0 < d.signum(); )
          (f = (c + e.intValue()).toString(a).substr(1) + f),
            d.divRemTo(b, d, e)
        return e.intValue().toString(a) + f
      }
      self.Sk.builtin.biginteger.prototype.bnpFromRadix = function(a, b) {
        var c, d, e
        this.fromInt(0)
        null == b && (b = 10)
        var f = this.chunkSize(b)
        var g = Math.pow(b, f)
        var h = !1
        for (c = e = d = 0; c < a.length; ++c) {
          var k = self.Sk.builtin.biginteger.intAt(a, c)
          if (0 > k) {
            if (
              ("-" == a.charAt(c) && 0 === this.signum() && (h = !0),
              "." == a.charAt(c))
            )
              break
          } else
            (e = b * e + k),
              ++d >= f &&
                (this.dMultiply(g), this.dAddOffset(e, 0), (e = d = 0))
        }
        0 < d && (this.dMultiply(Math.pow(b, d)), this.dAddOffset(e, 0))
        h && self.Sk.builtin.biginteger.ZERO.subTo(this, this)
      }
      self.Sk.builtin.biginteger.prototype.bnpFromNumber = function(a, b, c) {
        if ("number" == typeof b)
          if (2 > a) this.fromInt(1)
          else
            for (
              this.fromNumber(a, c),
                this.testBit(a - 1) ||
                  this.bitwiseTo(
                    self.Sk.builtin.biginteger.ONE.shiftLeft(a - 1),
                    self.Sk.builtin.biginteger.op_or,
                    this,
                  ),
                this.isEven() && this.dAddOffset(1, 0);
              !this.isProbablePrime(b);

            )
              this.dAddOffset(2, 0),
                this.bitLength() > a &&
                  this.subTo(self.Sk.builtin.biginteger.ONE.shiftLeft(a - 1), this)
        this.fromString(a + "")
      }
      self.Sk.builtin.biginteger.prototype.bnToByteArray = function() {
        var a,
          b = this.t,
          c = []
        c[0] = this.s
        var d = this.DB - ((b * this.DB) % 8)
        var e = 0
        if (0 < b--)
          for (
            d < this.DB &&
            (a = this[b] >> d) != (this.s & this.DM) >> d &&
            (c[e++] = a | (this.s << (this.DB - d)));
            0 <= b;

          )
            if (
              (8 > d
                ? ((a = (this[b] & ((1 << d) - 1)) << (8 - d)),
                  (a |= this[--b] >> (d += this.DB - 8)))
                : ((a = (this[b] >> (d -= 8)) & 255),
                  0 >= d && ((d += this.DB), --b)),
              0 !== (a & 128) && (a |= -256),
              0 === e && (this.s & 128) != (a & 128) && ++e,
              0 < e || a != this.s)
            )
              c[e++] = a
        return c
      }
      self.Sk.builtin.biginteger.prototype.bnEquals = function(a) {
        return 0 === this.compareTo(a)
      }
      self.Sk.builtin.biginteger.prototype.bnMin = function(a) {
        return 0 > this.compareTo(a) ? this : a
      }
      self.Sk.builtin.biginteger.prototype.bnMax = function(a) {
        return 0 < this.compareTo(a) ? this : a
      }
      self.Sk.builtin.biginteger.prototype.bnpBitwiseTo = function(a, b, c) {
        var d,
          e = Math.min(a.t, this.t)
        for (d = 0; d < e; ++d) c[d] = b(this[d], a[d])
        if (a.t < this.t) {
          var f = a.s & this.DM
          for (d = e; d < this.t; ++d) c[d] = b(this[d], f)
          c.t = this.t
        } else {
          f = this.s & this.DM
          for (d = e; d < a.t; ++d) c[d] = b(f, a[d])
          c.t = a.t
        }
        c.s = b(this.s, a.s)
        c.clamp()
      }
      self.Sk.builtin.biginteger.op_and = function(a, b) {
        return a & b
      }
      self.Sk.builtin.biginteger.prototype.bnAnd = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.bitwiseTo(a, self.Sk.builtin.biginteger.op_and, b)
        return b
      }
      self.Sk.builtin.biginteger.op_or = function(a, b) {
        return a | b
      }
      self.Sk.builtin.biginteger.prototype.bnOr = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.bitwiseTo(a, self.Sk.builtin.biginteger.op_or, b)
        return b
      }
      self.Sk.builtin.biginteger.op_xor = function(a, b) {
        return a ^ b
      }
      self.Sk.builtin.biginteger.prototype.bnXor = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.bitwiseTo(a, self.Sk.builtin.biginteger.op_xor, b)
        return b
      }
      self.Sk.builtin.biginteger.op_andnot = function(a, b) {
        return a & ~b
      }
      self.Sk.builtin.biginteger.prototype.bnAndNot = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.bitwiseTo(a, self.Sk.builtin.biginteger.op_andnot, b)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnNot = function() {
        var a,
          b = self.Sk.builtin.biginteger.nbi()
        for (a = 0; a < this.t; ++a) b[a] = this.DM & ~this[a]
        b.t = this.t
        b.s = ~this.s
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnShiftLeft = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        0 > a ? this.rShiftTo(-a, b) : this.lShiftTo(a, b)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnShiftRight = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        0 > a ? this.lShiftTo(-a, b) : this.rShiftTo(a, b)
        return b
      }
      self.Sk.builtin.biginteger.lbit = function(a) {
        if (0 === a) return -1
        var b = 0
        0 === (a & 65535) && ((a >>= 16), (b += 16))
        0 === (a & 255) && ((a >>= 8), (b += 8))
        0 === (a & 15) && ((a >>= 4), (b += 4))
        0 === (a & 3) && ((a >>= 2), (b += 2))
        0 === (a & 1) && ++b
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnGetLowestSetBit = function() {
        var a
        for (a = 0; a < this.t; ++a)
          if (0 !== this[a])
            return a * this.DB + self.Sk.builtin.biginteger.lbit(this[a])
        return 0 > this.s ? this.t * this.DB : -1
      }
      self.Sk.builtin.biginteger.cbit = function(a) {
        for (var b = 0; 0 !== a; ) (a &= a - 1), ++b
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnBitCount = function() {
        var a,
          b = 0,
          c = this.s & this.DM
        for (a = 0; a < this.t; ++a)
          b += self.Sk.builtin.biginteger.cbit(this[a] ^ c)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnTestBit = function(a) {
        var b = Math.floor(a / this.DB)
        return b >= this.t ? 0 !== this.s : 0 !== (this[b] & (1 << a % this.DB))
      }
      self.Sk.builtin.biginteger.prototype.bnpChangeBit = function(a, b) {
        a = self.Sk.builtin.biginteger.ONE.shiftLeft(a)
        this.bitwiseTo(a, b, a)
        return a
      }
      self.Sk.builtin.biginteger.prototype.bnSetBit = function(a) {
        return this.changeBit(a, self.Sk.builtin.biginteger.op_or)
      }
      self.Sk.builtin.biginteger.prototype.bnClearBit = function(a) {
        return this.changeBit(a, self.Sk.builtin.biginteger.op_andnot)
      }
      self.Sk.builtin.biginteger.prototype.bnFlipBit = function(a) {
        return this.changeBit(a, self.Sk.builtin.biginteger.op_xor)
      }
      self.Sk.builtin.biginteger.prototype.bnpAddTo = function(a, b) {
        for (var c = 0, d = 0, e = Math.min(a.t, this.t); c < e; )
          (d += this[c] + a[c]), (b[c++] = d & this.DM), (d >>= this.DB)
        if (a.t < this.t) {
          for (d += a.s; c < this.t; )
            (d += this[c]), (b[c++] = d & this.DM), (d >>= this.DB)
          d += this.s
        } else {
          for (d += this.s; c < a.t; )
            (d += a[c]), (b[c++] = d & this.DM), (d >>= this.DB)
          d += a.s
        }
        b.s = 0 > d ? -1 : 0
        0 < d ? (b[c++] = d) : -1 > d && (b[c++] = this.DV + d)
        b.t = c
        b.clamp()
      }
      self.Sk.builtin.biginteger.prototype.bnAdd = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.addTo(a, b)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnSubtract = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.subTo(a, b)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnMultiply = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.multiplyTo(a, b)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnDivide = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.divRemTo(a, b, null)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnRemainder = function(a) {
        var b = self.Sk.builtin.biginteger.nbi()
        this.divRemTo(a, null, b)
        return b
      }
      self.Sk.builtin.biginteger.prototype.bnDivideAndRemainder = function(a) {
        var b = self.Sk.builtin.biginteger.nbi(),
          c = self.Sk.builtin.biginteger.nbi()
        this.divRemTo(a, b, c)
        return [b, c]
      }
      self.Sk.builtin.biginteger.prototype.bnpDMultiply = function(a) {
        this[this.t] = this.am(0, a - 1, this, 0, 0, this.t)
        ++this.t
        this.clamp()
      }
      self.Sk.builtin.biginteger.prototype.bnpDAddOffset = function(a, b) {
        if (0 !== a) {
          for (; this.t <= b; ) this[this.t++] = 0
          for (this[b] += a; this[b] >= this.DV; )
            (this[b] -= this.DV),
              ++b >= this.t && (this[this.t++] = 0),
              ++this[b]
        }
      }
      self.Sk.builtin.biginteger.NullExp = function() {}
      self.Sk.builtin.biginteger.prototype.nNop = function(a) {
        return a
      }
      self.Sk.builtin.biginteger.prototype.nMulTo = function(a, b, c) {
        a.multiplyTo(b, c)
      }
      self.Sk.builtin.biginteger.prototype.nSqrTo = function(a, b) {
        a.squareTo(b)
      }
      self.Sk.builtin.biginteger.NullExp.prototype.convert =
        self.Sk.builtin.biginteger.prototype.nNop
      self.Sk.builtin.biginteger.NullExp.prototype.revert =
        self.Sk.builtin.biginteger.prototype.nNop
      self.Sk.builtin.biginteger.NullExp.prototype.mulTo =
        self.Sk.builtin.biginteger.prototype.nMulTo
      self.Sk.builtin.biginteger.NullExp.prototype.sqrTo =
        self.Sk.builtin.biginteger.prototype.nSqrTo
      self.Sk.builtin.biginteger.prototype.bnPow = function(a) {
        return this.exp(a, new self.Sk.builtin.biginteger.NullExp())
      }
      self.Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo = function(a, b, c) {
        var d,
          e = Math.min(this.t + a.t, b)
        c.s = 0
        for (c.t = e; 0 < e; ) c[--e] = 0
        for (d = c.t - this.t; e < d; ++e)
          c[e + this.t] = this.am(0, a[e], c, e, 0, this.t)
        for (d = Math.min(a.t, b); e < d; ++e) this.am(0, a[e], c, e, 0, b - e)
        c.clamp()
      }
      self.Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo = function(a, b, c) {
        --b
        var d = (c.t = this.t + a.t - b)
        for (c.s = 0; 0 <= --d; ) c[d] = 0
        for (d = Math.max(b - this.t, 0); d < a.t; ++d)
          c[this.t + d - b] = this.am(b - d, a[d], c, 0, 0, this.t + d - b)
        c.clamp()
        c.drShiftTo(1, c)
      }
      self.Sk.builtin.biginteger.Barrett = function(a) {
        this.r2 = self.Sk.builtin.biginteger.nbi()
        this.q3 = self.Sk.builtin.biginteger.nbi()
        self.Sk.builtin.biginteger.ONE.dlShiftTo(2 * a.t, this.r2)
        this.mu = this.r2.divide(a)
        this.m = a
      }
      self.Sk.builtin.biginteger.prototype.barrettConvert = function(a) {
        if (0 > a.s || a.t > 2 * this.m.t) return a.mod(this.m)
        if (0 > a.compareTo(this.m)) return a
        var b = self.Sk.builtin.biginteger.nbi()
        a.copyTo(b)
        this.reduce(b)
        return b
      }
      self.Sk.builtin.biginteger.prototype.barrettRevert = function(a) {
        return a
      }
      self.Sk.builtin.biginteger.prototype.barrettReduce = function(a) {
        a.drShiftTo(this.m.t - 1, this.r2)
        a.t > this.m.t + 1 && ((a.t = this.m.t + 1), a.clamp())
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3)
        for (
          this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
          0 > a.compareTo(this.r2);

        )
          a.dAddOffset(1, this.m.t + 1)
        for (a.subTo(this.r2, a); 0 <= a.compareTo(this.m); ) a.subTo(this.m, a)
      }
      self.Sk.builtin.biginteger.prototype.barrettSqrTo = function(a, b) {
        a.squareTo(b)
        this.reduce(b)
      }
      self.Sk.builtin.biginteger.prototype.barrettMulTo = function(a, b, c) {
        a.multiplyTo(b, c)
        this.reduce(c)
      }
      self.Sk.builtin.biginteger.Barrett.prototype.convert =
        self.Sk.builtin.biginteger.prototype.barrettConvert
      self.Sk.builtin.biginteger.Barrett.prototype.revert =
        self.Sk.builtin.biginteger.prototype.barrettRevert
      self.Sk.builtin.biginteger.Barrett.prototype.reduce =
        self.Sk.builtin.biginteger.prototype.barrettReduce
      self.Sk.builtin.biginteger.Barrett.prototype.mulTo =
        self.Sk.builtin.biginteger.prototype.barrettMulTo
      self.Sk.builtin.biginteger.Barrett.prototype.sqrTo =
        self.Sk.builtin.biginteger.prototype.barrettSqrTo
      self.Sk.builtin.biginteger.prototype.bnModPow = function(a, b) {
        var c = a.bitLength()
        var d = self.Sk.builtin.biginteger.nbv(1)
        if (0 >= c) return d
        var e = 18 > c ? 1 : 48 > c ? 3 : 144 > c ? 4 : 768 > c ? 5 : 6
        var f =
          8 > c
            ? new self.Sk.builtin.biginteger.Classic(b)
            : b.isEven()
            ? new self.Sk.builtin.biginteger.Barrett(b)
            : new self.Sk.builtin.biginteger.Montgomery(b)
        b = []
        var g = 3
        var h = e - 1
        var k = (1 << e) - 1
        b[1] = f.convert(this)
        if (1 < e)
          for (c = self.Sk.builtin.biginteger.nbi(), f.sqrTo(b[1], c); g <= k; )
            (b[g] = self.Sk.builtin.biginteger.nbi()),
              f.mulTo(c, b[g - 2], b[g]),
              (g += 2)
        var l = a.t - 1
        var r = !0
        var n = self.Sk.builtin.biginteger.nbi()
        for (c = self.Sk.builtin.biginteger.nbits(a[l]) - 1; 0 <= l; ) {
          if (c >= h) var q = (a[l] >> (c - h)) & k
          else
            (q = (a[l] & ((1 << (c + 1)) - 1)) << (h - c)),
              0 < l && (q |= a[l - 1] >> (this.DB + c - h))
          for (g = e; 0 === (q & 1); ) (q >>= 1), --g
          0 > (c -= g) && ((c += this.DB), --l)
          if (r) b[q].copyTo(d), (r = !1)
          else {
            for (; 1 < g; ) f.sqrTo(d, n), f.sqrTo(n, d), (g -= 2)
            0 < g ? f.sqrTo(d, n) : ((g = d), (d = n), (n = g))
            f.mulTo(n, b[q], d)
          }
          for (; 0 <= l && 0 === (a[l] & (1 << c)); )
            f.sqrTo(d, n),
              (g = d),
              (d = n),
              (n = g),
              0 > --c && ((c = this.DB - 1), --l)
        }
        return f.revert(d)
      }
      self.Sk.builtin.biginteger.prototype.bnGCD = function(a) {
        var b = 0 > this.s ? this.negate() : this.clone()
        a = 0 > a.s ? a.negate() : a.clone()
        if (0 > b.compareTo(a)) {
          var c = b
          b = a
          a = c
        }
        c = b.getLowestSetBit()
        var d = a.getLowestSetBit()
        if (0 > d) return b
        c < d && (d = c)
        0 < d && (b.rShiftTo(d, b), a.rShiftTo(d, a))
        for (; 0 < b.signum(); )
          0 < (c = b.getLowestSetBit()) && b.rShiftTo(c, b),
            0 < (c = a.getLowestSetBit()) && a.rShiftTo(c, a),
            0 <= b.compareTo(a)
              ? (b.subTo(a, b), b.rShiftTo(1, b))
              : (a.subTo(b, a), a.rShiftTo(1, a))
        0 < d && a.lShiftTo(d, a)
        return a
      }
      self.Sk.builtin.biginteger.prototype.bnpModInt = function(a) {
        var b
        if (0 >= a) return 0
        var c = this.DV % a
        var d = 0 > this.s ? a - 1 : 0
        if (0 < this.t)
          if (0 === c) d = this[0] % a
          else for (b = this.t - 1; 0 <= b; --b) d = (c * d + this[b]) % a
        return d
      }
      self.Sk.builtin.biginteger.prototype.bnModInverse = function(a) {
        var b,
          c = a.isEven()
        if ((this.isEven() && c) || 0 === a.signum())
          return self.Sk.builtin.biginteger.ZERO
        var d = a.clone()
        var e = this.clone()
        var f = self.Sk.builtin.biginteger.nbv(1)
        var g = self.Sk.builtin.biginteger.nbv(0)
        var h = self.Sk.builtin.biginteger.nbv(0)
        for (b = self.Sk.builtin.biginteger.nbv(1); 0 !== d.signum(); ) {
          for (; d.isEven(); )
            d.rShiftTo(1, d),
              c
                ? ((f.isEven() && g.isEven()) ||
                    (f.addTo(this, f), g.subTo(a, g)),
                  f.rShiftTo(1, f))
                : g.isEven() || g.subTo(a, g),
              g.rShiftTo(1, g)
          for (; e.isEven(); )
            e.rShiftTo(1, e),
              c
                ? ((h.isEven() && b.isEven()) ||
                    (h.addTo(this, h), b.subTo(a, b)),
                  h.rShiftTo(1, h))
                : b.isEven() || b.subTo(a, b),
              b.rShiftTo(1, b)
          0 <= d.compareTo(e)
            ? (d.subTo(e, d), c && f.subTo(h, f), g.subTo(b, g))
            : (e.subTo(d, e), c && h.subTo(f, h), b.subTo(g, b))
        }
        if (0 !== e.compareTo(self.Sk.builtin.biginteger.ONE))
          return self.Sk.builtin.biginteger.ZERO
        if (0 <= b.compareTo(a)) return b.subtract(a)
        if (0 > b.signum()) b.addTo(a, b)
        else return b
        return 0 > b.signum() ? b.add(a) : b
      }
      self.Sk.builtin.biginteger.lowprimes = [
        2,
        3,
        5,
        7,
        11,
        13,
        17,
        19,
        23,
        29,
        31,
        37,
        41,
        43,
        47,
        53,
        59,
        61,
        67,
        71,
        73,
        79,
        83,
        89,
        97,
        101,
        103,
        107,
        109,
        113,
        127,
        131,
        137,
        139,
        149,
        151,
        157,
        163,
        167,
        173,
        179,
        181,
        191,
        193,
        197,
        199,
        211,
        223,
        227,
        229,
        233,
        239,
        241,
        251,
        257,
        263,
        269,
        271,
        277,
        281,
        283,
        293,
        307,
        311,
        313,
        317,
        331,
        337,
        347,
        349,
        353,
        359,
        367,
        373,
        379,
        383,
        389,
        397,
        401,
        409,
        419,
        421,
        431,
        433,
        439,
        443,
        449,
        457,
        461,
        463,
        467,
        479,
        487,
        491,
        499,
        503,
        509,
      ]
      self.Sk.builtin.biginteger.lplim =
        67108864 /
        self.Sk.builtin.biginteger.lowprimes[
          self.Sk.builtin.biginteger.lowprimes.length - 1
        ]
      self.Sk.builtin.biginteger.prototype.bnIsProbablePrime = function(a) {
        var b,
          c,
          d = this.abs()
        if (
          1 == d.t &&
          d[0] <=
            self.Sk.builtin.biginteger.lowprimes[
              self.Sk.builtin.biginteger.lowprimes.length - 1
            ]
        ) {
          for (c = 0; c < self.Sk.builtin.biginteger.lowprimes.length; ++c)
            if (d[0] == self.Sk.builtin.biginteger.lowprimes[c]) return !0
          return !1
        }
        if (d.isEven()) return !1
        for (c = 1; c < self.Sk.builtin.biginteger.lowprimes.length; ) {
          var e = self.Sk.builtin.biginteger.lowprimes[c]
          for (
            b = c + 1;
            b < self.Sk.builtin.biginteger.lowprimes.length &&
            e < self.Sk.builtin.biginteger.lplim;

          )
            e *= self.Sk.builtin.biginteger.lowprimes[b++]
          for (e = d.modInt(e); c < b; )
            if (0 === e % self.Sk.builtin.biginteger.lowprimes[c++]) return !1
        }
        return d.millerRabin(a)
      }
      self.Sk.builtin.biginteger.prototype.bnpMillerRabin = function(a) {
        var b,
          c,
          d = this.subtract(self.Sk.builtin.biginteger.ONE),
          e = d.getLowestSetBit()
        if (0 >= e) return !1
        var f = d.shiftRight(e)
        a = (a + 1) >> 1
        a > self.Sk.builtin.biginteger.lowprimes.length &&
          (a = self.Sk.builtin.biginteger.lowprimes.length)
        var g = self.Sk.builtin.biginteger.nbi()
        for (c = 0; c < a; ++c) {
          g.fromInt(self.Sk.builtin.biginteger.lowprimes[c])
          var h = g.modPow(f, this)
          if (
            0 !== h.compareTo(self.Sk.builtin.biginteger.ONE) &&
            0 !== h.compareTo(d)
          ) {
            for (b = 1; b++ < e && 0 !== h.compareTo(d); )
              if (
                ((h = h.modPowInt(2, this)),
                0 === h.compareTo(self.Sk.builtin.biginteger.ONE))
              )
                return !1
            if (0 !== h.compareTo(d)) return !1
          }
        }
        return !0
      }
      self.Sk.builtin.biginteger.prototype.isnegative = function() {
        return 0 > this.s
      }
      self.Sk.builtin.biginteger.prototype.ispositive = function() {
        return 0 <= this.s
      }
      self.Sk.builtin.biginteger.prototype.trueCompare = function(a) {
        return 0 <= this.s && 0 > a.s
          ? 1
          : 0 > this.s && 0 <= a.s
          ? -1
          : this.compare(a)
      }
      self.Sk.builtin.biginteger.prototype.chunkSize =
        self.Sk.builtin.biginteger.prototype.bnpChunkSize
      self.Sk.builtin.biginteger.prototype.toRadix =
        self.Sk.builtin.biginteger.prototype.bnpToRadix
      self.Sk.builtin.biginteger.prototype.fromRadix =
        self.Sk.builtin.biginteger.prototype.bnpFromRadix
      self.Sk.builtin.biginteger.prototype.fromNumber =
        self.Sk.builtin.biginteger.prototype.bnpFromNumber
      self.Sk.builtin.biginteger.prototype.bitwiseTo =
        self.Sk.builtin.biginteger.prototype.bnpBitwiseTo
      self.Sk.builtin.biginteger.prototype.changeBit =
        self.Sk.builtin.biginteger.prototype.bnpChangeBit
      self.Sk.builtin.biginteger.prototype.addTo =
        self.Sk.builtin.biginteger.prototype.bnpAddTo
      self.Sk.builtin.biginteger.prototype.dMultiply =
        self.Sk.builtin.biginteger.prototype.bnpDMultiply
      self.Sk.builtin.biginteger.prototype.dAddOffset =
        self.Sk.builtin.biginteger.prototype.bnpDAddOffset
      self.Sk.builtin.biginteger.prototype.multiplyLowerTo =
        self.Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo
      self.Sk.builtin.biginteger.prototype.multiplyUpperTo =
        self.Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo
      self.Sk.builtin.biginteger.prototype.modInt =
        self.Sk.builtin.biginteger.prototype.bnpModInt
      self.Sk.builtin.biginteger.prototype.millerRabin =
        self.Sk.builtin.biginteger.prototype.bnpMillerRabin
      self.Sk.builtin.biginteger.prototype.clone =
        self.Sk.builtin.biginteger.prototype.bnClone
      self.Sk.builtin.biginteger.prototype.intValue =
        self.Sk.builtin.biginteger.prototype.bnIntValue
      self.Sk.builtin.biginteger.prototype.byteValue =
        self.Sk.builtin.biginteger.prototype.bnByteValue
      self.Sk.builtin.biginteger.prototype.shortValue =
        self.Sk.builtin.biginteger.prototype.bnShortValue
      self.Sk.builtin.biginteger.prototype.signum =
        self.Sk.builtin.biginteger.prototype.bnSigNum
      self.Sk.builtin.biginteger.prototype.toByteArray =
        self.Sk.builtin.biginteger.prototype.bnToByteArray
      self.Sk.builtin.biginteger.prototype.equals =
        self.Sk.builtin.biginteger.prototype.bnEquals
      self.Sk.builtin.biginteger.prototype.compare =
        self.Sk.builtin.biginteger.prototype.compareTo
      self.Sk.builtin.biginteger.prototype.min =
        self.Sk.builtin.biginteger.prototype.bnMin
      self.Sk.builtin.biginteger.prototype.max =
        self.Sk.builtin.biginteger.prototype.bnMax
      self.Sk.builtin.biginteger.prototype.and =
        self.Sk.builtin.biginteger.prototype.bnAnd
      self.Sk.builtin.biginteger.prototype.or = self.Sk.builtin.biginteger.prototype.bnOr
      self.Sk.builtin.biginteger.prototype.xor =
        self.Sk.builtin.biginteger.prototype.bnXor
      self.Sk.builtin.biginteger.prototype.andNot =
        self.Sk.builtin.biginteger.prototype.bnAndNot
      self.Sk.builtin.biginteger.prototype.not =
        self.Sk.builtin.biginteger.prototype.bnNot
      self.Sk.builtin.biginteger.prototype.shiftLeft =
        self.Sk.builtin.biginteger.prototype.bnShiftLeft
      self.Sk.builtin.biginteger.prototype.shiftRight =
        self.Sk.builtin.biginteger.prototype.bnShiftRight
      self.Sk.builtin.biginteger.prototype.getLowestSetBit =
        self.Sk.builtin.biginteger.prototype.bnGetLowestSetBit
      self.Sk.builtin.biginteger.prototype.bitCount =
        self.Sk.builtin.biginteger.prototype.bnBitCount
      self.Sk.builtin.biginteger.prototype.testBit =
        self.Sk.builtin.biginteger.prototype.bnTestBit
      self.Sk.builtin.biginteger.prototype.setBit =
        self.Sk.builtin.biginteger.prototype.bnSetBit
      self.Sk.builtin.biginteger.prototype.clearBit =
        self.Sk.builtin.biginteger.prototype.bnClearBit
      self.Sk.builtin.biginteger.prototype.flipBit =
        self.Sk.builtin.biginteger.prototype.bnFlipBit
      self.Sk.builtin.biginteger.prototype.add =
        self.Sk.builtin.biginteger.prototype.bnAdd
      self.Sk.builtin.biginteger.prototype.subtract =
        self.Sk.builtin.biginteger.prototype.bnSubtract
      self.Sk.builtin.biginteger.prototype.multiply =
        self.Sk.builtin.biginteger.prototype.bnMultiply
      self.Sk.builtin.biginteger.prototype.divide =
        self.Sk.builtin.biginteger.prototype.bnDivide
      self.Sk.builtin.biginteger.prototype.remainder =
        self.Sk.builtin.biginteger.prototype.bnRemainder
      self.Sk.builtin.biginteger.prototype.divideAndRemainder =
        self.Sk.builtin.biginteger.prototype.bnDivideAndRemainder
      self.Sk.builtin.biginteger.prototype.modPow =
        self.Sk.builtin.biginteger.prototype.bnModPow
      self.Sk.builtin.biginteger.prototype.modInverse =
        self.Sk.builtin.biginteger.prototype.bnModInverse
      self.Sk.builtin.biginteger.prototype.pow =
        self.Sk.builtin.biginteger.prototype.bnPow
      self.Sk.builtin.biginteger.prototype.gcd =
        self.Sk.builtin.biginteger.prototype.bnGCD
      self.Sk.builtin.biginteger.prototype.isProbablePrime =
        self.Sk.builtin.biginteger.prototype.bnIsProbablePrime
    },
    function(m, p) {
      self.Sk.builtin.int_ = function(a, b) {
        if (!(this instanceof self.Sk.builtin.int_)) return new self.Sk.builtin.int_(a, b)
        if (this instanceof self.Sk.builtin.bool) return this
        if (a instanceof self.Sk.builtin.int_ && void 0 === b)
          return (this.v = a.v), this
        if (
          b !== self.Sk.builtin.none.none$ &&
          void 0 !== b &&
          !self.Sk.builtin.checkInt(b)
        ) {
          if (self.Sk.builtin.checkFloat(b))
            throw new self.Sk.builtin.TypeError(
              "integer argument expected, got " + self.Sk.abstr.typeName(b),
            )
          if (b.__index__) b = self.Sk.misceval.callsimArray(b.__index__, [b])
          else if (b.__int__) b = self.Sk.misceval.callsimArray(b.__int__, [b])
          else
            throw new self.Sk.builtin.AttributeError(
              self.Sk.abstr.typeName(b) +
                " instance has no attribute '__index__' or '__int__'",
            )
        }
        if (a instanceof self.Sk.builtin.str) {
          b = self.Sk.builtin.asnum$(b)
          b === self.Sk.builtin.none.none$ && (b = 10)
          var c = self.Sk.str2number(
            a.v,
            b,
            parseInt,
            function(a) {
              return -a
            },
            "int",
          )
          if (c > self.Sk.builtin.int_.threshold$ || c < -self.Sk.builtin.int_.threshold$)
            return new self.Sk.builtin.lng(a, b)
          this.v = c
          return this
        }
        if (void 0 !== b && b !== self.Sk.builtin.none.none$)
          throw new self.Sk.builtin.TypeError(
            "int() can't convert non-string with explicit base",
          )
        if (void 0 === a || a === self.Sk.builtin.none) a = 0
        if (
          void 0 !== a &&
          a.tp$getattr &&
          (c = a.tp$getattr(self.Sk.builtin.str.$int_))
        ) {
          var d = self.Sk.misceval.callsimArray(c)
          var e = "__int__"
        } else
          void 0 !== a && a.__int__
            ? ((d = self.Sk.misceval.callsimArray(a.__int__, [a])), (e = "__int__"))
            : void 0 !== a &&
              a.tp$getattr &&
              (c = a.tp$getattr(self.Sk.builtin.str.$trunc))
            ? ((d = self.Sk.misceval.callsimArray(c)), (e = "__trunc__"))
            : void 0 !== a &&
              a.__trunc__ &&
              ((d = self.Sk.misceval.callsimArray(a.__trunc__, [a])),
              (e = "__trunc__"))
        if (void 0 === d || self.Sk.builtin.checkInt(d)) void 0 !== d && (a = d)
        else
          throw new self.Sk.builtin.TypeError(
            e + " returned non-Integral (type " + self.Sk.abstr.typeName(d) + ")",
          )
        if (!self.Sk.builtin.checkNumber(a))
          throw new self.Sk.builtin.TypeError(
            "int() argument must be a string or a number, not '" +
              self.Sk.abstr.typeName(a) +
              "'",
          )
        a = self.Sk.builtin.asnum$(a)
        if (a > self.Sk.builtin.int_.threshold$ || a < -self.Sk.builtin.int_.threshold$)
          return new self.Sk.builtin.lng(a)
        ;-1 < a && 1 > a && (a = 0)
        this.v = parseInt(a, b)
        return this
      }
      self.Sk.builtin.int_.$shiftconsts = [
        0.5,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        256,
        512,
        1024,
        2048,
        4096,
        8192,
        16384,
        32768,
        65536,
        131072,
        262144,
        524288,
        1048576,
        2097152,
        4194304,
        8388608,
        16777216,
        33554432,
        67108864,
        134217728,
        268435456,
        536870912,
        1073741824,
        2147483648,
        4294967296,
        8589934592,
        17179869184,
        34359738368,
        68719476736,
        137438953472,
        274877906944,
        549755813888,
        1099511627776,
        2199023255552,
        4398046511104,
        8796093022208,
        17592186044416,
        35184372088832,
        70368744177664,
        0x800000000000,
        281474976710656,
        562949953421312,
        0x4000000000000,
        0x8000000000000,
        4503599627370496,
        9007199254740992,
      ]
      self.Sk.abstr.setUpInheritance("int", self.Sk.builtin.int_, self.Sk.builtin.numtype)
      self.Sk.builtin.int_.prototype.nb$int_ = function() {
        return this
      }
      self.Sk.builtin.int_.prototype.nb$float_ = function() {
        return new self.Sk.builtin.float_(this.v)
      }
      self.Sk.builtin.int_.prototype.nb$lng = function() {
        return new self.Sk.builtin.lng(this.v)
      }
      self.Sk.builtin.int_.prototype.__trunc__ = new self.Sk.builtin.func(function(a) {
        return a
      })
      self.Sk.builtin.int_.prototype.__index__ = new self.Sk.builtin.func(function(a) {
        return a
      })
      self.Sk.builtin.int_.prototype.__complex__ = new self.Sk.builtin.func(function(a) {
        return self.Sk.builtin.NotImplemented.NotImplemented$
      })
      self.Sk.builtin.int_.prototype.tp$index = function() {
        return this.v
      }
      self.Sk.builtin.int_.prototype.tp$hash = function() {
        return new self.Sk.builtin.int_(this.v)
      }
      self.Sk.builtin.int_.threshold$ = Math.pow(2, 53) - 1
      self.Sk.builtin.int_.prototype.clone = function() {
        return new self.Sk.builtin.int_(this.v)
      }
      self.Sk.builtin.int_.prototype.nb$add = function(a) {
        if (a instanceof self.Sk.builtin.int_) {
          var b = this.v + a.v
          return b > self.Sk.builtin.int_.threshold$ ||
            b < -self.Sk.builtin.int_.threshold$
            ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$add(a))
            : new self.Sk.builtin.int_(b)
        }
        return a instanceof self.Sk.builtin.lng
          ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$add(a))
          : a instanceof self.Sk.builtin.float_
          ? ((b = new self.Sk.builtin.float_(this.v)), b.nb$add(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_add = function(a) {
        return self.Sk.builtin.int_.prototype.nb$add.call(this, a)
      }
      self.Sk.builtin.int_.prototype.nb$subtract = function(a) {
        if (a instanceof self.Sk.builtin.int_) {
          var b = this.v - a.v
          return b > self.Sk.builtin.int_.threshold$ ||
            b < -self.Sk.builtin.int_.threshold$
            ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$subtract(a))
            : new self.Sk.builtin.int_(b)
        }
        return a instanceof self.Sk.builtin.lng
          ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$subtract(a))
          : a instanceof self.Sk.builtin.float_
          ? ((b = new self.Sk.builtin.float_(this.v)), b.nb$subtract(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_subtract = function(a) {
        var b = this.nb$negative()
        return self.Sk.builtin.int_.prototype.nb$add.call(b, a)
      }
      self.Sk.builtin.int_.prototype.nb$multiply = function(a) {
        if (a instanceof self.Sk.builtin.int_) {
          var b = this.v * a.v
          return b > self.Sk.builtin.int_.threshold$ ||
            b < -self.Sk.builtin.int_.threshold$
            ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$multiply(a))
            : new self.Sk.builtin.int_(b)
        }
        return a instanceof self.Sk.builtin.lng
          ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$multiply(a))
          : a instanceof self.Sk.builtin.float_
          ? ((b = new self.Sk.builtin.float_(this.v)), b.nb$multiply(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_multiply = function(a) {
        return self.Sk.builtin.int_.prototype.nb$multiply.call(this, a)
      }
      self.Sk.builtin.int_.prototype.nb$divide = function(a) {
        if (self.Sk.__future__.division) {
          var b = new self.Sk.builtin.float_(this.v)
          return b.nb$divide(a)
        }
        return a instanceof self.Sk.builtin.int_
          ? this.nb$floor_divide(a)
          : a instanceof self.Sk.builtin.lng
          ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$divide(a))
          : a instanceof self.Sk.builtin.float_
          ? ((b = new self.Sk.builtin.float_(this.v)), b.nb$divide(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_divide = function(a) {
        return this.nb$reflected_floor_divide(a)
      }
      self.Sk.builtin.int_.prototype.nb$floor_divide = function(a) {
        if (a instanceof self.Sk.builtin.int_) {
          if (0 === a.v)
            throw new self.Sk.builtin.ZeroDivisionError(
              "integer division or modulo by zero",
            )
          return new self.Sk.builtin.int_(Math.floor(this.v / a.v))
        }
        if (a instanceof self.Sk.builtin.lng) {
          var b = new self.Sk.builtin.lng(this.v)
          return b.nb$floor_divide(a)
        }
        return a instanceof self.Sk.builtin.float_
          ? ((b = new self.Sk.builtin.float_(this.v)), b.nb$floor_divide(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_floor_divide = function(a) {
        return a instanceof self.Sk.builtin.int_
          ? a.nb$divide(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$remainder = function(a) {
        if (a instanceof self.Sk.builtin.int_) {
          var b = self.Sk.abstr.numberBinOp(this, a, "FloorDiv")
          b = self.Sk.abstr.numberBinOp(b, a, "Mult")
          b = self.Sk.abstr.numberBinOp(this, b, "Sub")
          b = b.v
          0 > a.v && 0 === b
            ? (b = -0)
            : 0 === b && -Infinity === Infinity / b && (b = 0)
          return new self.Sk.builtin.int_(b)
        }
        return a instanceof self.Sk.builtin.lng
          ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$remainder(a))
          : a instanceof self.Sk.builtin.float_
          ? ((b = new self.Sk.builtin.float_(this.v)), b.nb$remainder(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_remainder = function(a) {
        return a instanceof self.Sk.builtin.int_
          ? a.nb$remainder(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$divmod = function(a) {
        if (a instanceof self.Sk.builtin.int_)
          return new self.Sk.builtin.tuple([
            this.nb$floor_divide(a),
            this.nb$remainder(a),
          ])
        if (a instanceof self.Sk.builtin.lng) {
          var b = new self.Sk.builtin.lng(this.v)
          return b.nb$divmod(a)
        }
        return a instanceof self.Sk.builtin.float_
          ? ((b = new self.Sk.builtin.float_(this.v)), b.nb$divmod(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_divmod = function(a) {
        return a instanceof self.Sk.builtin.int_
          ? new self.Sk.builtin.tuple([
              a.nb$floor_divide(this),
              a.nb$remainder(this),
            ])
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$power = function(a, b) {
        if (
          a instanceof self.Sk.builtin.int_ &&
          (void 0 === b || b instanceof self.Sk.builtin.int_)
        ) {
          var c = Math.pow(this.v, a.v)
          c > self.Sk.builtin.int_.threshold$ || c < -self.Sk.builtin.int_.threshold$
            ? ((c = new self.Sk.builtin.lng(this.v)), (c = c.nb$power(a, b)))
            : (c = 0 > a.v ? new self.Sk.builtin.float_(c) : new self.Sk.builtin.int_(c))
          if (void 0 !== b) {
            if (0 > a.v)
              throw new self.Sk.builtin.TypeError(
                "pow() 2nd argument cannot be negative when 3rd argument specified",
              )
            return c.nb$remainder(b)
          }
          return c
        }
        return a instanceof self.Sk.builtin.lng
          ? ((c = new self.Sk.builtin.lng(this.v)), c.nb$power(a))
          : a instanceof self.Sk.builtin.float_
          ? ((b = new self.Sk.builtin.float_(this.v)), b.nb$power(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_power = function(a, b) {
        return a instanceof self.Sk.builtin.int_
          ? a.nb$power(this, b)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$abs = function() {
        return new self.Sk.builtin.int_(Math.abs(this.v))
      }
      self.Sk.builtin.int_.prototype.nb$and = function(a) {
        if (a instanceof self.Sk.builtin.int_) {
          a = self.Sk.builtin.asnum$(a)
          var b = this.v & a
          void 0 !== b && 0 > b && (b += 4294967296)
          if (void 0 !== b) return new self.Sk.builtin.int_(b)
        }
        return a instanceof self.Sk.builtin.lng
          ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$and(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_and =
        self.Sk.builtin.int_.prototype.nb$and
      self.Sk.builtin.int_.prototype.nb$or = function(a) {
        if (a instanceof self.Sk.builtin.int_) {
          a = self.Sk.builtin.asnum$(a)
          var b = this.v | a
          void 0 !== b && 0 > b && (b += 4294967296)
          if (void 0 !== b) return new self.Sk.builtin.int_(b)
        }
        return a instanceof self.Sk.builtin.lng
          ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$and(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_or =
        self.Sk.builtin.int_.prototype.nb$or
      self.Sk.builtin.int_.prototype.nb$xor = function(a) {
        if (a instanceof self.Sk.builtin.int_) {
          a = self.Sk.builtin.asnum$(a)
          var b = this.v ^ a
          void 0 !== b && 0 > b && (b += 4294967296)
          if (void 0 !== b) return new self.Sk.builtin.int_(b)
        }
        return a instanceof self.Sk.builtin.lng
          ? ((b = new self.Sk.builtin.lng(this.v)), b.nb$xor(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_xor =
        self.Sk.builtin.int_.prototype.nb$xor
      self.Sk.builtin.int_.prototype.nb$lshift = function(a) {
        if (0 === this.v) return this
        if (a instanceof self.Sk.builtin.int_) {
          var b = self.Sk.builtin.asnum$(a)
          if (void 0 !== b) {
            if (0 > b) throw new self.Sk.builtin.ValueError("negative shift count")
            if (53 < b)
              return new self.Sk.builtin.lng(this.v).nb$lshift(
                new self.Sk.builtin.int_(b),
              )
            var c = 2 * this.v * self.Sk.builtin.int_.$shiftconsts[b]
            if (
              c > self.Sk.builtin.int_.threshold$ ||
              c < -self.Sk.builtin.int_.threshold$
            )
              return new self.Sk.builtin.lng(c)
          }
          if (void 0 !== c) return new self.Sk.builtin.int_(c)
        }
        return a instanceof self.Sk.builtin.lng
          ? ((c = new self.Sk.builtin.lng(this.v)), c.nb$lshift(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_lshift = function(a) {
        return a instanceof self.Sk.builtin.int_
          ? a.nb$lshift(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$rshift = function(a) {
        if (a instanceof self.Sk.builtin.int_) {
          var b = self.Sk.builtin.asnum$(a)
          if (void 0 !== b) {
            if (0 > b) throw new self.Sk.builtin.ValueError("negative shift count")
            var c = this.v >> b
            0 < this.v && 0 > c && (c &= Math.pow(2, 32 - b) - 1)
          }
          if (void 0 !== c) return new self.Sk.builtin.int_(c)
        }
        return a instanceof self.Sk.builtin.lng
          ? ((c = new self.Sk.builtin.lng(this.v)), c.nb$rshift(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$reflected_rshift = function(a) {
        return a instanceof self.Sk.builtin.int_
          ? a.nb$rshift(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.nb$invert = function() {
        return new self.Sk.builtin.int_(~this.v)
      }
      self.Sk.builtin.int_.prototype.nb$inplace_add =
        self.Sk.builtin.int_.prototype.nb$add
      self.Sk.builtin.int_.prototype.nb$inplace_subtract =
        self.Sk.builtin.int_.prototype.nb$subtract
      self.Sk.builtin.int_.prototype.nb$inplace_multiply =
        self.Sk.builtin.int_.prototype.nb$multiply
      self.Sk.builtin.int_.prototype.nb$inplace_divide =
        self.Sk.builtin.int_.prototype.nb$divide
      self.Sk.builtin.int_.prototype.nb$inplace_remainder =
        self.Sk.builtin.int_.prototype.nb$remainder
      self.Sk.builtin.int_.prototype.nb$inplace_floor_divide =
        self.Sk.builtin.int_.prototype.nb$floor_divide
      self.Sk.builtin.int_.prototype.nb$inplace_power =
        self.Sk.builtin.int_.prototype.nb$power
      self.Sk.builtin.int_.prototype.nb$inplace_and =
        self.Sk.builtin.int_.prototype.nb$and
      self.Sk.builtin.int_.prototype.nb$inplace_or = self.Sk.builtin.int_.prototype.nb$or
      self.Sk.builtin.int_.prototype.nb$inplace_xor =
        self.Sk.builtin.int_.prototype.nb$xor
      self.Sk.builtin.int_.prototype.nb$inplace_lshift =
        self.Sk.builtin.int_.prototype.nb$lshift
      self.Sk.builtin.int_.prototype.nb$inplace_rshift =
        self.Sk.builtin.int_.prototype.nb$rshift
      self.Sk.builtin.int_.prototype.nb$negative = function() {
        return new self.Sk.builtin.int_(-this.v)
      }
      self.Sk.builtin.int_.prototype.nb$positive = function() {
        return this.clone()
      }
      self.Sk.builtin.int_.prototype.nb$nonzero = function() {
        return 0 !== this.v
      }
      self.Sk.builtin.int_.prototype.nb$isnegative = function() {
        return 0 > this.v
      }
      self.Sk.builtin.int_.prototype.nb$ispositive = function() {
        return 0 <= this.v
      }
      self.Sk.builtin.int_.prototype.numberCompare = function(a) {
        return a instanceof self.Sk.builtin.int_
          ? this.v - a.v
          : a instanceof self.Sk.builtin.lng
          ? -a.longCompare(this)
          : a instanceof self.Sk.builtin.float_
          ? -a.numberCompare(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.ob$eq = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 == this.numberCompare(a))
          : a instanceof self.Sk.builtin.none
          ? self.Sk.builtin.bool.false$
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.ob$ne = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 != this.numberCompare(a))
          : a instanceof self.Sk.builtin.none
          ? self.Sk.builtin.bool.true$
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.ob$lt = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 > this.numberCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.ob$le = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 >= this.numberCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.ob$gt = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 < this.numberCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.ob$ge = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 <= this.numberCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.int_.prototype.round$ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__round__", arguments.length, 1, 2)
        if (void 0 !== b && !self.Sk.misceval.isIndex(b))
          throw new self.Sk.builtin.TypeError(
            "'" +
              self.Sk.abstr.typeName(b) +
              "' object cannot be interpreted as an index",
          )
        var c = self.Sk.builtin.asnum$(a)
        var d = void 0 === b ? 0 : self.Sk.misceval.asIndex(b)
        if (self.Sk.__future__.bankers_rounding) {
          c *= Math.pow(10, d)
          var e = Math.round(c)
          d =
            (0.5 === (0 < c ? c : -c) % 1 ? (0 === e % 2 ? e : e - 1) : e) /
            Math.pow(10, d)
        } else (d = Math.pow(10, d)), (d = Math.round(c * d) / d)
        return new self.Sk.builtin.int_(d)
      }
      self.Sk.builtin.int_.prototype.__format__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__format__", arguments.length, 2, 2)
        if (self.Sk.builtin.checkString(b)) {
          var c = self.Sk.ffi.remapToJs(b)
          if ("" !== c)
            throw new self.Sk.builtin.NotImplementedError(
              "format spec is not yet implemented",
            )
        } else {
          if (self.Sk.__future__.exceptions)
            throw new self.Sk.builtin.TypeError(
              "format() argument 2 must be str, not " + self.Sk.abstr.typeName(b),
            )
          throw new self.Sk.builtin.TypeError(
            "format expects arg 2 to be string or unicode, not " +
              self.Sk.abstr.typeName(b),
          )
        }
        return new self.Sk.builtin.str(a)
      }
      self.Sk.builtin.int_.prototype.conjugate = new self.Sk.builtin.func(function(a) {
        return new self.Sk.builtin.int_(a.v)
      })
      self.Sk.builtin.int_.prototype.$r = function() {
        return new self.Sk.builtin.str(this.str$(10, !0))
      }
      self.Sk.builtin.int_.prototype.tp$str = function() {
        return new self.Sk.builtin.str(this.str$(10, !0))
      }
      self.Sk.builtin.int_.prototype.str$ = function(a, b) {
        void 0 === b && (b = !0)
        b = b ? this.v : Math.abs(this.v)
        return void 0 === a || 10 === a ? b.toString() : b.toString(a)
      }
      self.Sk.str2number = function(a, b, c, d, e) {
        var f = a,
          g = !1,
          h
        a = a.replace(/^\s+|\s+$/g, "")
        "-" === a.charAt(0) && ((g = !0), (a = a.substring(1)))
        "+" === a.charAt(0) && (a = a.substring(1))
        if (null === b || void 0 === b) b = 10
        if ((2 > b || 36 < b) && 0 !== b)
          throw new self.Sk.builtin.ValueError(e + "() base must be >= 2 and <= 36")
        if ("0x" === a.substring(0, 2).toLowerCase())
          if (16 === b || 0 === b) (a = a.substring(2)), (b = 16)
          else {
            if (34 > b)
              throw new self.Sk.builtin.ValueError(
                "invalid literal for " +
                  e +
                  "() with base " +
                  b +
                  ": '" +
                  f +
                  "'",
              )
          }
        else if ("0b" === a.substring(0, 2).toLowerCase())
          if (2 === b || 0 === b) (a = a.substring(2)), (b = 2)
          else {
            if (12 > b)
              throw new self.Sk.builtin.ValueError(
                "invalid literal for " +
                  e +
                  "() with base " +
                  b +
                  ": '" +
                  f +
                  "'",
              )
          }
        else if ("0o" === a.substring(0, 2).toLowerCase())
          if (8 === b || 0 === b) (a = a.substring(2)), (b = 8)
          else {
            if (25 > b)
              throw new self.Sk.builtin.ValueError(
                "invalid literal for " +
                  e +
                  "() with base " +
                  b +
                  ": '" +
                  f +
                  "'",
              )
          }
        else if ("0" === a.charAt(0)) {
          if ("0" === a) return 0
          if (8 === b || 0 === b) b = 8
        }
        0 === b && (b = 10)
        if (0 === a.length)
          throw new self.Sk.builtin.ValueError(
            "invalid literal for " + e + "() with base " + b + ": '" + f + "'",
          )
        for (h = 0; h < a.length; h += 1) {
          var k = a.charCodeAt(h)
          var l = b
          48 <= k && 57 >= k
            ? (l = k - 48)
            : 65 <= k && 90 >= k
            ? (l = k - 65 + 10)
            : 97 <= k && 122 >= k && (l = k - 97 + 10)
          if (l >= b)
            throw new self.Sk.builtin.ValueError(
              "invalid literal for " +
                e +
                "() with base " +
                b +
                ": '" +
                f +
                "'",
            )
        }
        l = c(a, b)
        g && (l = d(l))
        return l
      }
      self.Sk.exportSymbol("Sk.builtin.int_", self.Sk.builtin.int_)
    },
    function(m, p) {
      self.Sk.builtin.bool = function(a) {
        self.Sk.builtin.pyCheckArgsLen("bool", arguments.length, 1)
        return self.Sk.misceval.isTrue(a)
          ? self.Sk.builtin.bool.true$
          : self.Sk.builtin.bool.false$
      }
      self.Sk.abstr.setUpInheritance("bool", self.Sk.builtin.bool, self.Sk.builtin.int_)
      self.Sk.builtin.bool.prototype.$r = function() {
        return this.v ? new self.Sk.builtin.str("True") : new self.Sk.builtin.str("False")
      }
      self.Sk.builtin.bool.prototype.tp$hash = function() {
        return new self.Sk.builtin.int_(this.v)
      }
      self.Sk.builtin.bool.prototype.__int__ = new self.Sk.builtin.func(function(a) {
        a = self.Sk.builtin.asnum$(a)
        return new self.Sk.builtin.int_(a)
      })
      self.Sk.builtin.bool.prototype.__float__ = new self.Sk.builtin.func(function(a) {
        return new self.Sk.builtin.float_(self.Sk.ffi.remapToJs(a))
      })
      self.Sk.exportSymbol("Sk.builtin.bool", self.Sk.builtin.bool)
    },
    function(m, p) {
      self.Sk.builtin.float_ = function(a) {
        if (void 0 === a) return new self.Sk.builtin.float_(0)
        if (!(this instanceof self.Sk.builtin.float_))
          return new self.Sk.builtin.float_(a)
        if (a instanceof self.Sk.builtin.str) return self.Sk.builtin._str_to_float(a.v)
        if (
          "number" === typeof a ||
          a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
        ) {
          a = self.Sk.builtin.asnum$(a)
          if ("string" === typeof a) return self.Sk.builtin._str_to_float(a)
          this.v = a
          return this
        }
        if (a instanceof self.Sk.builtin.bool)
          return (this.v = self.Sk.builtin.asnum$(a)), this
        if ("boolean" === typeof a) return (this.v = a ? 1 : 0), this
        if ("string" === typeof a) return (this.v = parseFloat(a)), this
        var b = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$float_)
        if (null != b) return self.Sk.misceval.callsimArray(b, [a])
        throw new self.Sk.builtin.TypeError(
          "float() argument must be a string or a number",
        )
      }
      self.Sk.abstr.setUpInheritance("float", self.Sk.builtin.float_, self.Sk.builtin.numtype)
      self.Sk.builtin._str_to_float = function(a) {
        if (a.match(/^-inf$/i)) a = -Infinity
        else if (a.match(/^[+]?inf$/i)) a = Infinity
        else if (a.match(/^[-+]?nan$/i)) a = NaN
        else {
          if (isNaN(a))
            throw new self.Sk.builtin.ValueError(
              "float: Argument: " + a + " is not number",
            )
          a = parseFloat(a)
        }
        return new self.Sk.builtin.float_(a)
      }
      self.Sk.builtin.float_.prototype.nb$int_ = function() {
        var a = this.v
        a = 0 > a ? Math.ceil(a) : Math.floor(a)
        return new self.Sk.builtin.int_(a)
      }
      self.Sk.builtin.float_.prototype.nb$float_ = function() {
        return this
      }
      self.Sk.builtin.float_.prototype.nb$lng = function() {
        return new self.Sk.builtin.lng(this.v)
      }
      self.Sk.builtin.float_.PyFloat_Check = function(a) {
        return void 0 === a
          ? !1
          : self.Sk.builtin.checkNumber(a) ||
            self.Sk.builtin.checkFloat(a) ||
            self.Sk.builtin.issubclass(a.ob$type, self.Sk.builtin.float_)
          ? !0
          : !1
      }
      self.Sk.builtin.float_.PyFloat_Check_Exact = function(a) {
        return self.Sk.builtin.checkFloat(a)
      }
      self.Sk.builtin.float_.PyFloat_AsDouble = function(a) {
        if (a && self.Sk.builtin.float_.PyFloat_Check(a)) return self.Sk.ffi.remapToJs(a)
        if (null == a)
          throw Error("bad argument for internal PyFloat_AsDouble function")
        var b = self.Sk.builtin.type.typeLookup(a.ob$type, self.Sk.builtin.str.$float_)
        if (null == b) throw new self.Sk.builtin.TypeError("a float is required")
        a = self.Sk.misceval.callsimArray(b, [a])
        if (!self.Sk.builtin.float_.PyFloat_Check(a))
          throw new self.Sk.builtin.TypeError("nb_float should return float object")
        return self.Sk.ffi.remapToJs(a)
      }
      self.Sk.builtin.float_.prototype.tp$index = function() {
        return this.v
      }
      self.Sk.builtin.float_.prototype.tp$hash = function() {
        return this.nb$int_()
      }
      self.Sk.builtin.float_.prototype.clone = function() {
        return new self.Sk.builtin.float_(this.v)
      }
      self.Sk.builtin.float_.prototype.toFixed = function(a) {
        a = self.Sk.builtin.asnum$(a)
        return this.v.toFixed(a)
      }
      self.Sk.builtin.float_.prototype.nb$add = function(a) {
        return a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.float_(this.v + a.v)
          : a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.float_(this.v + parseFloat(a.str$(10, !0)))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$reflected_add = function(a) {
        return self.Sk.builtin.float_.prototype.nb$add.call(this, a)
      }
      self.Sk.builtin.float_.prototype.nb$subtract = function(a) {
        return a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.float_(this.v - a.v)
          : a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.float_(this.v - parseFloat(a.str$(10, !0)))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$reflected_subtract = function(a) {
        var b = this.nb$negative()
        return self.Sk.builtin.float_.prototype.nb$add.call(b, a)
      }
      self.Sk.builtin.float_.prototype.nb$multiply = function(a) {
        return a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.float_(this.v * a.v)
          : a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.float_(this.v * parseFloat(a.str$(10, !0)))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$reflected_multiply = function(a) {
        return self.Sk.builtin.float_.prototype.nb$multiply.call(this, a)
      }
      self.Sk.builtin.float_.prototype.nb$divide = function(a) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.float_) {
          if (0 === a.v)
            throw new self.Sk.builtin.ZeroDivisionError(
              "integer division or modulo by zero",
            )
          return Infinity === this.v
            ? Infinity === a.v || -Infinity === a.v
              ? new self.Sk.builtin.float_(NaN)
              : a.nb$isnegative()
              ? new self.Sk.builtin.float_(-Infinity)
              : new self.Sk.builtin.float_(Infinity)
            : -Infinity === this.v
            ? Infinity === a.v || -Infinity === a.v
              ? new self.Sk.builtin.float_(NaN)
              : a.nb$isnegative()
              ? new self.Sk.builtin.float_(Infinity)
              : new self.Sk.builtin.float_(-Infinity)
            : new self.Sk.builtin.float_(this.v / a.v)
        }
        if (a instanceof self.Sk.builtin.lng) {
          if (0 === a.longCompare(self.Sk.builtin.biginteger.ZERO))
            throw new self.Sk.builtin.ZeroDivisionError(
              "integer division or modulo by zero",
            )
          return Infinity === this.v
            ? a.nb$isnegative()
              ? new self.Sk.builtin.float_(-Infinity)
              : new self.Sk.builtin.float_(Infinity)
            : -Infinity === this.v
            ? a.nb$isnegative()
              ? new self.Sk.builtin.float_(Infinity)
              : new self.Sk.builtin.float_(-Infinity)
            : new self.Sk.builtin.float_(this.v / parseFloat(a.str$(10, !0)))
        }
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$reflected_divide = function(a) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.lng)
          a = new self.Sk.builtin.float_(a)
        return a instanceof self.Sk.builtin.float_
          ? a.nb$divide(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$floor_divide = function(a) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.float_) {
          if (Infinity === this.v || -Infinity === this.v)
            return new self.Sk.builtin.float_(NaN)
          if (0 === a.v)
            throw new self.Sk.builtin.ZeroDivisionError(
              "integer division or modulo by zero",
            )
          return Infinity === a.v
            ? this.nb$isnegative()
              ? new self.Sk.builtin.float_(-1)
              : new self.Sk.builtin.float_(0)
            : -Infinity === a.v
            ? this.nb$isnegative() || !this.nb$nonzero()
              ? new self.Sk.builtin.float_(0)
              : new self.Sk.builtin.float_(-1)
            : new self.Sk.builtin.float_(Math.floor(this.v / a.v))
        }
        if (a instanceof self.Sk.builtin.lng) {
          if (0 === a.longCompare(self.Sk.builtin.biginteger.ZERO))
            throw new self.Sk.builtin.ZeroDivisionError(
              "integer division or modulo by zero",
            )
          return Infinity === this.v || -Infinity === this.v
            ? new self.Sk.builtin.float_(NaN)
            : new self.Sk.builtin.float_(
                Math.floor(this.v / parseFloat(a.str$(10, !0))),
              )
        }
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$reflected_floor_divide = function(a) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.lng)
          a = new self.Sk.builtin.float_(a)
        return a instanceof self.Sk.builtin.float_
          ? a.nb$floor_divide(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$remainder = function(a) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.float_) {
          if (0 === a.v)
            throw new self.Sk.builtin.ZeroDivisionError(
              "integer division or modulo by zero",
            )
          if (0 === this.v) return new self.Sk.builtin.float_(0)
          if (Infinity === a.v)
            return Infinity === this.v || -Infinity === this.v
              ? new self.Sk.builtin.float_(NaN)
              : this.nb$ispositive()
              ? new self.Sk.builtin.float_(this.v)
              : new self.Sk.builtin.float_(Infinity)
          var b = this.v % a.v
          0 > this.v
            ? 0 < a.v && 0 > b && (b += a.v)
            : 0 > a.v && 0 !== b && (b += a.v)
          0 > a.v && 0 === b
            ? (b = -0)
            : 0 === b && -Infinity === Infinity / b && (b = 0)
          return new self.Sk.builtin.float_(b)
        }
        if (a instanceof self.Sk.builtin.lng) {
          if (0 === a.longCompare(self.Sk.builtin.biginteger.ZERO))
            throw new self.Sk.builtin.ZeroDivisionError(
              "integer division or modulo by zero",
            )
          if (0 === this.v) return new self.Sk.builtin.float_(0)
          var c = parseFloat(a.str$(10, !0))
          b = this.v % c
          0 > b ? 0 < c && 0 !== b && (b += c) : 0 > c && 0 !== b && (b += c)
          a.nb$isnegative() && 0 === b
            ? (b = -0)
            : 0 === b && -Infinity === Infinity / b && (b = 0)
          return new self.Sk.builtin.float_(b)
        }
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$reflected_remainder = function(a) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.lng)
          a = new self.Sk.builtin.float_(a)
        return a instanceof self.Sk.builtin.float_
          ? a.nb$remainder(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$divmod = function(a) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.lng)
          a = new self.Sk.builtin.float_(a)
        return a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.tuple([
              this.nb$floor_divide(a),
              this.nb$remainder(a),
            ])
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$reflected_divmod = function(a) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.lng)
          a = new self.Sk.builtin.float_(a)
        return a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.tuple([
              a.nb$floor_divide(this),
              a.nb$remainder(this),
            ])
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$power = function(a, b) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.float_) {
          if (0 > this.v && 0 !== a.v % 1)
            throw new self.Sk.builtin.NegativePowerError(
              "cannot raise a negative number to a fractional power",
            )
          if (0 === this.v && 0 > a.v)
            throw new self.Sk.builtin.NegativePowerError(
              "cannot raise zero to a negative power",
            )
          b = new self.Sk.builtin.float_(Math.pow(this.v, a.v))
          if (
            Infinity === Math.abs(b.v) &&
            Infinity !== Math.abs(this.v) &&
            Infinity !== Math.abs(a.v)
          )
            throw new self.Sk.builtin.OverflowError("Numerical result out of range")
          return b
        }
        if (a instanceof self.Sk.builtin.lng) {
          if (0 === this.v && 0 > a.longCompare(self.Sk.builtin.biginteger.ZERO))
            throw new self.Sk.builtin.NegativePowerError(
              "cannot raise zero to a negative power",
            )
          return new self.Sk.builtin.float_(
            Math.pow(this.v, parseFloat(a.str$(10, !0))),
          )
        }
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$reflected_power = function(a, b) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.lng)
          a = new self.Sk.builtin.float_(a)
        return a instanceof self.Sk.builtin.float_
          ? a.nb$power(this, b)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.nb$abs = function() {
        return new self.Sk.builtin.float_(Math.abs(this.v))
      }
      self.Sk.builtin.float_.prototype.nb$inplace_add =
        self.Sk.builtin.float_.prototype.nb$add
      self.Sk.builtin.float_.prototype.nb$inplace_subtract =
        self.Sk.builtin.float_.prototype.nb$subtract
      self.Sk.builtin.float_.prototype.nb$inplace_multiply =
        self.Sk.builtin.float_.prototype.nb$multiply
      self.Sk.builtin.float_.prototype.nb$inplace_divide =
        self.Sk.builtin.float_.prototype.nb$divide
      self.Sk.builtin.float_.prototype.nb$inplace_remainder =
        self.Sk.builtin.float_.prototype.nb$remainder
      self.Sk.builtin.float_.prototype.nb$inplace_floor_divide =
        self.Sk.builtin.float_.prototype.nb$floor_divide
      self.Sk.builtin.float_.prototype.nb$inplace_power =
        self.Sk.builtin.float_.prototype.nb$power
      self.Sk.builtin.float_.prototype.nb$negative = function() {
        return new self.Sk.builtin.float_(-this.v)
      }
      self.Sk.builtin.float_.prototype.nb$positive = function() {
        return this.clone()
      }
      self.Sk.builtin.float_.prototype.nb$nonzero = function() {
        return 0 !== this.v
      }
      self.Sk.builtin.float_.prototype.nb$isnegative = function() {
        return 0 > this.v
      }
      self.Sk.builtin.float_.prototype.nb$ispositive = function() {
        return 0 <= this.v
      }
      self.Sk.builtin.float_.prototype.numberCompare = function(a) {
        if (a instanceof self.Sk.builtin.int_ || a instanceof self.Sk.builtin.float_)
          return (Infinity == this.v && Infinity == a.v) ||
            (-Infinity == this.v && -Infinity == a.v)
            ? 0
            : this.v - a.v
        if (a instanceof self.Sk.builtin.lng) {
          if (0 === this.v % 1) {
            var b = new self.Sk.builtin.lng(this.v)
            return (a = b.longCompare(a))
          }
          a = this.nb$subtract(a)
          if (a instanceof self.Sk.builtin.float_) return a.v
          if (a instanceof self.Sk.builtin.lng)
            return a.longCompare(self.Sk.builtin.biginteger.ZERO)
        }
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.ob$eq = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 == this.numberCompare(a))
          : a instanceof self.Sk.builtin.none
          ? self.Sk.builtin.bool.false$
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.ob$ne = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 != this.numberCompare(a))
          : a instanceof self.Sk.builtin.none
          ? self.Sk.builtin.bool.true$
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.ob$lt = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 > this.numberCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.ob$le = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 >= this.numberCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.ob$gt = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 < this.numberCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.ob$ge = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 <= this.numberCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.float_.prototype.round$ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__round__", arguments.length, 1, 2)
        if (void 0 !== b && !self.Sk.misceval.isIndex(b))
          throw new self.Sk.builtin.TypeError(
            "'" +
              self.Sk.abstr.typeName(b) +
              "' object cannot be interpreted as an index",
          )
        var c = self.Sk.builtin.asnum$(a)
        var d = void 0 === b ? 0 : self.Sk.misceval.asIndex(b)
        if (self.Sk.__future__.bankers_rounding) {
          c *= Math.pow(10, d)
          var e = Math.round(c)
          d =
            (0.5 === (0 < c ? c : -c) % 1 ? (0 === e % 2 ? e : e - 1) : e) /
            Math.pow(10, d)
          return void 0 === b
            ? new self.Sk.builtin.int_(d)
            : new self.Sk.builtin.float_(d)
        }
        d = Math.pow(10, d)
        d = Math.round(c * d) / d
        return new self.Sk.builtin.float_(d)
      }
      self.Sk.builtin.float_.prototype.__format__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__format__", arguments.length, 2, 2)
        if (self.Sk.builtin.checkString(b)) {
          var c = self.Sk.ffi.remapToJs(b)
          if ("" !== c)
            throw new self.Sk.builtin.NotImplementedError(
              "format spec is not yet implemented",
            )
        } else {
          if (self.Sk.__future__.exceptions)
            throw new self.Sk.builtin.TypeError(
              "format() argument 2 must be str, not " + self.Sk.abstr.typeName(b),
            )
          throw new self.Sk.builtin.TypeError(
            "format expects arg 2 to be string or unicode, not " +
              self.Sk.abstr.typeName(b),
          )
        }
        return new self.Sk.builtin.str(a)
      }
      self.Sk.builtin.float_.prototype.conjugate = new self.Sk.builtin.func(function(a) {
        return new self.Sk.builtin.float_(a.v)
      })
      self.Sk.builtin.float_.prototype.$r = function() {
        return new self.Sk.builtin.str(this.str$(10, !0))
      }
      self.Sk.builtin.float_.prototype.tp$str = function() {
        return new self.Sk.builtin.str(this.str$(10, !0))
      }
      self.Sk.builtin.float_.prototype.str$ = function(a, b) {
        if (isNaN(this.v)) return "nan"
        void 0 === b && (b = !0)
        if (Infinity == this.v) return "inf"
        if (-Infinity == this.v && b) return "-inf"
        if (-Infinity == this.v && !b) return "inf"
        b = b ? this.v : Math.abs(this.v)
        if (void 0 === a || 10 === a) {
          var c = self.Sk.__future__.python3 ? b.toPrecision(16) : b.toPrecision(12)
          var d = c.indexOf(".")
          a = b.toString().slice(0, d)
          d = b.toString().slice(d)
          a.match(/^-?0$/) &&
            d.slice(1).match(/^0{4,}/) &&
            (c = 12 > c.length ? b.toExponential() : b.toExponential(11))
          if (0 > c.indexOf("e") && 0 <= c.indexOf(".")) {
            for (; "0" == c.charAt(c.length - 1); )
              c = c.substring(0, c.length - 1)
            "." == c.charAt(c.length - 1) && (c += "0")
          }
          c = c.replace(/\.0+e/, "e", "i")
          c = c.replace(/(e[-+])([1-9])$/, "$10$2")
          c = c.replace(/0+(e.*)/, "$1")
        } else c = b.toString(a)
        0 === this.v && -Infinity === 1 / this.v && (c = "-" + c)
        0 > c.indexOf(".") &&
          0 > c.indexOf("E") &&
          0 > c.indexOf("e") &&
          (c += ".0")
        return c
      }
    },
    function(m, p) {
      var a = new self.Sk.builtin.ExternalError("Sk.builtin.nmber is deprecated.")
      self.Sk.builtin.nmber = function(a, c) {
        throw new self.Sk.builtin.ExternalError(
          "Sk.builtin.nmber is deprecated. Please replace with self.Sk.builtin.int_, self.Sk.builtin.float_, or self.Sk.builtin.assk$.",
        )
      }
      self.Sk.builtin.nmber.prototype.tp$index = function() {
        return this.v
      }
      self.Sk.builtin.nmber.prototype.tp$hash = function() {
        throw a
      }
      self.Sk.builtin.nmber.fromInt$ = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.clone = function() {
        throw a
      }
      self.Sk.builtin.nmber.prototype.toFixed = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$add = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$subtract = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$multiply = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$divide = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$floor_divide = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$remainder = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$divmod = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$power = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$and = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$or = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$xor = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$lshift = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$rshift = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$inplace_add =
        self.Sk.builtin.nmber.prototype.nb$add
      self.Sk.builtin.nmber.prototype.nb$inplace_subtract =
        self.Sk.builtin.nmber.prototype.nb$subtract
      self.Sk.builtin.nmber.prototype.nb$inplace_multiply =
        self.Sk.builtin.nmber.prototype.nb$multiply
      self.Sk.builtin.nmber.prototype.nb$inplace_divide =
        self.Sk.builtin.nmber.prototype.nb$divide
      self.Sk.builtin.nmber.prototype.nb$inplace_remainder =
        self.Sk.builtin.nmber.prototype.nb$remainder
      self.Sk.builtin.nmber.prototype.nb$inplace_floor_divide =
        self.Sk.builtin.nmber.prototype.nb$floor_divide
      self.Sk.builtin.nmber.prototype.nb$inplace_power =
        self.Sk.builtin.nmber.prototype.nb$power
      self.Sk.builtin.nmber.prototype.nb$inplace_and =
        self.Sk.builtin.nmber.prototype.nb$and
      self.Sk.builtin.nmber.prototype.nb$inplace_or =
        self.Sk.builtin.nmber.prototype.nb$or
      self.Sk.builtin.nmber.prototype.nb$inplace_xor =
        self.Sk.builtin.nmber.prototype.nb$xor
      self.Sk.builtin.nmber.prototype.nb$inplace_lshift =
        self.Sk.builtin.nmber.prototype.nb$lshift
      self.Sk.builtin.nmber.prototype.nb$inplace_rshift =
        self.Sk.builtin.nmber.prototype.nb$rshift
      self.Sk.builtin.nmber.prototype.nb$negative = function() {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$positive = function() {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$nonzero = function() {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$isnegative = function() {
        throw a
      }
      self.Sk.builtin.nmber.prototype.nb$ispositive = function() {
        throw a
      }
      self.Sk.builtin.nmber.prototype.numberCompare = function(b) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.__eq__ = function(b, c) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.__ne__ = function(b, c) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.__lt__ = function(b, c) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.__le__ = function(b, c) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.__gt__ = function(b, c) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.__ge__ = function(b, c) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.round$ = function(b, c) {
        throw a
      }
      self.Sk.builtin.nmber.prototype.$r = function() {
        throw a
      }
      self.Sk.builtin.nmber.prototype.tp$str = function() {
        throw a
      }
      self.Sk.builtin.nmber.prototype.str$ = function(b, c) {
        throw a
      }
      self.Sk.exportSymbol("Sk.builtin.nmber", self.Sk.builtin.nmber)
    },
    function(m, p) {
      self.Sk.builtin.lng = function(a, b) {
        b = self.Sk.builtin.asnum$(b)
        if (!(this instanceof self.Sk.builtin.lng)) return new self.Sk.builtin.lng(a, b)
        if (void 0 === a)
          return (this.biginteger = new self.Sk.builtin.biginteger(0)), this
        if (a instanceof self.Sk.builtin.lng)
          return (this.biginteger = a.biginteger.clone()), this
        if (a instanceof self.Sk.builtin.biginteger)
          return (this.biginteger = a), this
        if (a instanceof String || "string" === typeof a)
          return self.Sk.longFromStr(a, b)
        if (a instanceof self.Sk.builtin.str) return self.Sk.longFromStr(a.v, b)
        if (
          void 0 !== a &&
          !self.Sk.builtin.checkString(a) &&
          !self.Sk.builtin.checkNumber(a)
        )
          if (!0 === a) a = 1
          else if (!1 === a) a = 0
          else
            throw new self.Sk.builtin.TypeError(
              "long() argument must be a string or a number, not '" +
                self.Sk.abstr.typeName(a) +
                "'",
            )
        a = self.Sk.builtin.asnum$nofloat(a)
        this.biginteger = new self.Sk.builtin.biginteger(a)
        return this
      }
      self.Sk.abstr.setUpInheritance("long", self.Sk.builtin.lng, self.Sk.builtin.numtype)
      self.Sk.builtin.lng.prototype.tp$index = function() {
        return parseInt(this.str$(10, !0), 10)
      }
      self.Sk.builtin.lng.prototype.tp$hash = function() {
        return new self.Sk.builtin.int_(this.tp$index())
      }
      self.Sk.builtin.lng.prototype.nb$int_ = function() {
        return this.cantBeInt()
          ? new self.Sk.builtin.lng(this)
          : new self.Sk.builtin.int_(this.toInt$())
      }
      self.Sk.builtin.lng.prototype.__format__ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__format__", arguments.length, 2, 2)
        if (self.Sk.builtin.checkString(b)) {
          var c = self.Sk.ffi.remapToJs(b)
          if ("" !== c)
            throw new self.Sk.builtin.NotImplementedError(
              "format spec is not yet implemented",
            )
        } else {
          if (self.Sk.__future__.exceptions)
            throw new self.Sk.builtin.TypeError(
              "format() argument 2 must be str, not " + self.Sk.abstr.typeName(b),
            )
          throw new self.Sk.builtin.TypeError(
            "format expects arg 2 to be string or unicode, not " +
              self.Sk.abstr.typeName(b),
          )
        }
        return new self.Sk.builtin.str(a)
      }
      self.Sk.builtin.lng.prototype.round$ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__round__", arguments.length, 1, 2)
        if (void 0 !== b && !self.Sk.misceval.isIndex(b))
          throw new self.Sk.builtin.TypeError(
            "'" +
              self.Sk.abstr.typeName(b) +
              "' object cannot be interpreted as an index",
          )
        var c = self.Sk.builtin.asnum$(a)
        var d = void 0 === b ? 0 : self.Sk.misceval.asIndex(b)
        if (self.Sk.__future__.bankers_rounding) {
          c *= Math.pow(10, d)
          var e = Math.round(c)
          d =
            (0.5 === (0 < c ? c : -c) % 1 ? (0 === e % 2 ? e : e - 1) : e) /
            Math.pow(10, d)
        } else (d = Math.pow(10, d)), (d = Math.round(c * d) / d)
        return new self.Sk.builtin.lng(d)
      }
      self.Sk.builtin.lng.prototype.__index__ = new self.Sk.builtin.func(function(a) {
        return a.nb$int_(a)
      })
      self.Sk.builtin.lng.prototype.nb$lng_ = function() {
        return this
      }
      self.Sk.builtin.lng.prototype.nb$float_ = function() {
        return new self.Sk.builtin.float_(self.Sk.ffi.remapToJs(this))
      }
      self.Sk.builtin.lng.MAX_INT$ = new self.Sk.builtin.lng(self.Sk.builtin.int_.threshold$)
      self.Sk.builtin.lng.MIN_INT$ = new self.Sk.builtin.lng(-self.Sk.builtin.int_.threshold$)
      self.Sk.builtin.lng.prototype.cantBeInt = function() {
        return (
          0 < this.longCompare(self.Sk.builtin.lng.MAX_INT$) ||
          0 > this.longCompare(self.Sk.builtin.lng.MIN_INT$)
        )
      }
      self.Sk.builtin.lng.fromInt$ = function(a) {
        return new self.Sk.builtin.lng(a)
      }
      self.Sk.longFromStr = function(a, b) {
        a = self.Sk.str2number(
          a,
          b,
          function(a, b) {
            return 10 === b
              ? new self.Sk.builtin.biginteger(a)
              : new self.Sk.builtin.biginteger(a, b)
          },
          function(a) {
            return a.negate()
          },
          "long",
        )
        return new self.Sk.builtin.lng(a)
      }
      self.Sk.exportSymbol("Sk.longFromStr", self.Sk.longFromStr)
      self.Sk.builtin.lng.prototype.toInt$ = function() {
        return this.biginteger.intValue()
      }
      self.Sk.builtin.lng.prototype.clone = function() {
        return new self.Sk.builtin.lng(this)
      }
      self.Sk.builtin.lng.prototype.conjugate = new self.Sk.builtin.func(function(a) {
        return a.clone()
      })
      self.Sk.builtin.lng.prototype.nb$add = function(a) {
        if (a instanceof self.Sk.builtin.float_) {
          var b = new self.Sk.builtin.float_(this.str$(10, !0))
          return b.nb$add(a)
        }
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.lng(this.biginteger.add(a.biginteger))
          : a instanceof self.Sk.builtin.biginteger
          ? new self.Sk.builtin.lng(this.biginteger.add(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_add = function(a) {
        return self.Sk.builtin.lng.prototype.nb$add.call(this, a)
      }
      self.Sk.builtin.lng.prototype.nb$inplace_add = self.Sk.builtin.lng.prototype.nb$add
      self.Sk.builtin.lng.prototype.nb$subtract = function(a) {
        if (a instanceof self.Sk.builtin.float_) {
          var b = new self.Sk.builtin.float_(this.str$(10, !0))
          return b.nb$subtract(a)
        }
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.lng(this.biginteger.subtract(a.biginteger))
          : a instanceof self.Sk.builtin.biginteger
          ? new self.Sk.builtin.lng(this.biginteger.subtract(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_subtract = function(a) {
        var b = this.nb$negative()
        return self.Sk.builtin.lng.prototype.nb$add.call(b, a)
      }
      self.Sk.builtin.lng.prototype.nb$inplace_subtract =
        self.Sk.builtin.lng.prototype.nb$subtract
      self.Sk.builtin.lng.prototype.nb$multiply = function(a) {
        if (a instanceof self.Sk.builtin.float_) {
          var b = new self.Sk.builtin.float_(this.str$(10, !0))
          return b.nb$multiply(a)
        }
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.lng(this.biginteger.multiply(a.biginteger))
          : a instanceof self.Sk.builtin.biginteger
          ? new self.Sk.builtin.lng(this.biginteger.multiply(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_multiply = function(a) {
        return self.Sk.builtin.lng.prototype.nb$multiply.call(this, a)
      }
      self.Sk.builtin.lng.prototype.nb$inplace_multiply =
        self.Sk.builtin.lng.prototype.nb$multiply
      self.Sk.builtin.lng.prototype.nb$divide = function(a) {
        if (a instanceof self.Sk.builtin.float_) {
          var b = new self.Sk.builtin.float_(this.str$(10, !0))
          return b.nb$divide(a)
        }
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        if (a instanceof self.Sk.builtin.lng) {
          b = this.nb$isnegative()
          var c = a.nb$isnegative()
          if ((b && !c) || (c && !b)) {
            a = this.biginteger.divideAndRemainder(a.biginteger)
            if (0 === a[1].trueCompare(self.Sk.builtin.biginteger.ZERO))
              return new self.Sk.builtin.lng(a[0])
            a = a[0].subtract(self.Sk.builtin.biginteger.ONE)
            return new self.Sk.builtin.lng(a)
          }
          return new self.Sk.builtin.lng(this.biginteger.divide(a.biginteger))
        }
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_divide = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? a.nb$divide(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$floor_divide = function(a) {
        if (a instanceof self.Sk.builtin.float_) {
          var b = new self.Sk.builtin.float_(this.str$(10, !0))
          return b.nb$floor_divide(a)
        }
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? a.nb$divide(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$divmod = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.tuple([
              this.nb$floor_divide(a),
              this.nb$remainder(a),
            ])
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_divmod = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.tuple([
              a.nb$floor_divide(this),
              a.nb$remainder(this),
            ])
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$inplace_divide =
        self.Sk.builtin.lng.prototype.nb$divide
      self.Sk.builtin.lng.prototype.nb$floor_divide =
        self.Sk.builtin.lng.prototype.nb$divide
      self.Sk.builtin.lng.prototype.nb$reflected_floor_divide =
        self.Sk.builtin.lng.prototype.nb$reflected_divide
      self.Sk.builtin.lng.prototype.nb$inplace_floor_divide =
        self.Sk.builtin.lng.prototype.nb$floor_divide
      self.Sk.builtin.lng.prototype.nb$remainder = function(a) {
        if (0 === this.biginteger.trueCompare(self.Sk.builtin.biginteger.ZERO))
          return a instanceof self.Sk.builtin.float_
            ? new self.Sk.builtin.float_(0)
            : new self.Sk.builtin.lng(0)
        if (a instanceof self.Sk.builtin.float_) {
          var b = new self.Sk.builtin.float_(this.str$(10, !0))
          return b.nb$remainder(a)
        }
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? ((b = new self.Sk.builtin.lng(this.biginteger.remainder(a.biginteger))),
            this.nb$isnegative()
              ? a.nb$ispositive() &&
                b.nb$nonzero() &&
                (b = b.nb$add(a).nb$remainder(a))
              : a.nb$isnegative() && b.nb$nonzero() && (b = b.nb$add(a)),
            b)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_remainder = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? a.nb$remainder(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$inplace_remainder =
        self.Sk.builtin.lng.prototype.nb$remainder
      self.Sk.builtin.lng.prototype.nb$divmod = function(a) {
        a === self.Sk.builtin.bool.true$ && (a = new self.Sk.builtin.lng(1))
        a === self.Sk.builtin.bool.false$ && (a = new self.Sk.builtin.lng(0))
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        if (a instanceof self.Sk.builtin.lng)
          return new self.Sk.builtin.tuple([
            this.nb$floor_divide(a),
            this.nb$remainder(a),
          ])
        if (a instanceof self.Sk.builtin.float_) {
          var b = new self.Sk.builtin.float_(this.str$(10, !0))
          return b.nb$divmod(a)
        }
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$power = function(a, b) {
        if (void 0 !== b)
          return (
            (a = new self.Sk.builtin.biginteger(self.Sk.builtin.asnum$(a))),
            (b = new self.Sk.builtin.biginteger(self.Sk.builtin.asnum$(b))),
            new self.Sk.builtin.lng(this.biginteger.modPowInt(a, b))
          )
        if (
          a instanceof self.Sk.builtin.float_ ||
          (a instanceof self.Sk.builtin.int_ && 0 > a.v)
        )
          return (b = new self.Sk.builtin.float_(this.str$(10, !0))), b.nb$power(a)
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? void 0 !== b
            ? ((a = new self.Sk.builtin.biginteger(self.Sk.builtin.asnum$(a))),
              (b = new self.Sk.builtin.biginteger(self.Sk.builtin.asnum$(b))),
              new self.Sk.builtin.lng(this.biginteger.modPowInt(a, b)))
            : a.nb$isnegative()
            ? ((b = new self.Sk.builtin.float_(this.str$(10, !0))), b.nb$power(a))
            : new self.Sk.builtin.lng(this.biginteger.pow(a.biginteger))
          : a instanceof self.Sk.builtin.biginteger
          ? void 0 !== b
            ? ((b = new self.Sk.builtin.biginteger(self.Sk.builtin.asnum$(b))),
              new self.Sk.builtin.lng(this.biginteger.modPowInt(a, b)))
            : a.isnegative()
            ? ((b = new self.Sk.builtin.float_(this.str$(10, !0))), b.nb$power(a))
            : new self.Sk.builtin.lng(this.biginteger.pow(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_power = function(a, b) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? a.nb$power(this, b)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$inplace_power =
        self.Sk.builtin.lng.prototype.nb$power
      self.Sk.builtin.lng.prototype.nb$abs = function() {
        return new self.Sk.builtin.lng(this.biginteger.bnAbs())
      }
      self.Sk.builtin.lng.prototype.nb$lshift = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        if (a instanceof self.Sk.builtin.lng) {
          if (0 > a.biginteger.signum())
            throw new self.Sk.builtin.ValueError("negative shift count")
          return new self.Sk.builtin.lng(this.biginteger.shiftLeft(a.biginteger))
        }
        if (a instanceof self.Sk.builtin.biginteger) {
          if (0 > a.signum())
            throw new self.Sk.builtin.ValueError("negative shift count")
          return new self.Sk.builtin.lng(this.biginteger.shiftLeft(a))
        }
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_lshift = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? a.nb$lshift(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$inplace_lshift =
        self.Sk.builtin.lng.prototype.nb$lshift
      self.Sk.builtin.lng.prototype.nb$rshift = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        if (a instanceof self.Sk.builtin.lng) {
          if (0 > a.biginteger.signum())
            throw new self.Sk.builtin.ValueError("negative shift count")
          return new self.Sk.builtin.lng(this.biginteger.shiftRight(a.biginteger))
        }
        if (a instanceof self.Sk.builtin.biginteger) {
          if (0 > a.signum())
            throw new self.Sk.builtin.ValueError("negative shift count")
          return new self.Sk.builtin.lng(this.biginteger.shiftRight(a))
        }
        return self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_rshift = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? a.nb$rshift(this)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$inplace_rshift =
        self.Sk.builtin.lng.prototype.nb$rshift
      self.Sk.builtin.lng.prototype.nb$and = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.lng(this.biginteger.and(a.biginteger))
          : a instanceof self.Sk.builtin.biginteger
          ? new self.Sk.builtin.lng(this.biginteger.and(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_and =
        self.Sk.builtin.lng.prototype.nb$and
      self.Sk.builtin.lng.prototype.nb$inplace_and = self.Sk.builtin.lng.prototype.nb$and
      self.Sk.builtin.lng.prototype.nb$or = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.lng(this.biginteger.or(a.biginteger))
          : a instanceof self.Sk.builtin.biginteger
          ? new self.Sk.builtin.lng(this.biginteger.or(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_or = self.Sk.builtin.lng.prototype.nb$or
      self.Sk.builtin.lng.prototype.nb$inplace_or = self.Sk.builtin.lng.prototype.nb$or
      self.Sk.builtin.lng.prototype.nb$xor = function(a) {
        a instanceof self.Sk.builtin.int_ && (a = new self.Sk.builtin.lng(a.v))
        return a instanceof self.Sk.builtin.lng
          ? new self.Sk.builtin.lng(this.biginteger.xor(a.biginteger))
          : a instanceof self.Sk.builtin.biginteger
          ? new self.Sk.builtin.lng(this.biginteger.xor(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.nb$reflected_xor =
        self.Sk.builtin.lng.prototype.nb$xor
      self.Sk.builtin.lng.prototype.nb$inplace_xor = self.Sk.builtin.lng.prototype.nb$xor
      self.Sk.builtin.lng.prototype.nb$negative = function() {
        return new self.Sk.builtin.lng(this.biginteger.negate())
      }
      self.Sk.builtin.lng.prototype.nb$invert = function() {
        return new self.Sk.builtin.lng(this.biginteger.not())
      }
      self.Sk.builtin.lng.prototype.nb$positive = function() {
        return this.clone()
      }
      self.Sk.builtin.lng.prototype.nb$nonzero = function() {
        return 0 !== this.biginteger.trueCompare(self.Sk.builtin.biginteger.ZERO)
      }
      self.Sk.builtin.lng.prototype.nb$isnegative = function() {
        return this.biginteger.isnegative()
      }
      self.Sk.builtin.lng.prototype.nb$ispositive = function() {
        return !this.biginteger.isnegative()
      }
      self.Sk.builtin.lng.prototype.longCompare = function(a) {
        "number" === typeof a && (a = new self.Sk.builtin.lng(a))
        if (
          a instanceof self.Sk.builtin.int_ ||
          (a instanceof self.Sk.builtin.float_ && 0 === a.v % 1)
        )
          return (a = new self.Sk.builtin.lng(a.v)), this.longCompare(a)
        if (a instanceof self.Sk.builtin.float_) {
          var b = new self.Sk.builtin.float_(this)
          return b.numberCompare(a)
        }
        return a instanceof self.Sk.builtin.lng
          ? this.biginteger.subtract(a.biginteger)
          : a instanceof self.Sk.builtin.biginteger
          ? this.biginteger.subtract(a)
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.ob$eq = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 == this.longCompare(a))
          : a instanceof self.Sk.builtin.none
          ? self.Sk.builtin.bool.false$
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.ob$ne = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 != this.longCompare(a))
          : a instanceof self.Sk.builtin.none
          ? self.Sk.builtin.bool.true$
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.ob$lt = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 > this.longCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.ob$le = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 >= this.longCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.ob$gt = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 < this.longCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.ob$ge = function(a) {
        return a instanceof self.Sk.builtin.int_ ||
          a instanceof self.Sk.builtin.lng ||
          a instanceof self.Sk.builtin.float_
          ? new self.Sk.builtin.bool(0 <= this.longCompare(a))
          : self.Sk.builtin.NotImplemented.NotImplemented$
      }
      self.Sk.builtin.lng.prototype.$r = function() {
        var a = self.Sk.__future__.python3 ? "" : "L"
        return new self.Sk.builtin.str(this.str$(10, !0) + a)
      }
      self.Sk.builtin.lng.prototype.tp$str = function() {
        return new self.Sk.builtin.str(this.str$(10, !0))
      }
      self.Sk.builtin.lng.prototype.str$ = function(a, b) {
        void 0 === b && (b = !0)
        b = b ? this.biginteger : this.biginteger.abs()
        return void 0 === a || 10 === a ? b.toString() : b.toString(a)
      }
    },
    function(m, p) {
      Math.hypot =
        Math.hypot ||
        function() {
          for (var a = 0, b = arguments.length, c = 0; c < b; c++) {
            if (Infinity === arguments[c] || -Infinity === arguments[c])
              return Infinity
            a += arguments[c] * arguments[c]
          }
          return Math.sqrt(a)
        }
      self.Sk.builtin.complex = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("complex", arguments.length, 0, 2)
        var c,
          d = !1,
          e = !1
        if (!(this instanceof self.Sk.builtin.complex))
          return new self.Sk.builtin.complex(a, b)
        var f = null == a ? self.Sk.builtin.bool.false$ : a
        if (f instanceof self.Sk.builtin.complex && null == b) return a
        if (null != f && self.Sk.builtin.checkString(f)) {
          if (null != b)
            throw new self.Sk.builtin.TypeError(
              "complex() can't take second arg if first is a string",
            )
          return self.Sk.builtin.complex.complex_subtype_from_string(f)
        }
        if (null != b && self.Sk.builtin.checkString(b))
          throw new self.Sk.builtin.TypeError(
            "complex() second arg can't be a string",
          )
        var g = self.Sk.builtin.complex.try_complex_special_method(f)
        if (null != g && g !== self.Sk.builtin.NotImplemented.NotImplemented$) {
          if (!self.Sk.builtin.checkComplex(g))
            throw new self.Sk.builtin.TypeError(
              "__complex__ should return a complex object",
            )
          f = g
        }
        g = self.Sk.builtin.asnum$(f)
        null != b && (c = self.Sk.builtin.asnum$(b))
        var h = function(a) {
          if (
            self.Sk.builtin.checkNumber(a) ||
            void 0 !==
              self.Sk.builtin.type.typeLookup(a.ob$type, self.Sk.builtin.str.$float_)
          )
            return !0
        }
        if (
          null == g ||
          (!h(f) && !self.Sk.builtin.checkComplex(f)) ||
          (null != b && (null == c || (!h(b) && !self.Sk.builtin.checkComplex(b))))
        )
          throw new self.Sk.builtin.TypeError(
            "complex() argument must be a string or number",
          )
        if (self.Sk.builtin.complex._complex_check(f))
          (c = f.real.v), (f = f.imag.v), (d = !0)
        else {
          g = self.Sk.builtin.float_.PyFloat_AsDouble(f)
          if (null == g) return null
          c = g
          f = 0
        }
        if (null == b) g = 0
        else if (self.Sk.builtin.complex._complex_check(b)) {
          g = b.real.v
          var k = b.imag.v
          e = !0
        } else {
          g = self.Sk.builtin.float_.PyFloat_AsDouble(b)
          if (null == g) return null
          k = 0
        }
        !0 === e && (c -= k)
        !0 === d && (g += f)
        0 === c && (0 > g || self.Sk.builtin.complex._isNegativeZero(g)) && (c = -0)
        this.real = new self.Sk.builtin.float_(c)
        this.imag = new self.Sk.builtin.float_(g)
        return this
      }
      self.Sk.abstr.setUpInheritance(
        "complex",
        self.Sk.builtin.complex,
        self.Sk.builtin.numtype,
      )
      self.Sk.builtin.complex.prototype.__class__ = self.Sk.builtin.complex
      self.Sk.builtin.complex.prototype.nb$int_ = function() {
        throw new self.Sk.builtin.TypeError("can't convert complex to int")
      }
      self.Sk.builtin.complex.prototype.nb$float_ = function() {
        throw new self.Sk.builtin.TypeError("can't convert complex to float")
      }
      self.Sk.builtin.complex.prototype.nb$lng = function() {
        throw new self.Sk.builtin.TypeError("can't convert complex to long")
      }
      self.Sk.builtin.complex.prototype.__doc__ = new self.Sk.builtin.str(
        "complex(real[, imag]) -> complex number\n\nCreate a complex number from a real part and an optional imaginary part.\nThis is equivalent to (real + imag*1j) where imag defaults to 0.",
      )
      self.Sk.builtin.complex._isNegativeZero = function(a) {
        return 0 !== a ? !1 : -Infinity === 1 / a
      }
      self.Sk.builtin.complex.try_complex_special_method = function(a) {
        if (null == a) return null
        var b = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$complex)
        return null != b ? (a = self.Sk.misceval.callsimArray(b, [a])) : null
      }
      self.Sk.builtin.complex.check_number_or_complex = function(a) {
        if (!self.Sk.builtin.checkNumber(a) && "complex" !== a.tp$name)
          throw new self.Sk.builtin.TypeError(
            "unsupported operand type(s) for +: 'complex' and '" +
              self.Sk.abstr.typeName(a) +
              "'",
          )
        self.Sk.builtin.checkNumber(a) && (a = new self.Sk.builtin.complex(a))
        return a
      }
      self.Sk.builtin.complex.complex_subtype_from_string = function(a) {
        var b = 0,
          c = 0,
          d = !1
        if (self.Sk.builtin.checkString(a)) a = self.Sk.ffi.remapToJs(a)
        else if ("string" !== typeof a)
          throw new TypeError("provided unsupported string-alike argument")
        if (-1 !== a.indexOf("\x00") || 0 === a.length || "" === a)
          throw new self.Sk.builtin.ValueError("complex() arg is a malformed string")
        var e = 0
        a = a.replace(/inf|infinity/gi, "Infinity")
        for (a = a.replace(/nan/gi, "NaN"); " " === a[e]; ) e++
        if ("(" === a[e]) for (d = !0, e++; " " === a[e]; ) e++
        var f = /^(?:[+-]?(?:(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[eE][+-]?\d+)?|NaN|Infinity))/
        var g = a.substr(e)
        var h = g.match(f)
        if (null !== h)
          if (((e += h[0].length), "j" === a[e] || "J" === a[e]))
            (c = parseFloat(h[0])), e++
          else if ("+" === a[e] || "-" === a[e]) {
            b = parseFloat(h[0])
            h = a.substr(e).match(f)
            null !== h
              ? ((c = parseFloat(h[0])), (e += h[0].length))
              : ((c = "+" === a[e] ? 1 : -1), e++)
            if ("j" !== a[e] && "J" !== a[e])
              throw new self.Sk.builtin.ValueError(
                "complex() arg is malformed string",
              )
            e++
          } else b = parseFloat(h[0])
        else
          (h = h = g.match(/^([+-]?[jJ])/)),
            null !== h &&
              ((c = 1 === h[0].length ? 1 : "+" === h[0][0] ? 1 : -1),
              (e += h[0].length))
        for (; " " === a[e]; ) e++
        if (d) {
          if (")" !== a[e])
            throw new self.Sk.builtin.ValueError("complex() arg is malformed string")
          for (e++; " " === a[e]; ) e++
        }
        if (a.length !== e)
          throw new self.Sk.builtin.ValueError("complex() arg is malformed string")
        return new self.Sk.builtin.complex(
          new self.Sk.builtin.float_(b),
          new self.Sk.builtin.float_(c),
        )
      }
      self.Sk.builtin.complex.prototype.tp$hash = function() {
        return new self.Sk.builtin.int_(
          1000003 * this.tp$getattr(self.Sk.builtin.str.$imag).v +
            this.tp$getattr(self.Sk.builtin.str.$real).v,
        )
      }
      self.Sk.builtin.complex.prototype.nb$add = function(a) {
        a = self.Sk.builtin.complex.check_number_or_complex(a)
        var b =
          this.tp$getattr(self.Sk.builtin.str.$real).v +
          a.tp$getattr(self.Sk.builtin.str.$real).v
        a =
          this.tp$getattr(self.Sk.builtin.str.$imag).v +
          a.tp$getattr(self.Sk.builtin.str.$imag).v
        return new self.Sk.builtin.complex(
          new self.Sk.builtin.float_(b),
          new self.Sk.builtin.float_(a),
        )
      }
      self.Sk.builtin.complex._c_diff = function(a, b) {
        var c = a.real.nb$subtract.call(a.real, b.real)
        a = a.imag.nb$subtract.call(a.imag, b.imag)
        return new self.Sk.builtin.complex(c, a)
      }
      self.Sk.builtin.complex.prototype.nb$subtract = function(a) {
        var b = self.Sk.builtin.complex.check_number_or_complex(this)
        a = self.Sk.builtin.complex.check_number_or_complex(a)
        return self.Sk.builtin.complex._c_diff(b, a)
      }
      self.Sk.builtin.complex.prototype.nb$multiply = function(a) {
        var b = self.Sk.builtin.complex.check_number_or_complex(a)
        a = this.real.v * b.real.v - this.imag.v * b.imag.v
        b = this.real.v * b.imag.v + this.imag.v * b.real.v
        return new self.Sk.builtin.complex(
          new self.Sk.builtin.float_(a),
          new self.Sk.builtin.float_(b),
        )
      }
      self.Sk.builtin.complex.prototype.nb$divide = function(a) {
        a = self.Sk.builtin.complex.check_number_or_complex(a)
        var b = a.real.v
        var c = a.imag.v
        a = this.real.v
        var d = this.imag.v
        var e = Math.abs(b)
        var f = Math.abs(c)
        if (e >= f) {
          if (0 === e)
            throw new self.Sk.builtin.ZeroDivisionError("complex division by zero")
          e = c / b
          f = b + c * e
          b = (a + d * e) / f
          a = (d - a * e) / f
        } else
          f >= e
            ? ((e = b / c),
              (f = b * e + c),
              self.Sk.asserts.assert(0 !== c),
              (b = (a * e + d) / f),
              (a = (d * e - a) / f))
            : (a = b = NaN)
        return new self.Sk.builtin.complex(
          new self.Sk.builtin.float_(b),
          new self.Sk.builtin.float_(a),
        )
      }
      self.Sk.builtin.complex.prototype.nb$floor_divide = function(a) {
        throw new self.Sk.builtin.TypeError("can't take floor of complex number.")
      }
      self.Sk.builtin.complex.prototype.nb$remainder = function(a) {
        throw new self.Sk.builtin.TypeError("can't mod complex numbers.")
      }
      self.Sk.builtin.complex.prototype.nb$power = function(a, b) {
        if (null != b && !self.Sk.builtin.checkNone(b))
          throw new self.Sk.builtin.ValueError("complex modulo")
        b = self.Sk.builtin.complex.check_number_or_complex(a)
        a = b.real.v | 0
        return 0 === b.imag.v && b.real.v === a
          ? self.Sk.builtin.complex.c_powi(this, a)
          : self.Sk.builtin.complex.c_pow(this, b)
      }
      self.Sk.builtin.complex.c_pow = function(a, b) {
        var c = b.real.v
        b = b.imag.v
        var d = a.real.v
        var e = a.imag.v
        if (0 === c && 0 === b) (b = 1), (a = 0)
        else if (0 === d && 0 === e) {
          if (0 !== b || 0 > c)
            throw new self.Sk.builtin.ZeroDivisionError("complex division by zero")
          a = b = 0
        } else {
          var f = Math.hypot(d, e)
          a = Math.pow(f, c)
          d = Math.atan2(e, d)
          c *= d
          0 !== b && ((a /= Math.exp(d * b)), (c += b * Math.log(f)))
          b = a * Math.cos(c)
          a *= Math.sin(c)
        }
        return new self.Sk.builtin.complex(
          new self.Sk.builtin.float_(b),
          new self.Sk.builtin.float_(a),
        )
      }
      self.Sk.builtin.complex.c_powi = function(a, b) {
        return 100 < b || -100 > b
          ? ((b = new self.Sk.builtin.complex(
              new self.Sk.builtin.float_(b),
              new self.Sk.builtin.float_(0),
            )),
            self.Sk.builtin.complex.c_pow(a, b))
          : 0 < b
          ? self.Sk.builtin.complex.c_powu(a, b)
          : new self.Sk.builtin.complex(
              new self.Sk.builtin.float_(1),
              new self.Sk.builtin.float_(0),
            ).nb$divide(self.Sk.builtin.complex.c_powu(a, -b))
      }
      self.Sk.builtin.complex.c_powu = function(a, b) {
        var c,
          d = 1
        for (
          c = new self.Sk.builtin.complex(
            new self.Sk.builtin.float_(1),
            new self.Sk.builtin.float_(0),
          );
          0 < d && b >= d;

        )
          b & d && (c = c.nb$multiply(a)), (d <<= 1), (a = a.nb$multiply(a))
        return c
      }
      self.Sk.builtin.complex.prototype.nb$inplace_add =
        self.Sk.builtin.complex.prototype.nb$add
      self.Sk.builtin.complex.prototype.nb$inplace_subtract =
        self.Sk.builtin.complex.prototype.nb$subtract
      self.Sk.builtin.complex.prototype.nb$inplace_multiply =
        self.Sk.builtin.complex.prototype.nb$multiply
      self.Sk.builtin.complex.prototype.nb$inplace_divide =
        self.Sk.builtin.complex.prototype.nb$divide
      self.Sk.builtin.complex.prototype.nb$inplace_remainder =
        self.Sk.builtin.complex.prototype.nb$remainder
      self.Sk.builtin.complex.prototype.nb$inplace_floor_divide =
        self.Sk.builtin.complex.prototype.nb$floor_divide
      self.Sk.builtin.complex.prototype.nb$inplace_power =
        self.Sk.builtin.complex.prototype.nb$power
      self.Sk.builtin.complex.prototype.nb$negative = function() {
        var a = this.real.v
        var b = -this.imag.v
        return new self.Sk.builtin.complex(
          new self.Sk.builtin.float_(-a),
          new self.Sk.builtin.float_(b),
        )
      }
      self.Sk.builtin.complex.prototype.nb$positive = function() {
        return self.Sk.builtin.complex.check_number_or_complex(this)
      }
      self.Sk.builtin.complex._complex_check = function(a) {
        return void 0 === a
          ? !1
          : a instanceof self.Sk.builtin.complex ||
            (a.tp$name && "complex" === a.tp$name) ||
            self.Sk.builtin.issubclass(new self.Sk.builtin.type(a), self.Sk.builtin.complex)
          ? !0
          : !1
      }
      self.Sk.builtin.complex.prototype.tp$richcompare = function(a, b) {
        if ("Eq" !== b && "NotEq" !== b) {
          if (self.Sk.builtin.checkNumber(a) || self.Sk.builtin.complex._complex_check(a))
            throw new self.Sk.builtin.TypeError(
              "no ordering relation is defined for complex numbers",
            )
          return self.Sk.builtin.NotImplemented.NotImplemented$
        }
        var c = self.Sk.builtin.complex.check_number_or_complex(this)
        var d = c.tp$getattr(self.Sk.builtin.str.$real).v
        c = c.tp$getattr(self.Sk.builtin.str.$imag).v
        if (self.Sk.builtin.checkInt(a)) {
          if (0 === c)
            return (
              (d = self.Sk.misceval.richCompareBool(new self.Sk.builtin.float_(d), a, b)),
              (b = new self.Sk.builtin.bool(d))
            )
          d = !1
        } else if (self.Sk.builtin.checkFloat(a))
          d = d === self.Sk.builtin.float_.PyFloat_AsDouble(a) && 0 === c
        else if (self.Sk.builtin.complex._complex_check(a)) {
          var e = a.tp$getattr(self.Sk.builtin.str.$real).v
          a = a.tp$getattr(self.Sk.builtin.str.$imag).v
          d = d === e && c === a
        } else return self.Sk.builtin.NotImplemented.NotImplemented$
        "NotEq" === b && (d = !d)
        return (b = new self.Sk.builtin.bool(d))
      }
      self.Sk.builtin.complex.prototype.__eq__ = function(a, b) {
        return self.Sk.builtin.complex.prototype.tp$richcompare.call(a, b, "Eq")
      }
      self.Sk.builtin.complex.prototype.__ne__ = function(a, b) {
        return self.Sk.builtin.complex.prototype.tp$richcompare.call(a, b, "NotEq")
      }
      self.Sk.builtin.complex.prototype.__lt__ = function(a, b) {
        throw new self.Sk.builtin.TypeError(
          "unorderable types: " +
            self.Sk.abstr.typeName(a) +
            " < " +
            self.Sk.abstr.typeName(b),
        )
      }
      self.Sk.builtin.complex.prototype.__le__ = function(a, b) {
        throw new self.Sk.builtin.TypeError(
          "unorderable types: " +
            self.Sk.abstr.typeName(a) +
            " <= " +
            self.Sk.abstr.typeName(b),
        )
      }
      self.Sk.builtin.complex.prototype.__gt__ = function(a, b) {
        throw new self.Sk.builtin.TypeError(
          "unorderable types: " +
            self.Sk.abstr.typeName(a) +
            " > " +
            self.Sk.abstr.typeName(b),
        )
      }
      self.Sk.builtin.complex.prototype.__ge__ = function(a, b) {
        throw new self.Sk.builtin.TypeError(
          "unorderable types: " +
            self.Sk.abstr.typeName(a) +
            " >= " +
            self.Sk.abstr.typeName(b),
        )
      }
      self.Sk.builtin.complex.prototype.__float__ = function(a) {
        throw new self.Sk.builtin.TypeError("can't convert complex to float")
      }
      self.Sk.builtin.complex.prototype.__int__ = function(a) {
        throw new self.Sk.builtin.TypeError("can't convert complex to int")
      }
      self.Sk.builtin.complex.prototype._internalGenericGetAttr =
        self.Sk.builtin.object.prototype.GenericGetAttr
      self.Sk.builtin.complex.prototype.tp$getattr = function(a) {
        if (null != a && (self.Sk.builtin.checkString(a) || "string" === typeof a)) {
          var b = a
          self.Sk.builtin.checkString(a) && (b = self.Sk.ffi.remapToJs(a))
          if ("real" === b || "imag" === b) return this[b]
        }
        return this._internalGenericGetAttr(a)
      }
      self.Sk.builtin.complex.prototype.tp$setattr = function(a, b) {
        if (
          null != a &&
          (self.Sk.builtin.checkString(a) || "string" === typeof a) &&
          ((b = a),
          self.Sk.builtin.checkString(a) && (b = self.Sk.ffi.remapToJs(a)),
          "real" === b || "imag" === b)
        )
          throw new self.Sk.builtin.AttributeError("readonly attribute")
        throw new self.Sk.builtin.AttributeError(
          "'complex' object attribute '" + a + "' is readonly",
        )
      }
      self.Sk.builtin.complex.complex_format = function(a, b, c) {
        if (null == a || !self.Sk.builtin.complex._complex_check(a))
          throw Error(
            "Invalid internal method call: self.Sk.complex.complex_format() called with invalid value type.",
          )
        var d = "",
          e = ""
        if (0 === a.real.v && 1 == (0 > a.real.v ? -1 : 1)) {
          var f = ""
          b = self.Sk.builtin.complex.PyOS_double_to_string(a.imag.v, c, b, 0, null)
        } else
          (f = self.Sk.builtin.complex.PyOS_double_to_string(
            a.real.v,
            c,
            b,
            0,
            null,
          )),
            (b = self.Sk.builtin.complex.PyOS_double_to_string(
              a.imag.v,
              c,
              b,
              self.Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_SIGN,
              null,
            )),
            0 === a.imag.v &&
              -Infinity === 1 / a.imag.v &&
              b &&
              "-" !== b[0] &&
              (b = "-" + b),
            (d = "("),
            (e = ")")
        return new self.Sk.builtin.str("" + d + f + b + "j" + e)
      }
      self.Sk.builtin.complex.prototype.$r = function() {
        return self.Sk.builtin.complex.complex_format(this, 0, "r")
      }
      self.Sk.builtin.complex.prototype.tp$str = function() {
        return self.Sk.builtin.complex.complex_format(this, null, "g")
      }
      self.Sk.builtin.complex.prototype.int$format = function(a, b) {
        if (null == b) return null
        if (self.Sk.builtin.checkString(b))
          return (a = self.Sk.builtin.complex._PyComplex_FormatAdvanced(a, b))
        throw new self.Sk.builtin.TypeError("__format__ requires str or unicode")
      }
      self.Sk.builtin.complex.prototype.int$format.co_name = new self.Sk.builtin.str(
        "__format__",
      )
      self.Sk.builtin.complex.prototype.__format__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$format,
      )
      self.Sk.builtin.complex._PyComplex_FormatAdvanced = function(a, b) {
        throw new self.Sk.builtin.NotImplementedError(
          "__format__ is not implemented for complex type.",
        )
      }
      self.Sk.builtin.complex._is_finite = function(a) {
        return !isNaN(a) && Infinity !== a && -Infinity !== a
      }
      self.Sk.builtin.complex._is_infinity = function(a) {
        return Infinity === a || -Infinity === a
      }
      self.Sk.builtin.complex.prototype.int$abs = function(a) {
        var b = a.real.v
        a = a.imag.v
        if (
          !self.Sk.builtin.complex._is_finite(b) ||
          !self.Sk.builtin.complex._is_finite(a)
        )
          return self.Sk.builtin.complex._is_infinity(b)
            ? ((b = Math.abs(b)), new self.Sk.builtin.float_(b))
            : self.Sk.builtin.complex._is_infinity(a)
            ? ((b = Math.abs(a)), new self.Sk.builtin.float_(b))
            : new self.Sk.builtin.float_(NaN)
        b = Math.hypot(b, a)
        if (!self.Sk.builtin.complex._is_finite(b))
          throw new self.Sk.builtin.OverflowError("absolute value too large")
        return new self.Sk.builtin.float_(b)
      }
      self.Sk.builtin.complex.prototype.int$abs.co_name = new self.Sk.builtin.str(
        "__abs__",
      )
      self.Sk.builtin.complex.prototype.__abs__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$abs,
      )
      self.Sk.builtin.complex.prototype.int$bool = function(a) {
        return new self.Sk.builtin.bool(
          a.tp$getattr(self.Sk.builtin.str.$real).v ||
            a.tp$getattr(self.Sk.builtin.str.$real).v,
        )
      }
      self.Sk.builtin.complex.prototype.int$bool.co_name = new self.Sk.builtin.str(
        "__bool__",
      )
      self.Sk.builtin.complex.prototype.__bool__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$bool,
      )
      self.Sk.builtin.complex.prototype.int$truediv = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__truediv__", arguments.length, 1, 1, !0)
        return a.nb$divide.call(a, b)
      }
      self.Sk.builtin.complex.prototype.int$truediv.co_name = new self.Sk.builtin.str(
        "__truediv__",
      )
      self.Sk.builtin.complex.prototype.__truediv__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$truediv,
      )
      self.Sk.builtin.complex.prototype.int$hash = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__hash__", arguments.length, 0, 0, !0)
        return a.tp$hash.call(a)
      }
      self.Sk.builtin.complex.prototype.int$hash.co_name = new self.Sk.builtin.str(
        "__hash__",
      )
      self.Sk.builtin.complex.prototype.__hash__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$hash,
      )
      self.Sk.builtin.complex.prototype.int$add = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__add__", arguments.length, 1, 1, !0)
        return a.nb$add.call(a, b)
      }
      self.Sk.builtin.complex.prototype.int$add.co_name = new self.Sk.builtin.str(
        "__add__",
      )
      self.Sk.builtin.complex.prototype.__add__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$add,
      )
      self.Sk.builtin.complex.prototype.int$repr = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__repr__", arguments.length, 0, 0, !0)
        return a.r$.call(a)
      }
      self.Sk.builtin.complex.prototype.int$repr.co_name = new self.Sk.builtin.str(
        "__repr__",
      )
      self.Sk.builtin.complex.prototype.__repr__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$repr,
      )
      self.Sk.builtin.complex.prototype.int$str = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__str__", arguments.length, 0, 0, !0)
        return a.tp$str.call(a)
      }
      self.Sk.builtin.complex.prototype.int$str.co_name = new self.Sk.builtin.str(
        "__str__",
      )
      self.Sk.builtin.complex.prototype.__str__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$str,
      )
      self.Sk.builtin.complex.prototype.int$sub = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__sub__", arguments.length, 1, 1, !0)
        return a.nb$subtract.call(a, b)
      }
      self.Sk.builtin.complex.prototype.int$sub.co_name = new self.Sk.builtin.str(
        "__sub__",
      )
      self.Sk.builtin.complex.prototype.__sub__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$sub,
      )
      self.Sk.builtin.complex.prototype.int$mul = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__mul__", arguments.length, 1, 1, !0)
        return a.nb$multiply.call(a, b)
      }
      self.Sk.builtin.complex.prototype.int$mul.co_name = new self.Sk.builtin.str(
        "__mul__",
      )
      self.Sk.builtin.complex.prototype.__mul__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$mul,
      )
      self.Sk.builtin.complex.prototype.int$div = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__div__", arguments.length, 1, 1, !0)
        return a.nb$divide.call(a, b)
      }
      self.Sk.builtin.complex.prototype.int$div.co_name = new self.Sk.builtin.str(
        "__div__",
      )
      self.Sk.builtin.complex.prototype.__div__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$div,
      )
      self.Sk.builtin.complex.prototype.int$floordiv = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__floordiv__", arguments.length, 1, 1, !0)
        return a.nb$floor_divide.call(a, b)
      }
      self.Sk.builtin.complex.prototype.int$floordiv.co_name = new self.Sk.builtin.str(
        "__floordiv__",
      )
      self.Sk.builtin.complex.prototype.__floordiv__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$floordiv,
      )
      self.Sk.builtin.complex.prototype.int$mod = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__mod__", arguments.length, 1, 1, !0)
        return a.nb$remainder.call(a, b)
      }
      self.Sk.builtin.complex.prototype.int$mod.co_name = new self.Sk.builtin.str(
        "__mod__",
      )
      self.Sk.builtin.complex.prototype.__mod__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$mod,
      )
      self.Sk.builtin.complex.prototype.int$pow = function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("__pow__", arguments.length, 1, 2, !0)
        return a.nb$power.call(a, b, c)
      }
      self.Sk.builtin.complex.prototype.int$pow.co_name = new self.Sk.builtin.str(
        "__pow__",
      )
      self.Sk.builtin.complex.prototype.__pow__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$pow,
      )
      self.Sk.builtin.complex.prototype.int$neg = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__neg__", arguments.length, 0, 0, !0)
        return a.nb$negative.call(a)
      }
      self.Sk.builtin.complex.prototype.__neg__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$neg,
      )
      self.Sk.builtin.complex.prototype.int$pos = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__pos__", arguments.length, 0, 0, !0)
        return a.nb$positive.call(a)
      }
      self.Sk.builtin.complex.prototype.int$pos.co_name = new self.Sk.builtin.str(
        "__pos__",
      )
      self.Sk.builtin.complex.prototype.__pos__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$pos,
      )
      self.Sk.builtin.complex.prototype.int$conjugate = function(a) {
        self.Sk.builtin.pyCheckArgsLen("conjugate", arguments.length, 0, 0, !0)
        return new self.Sk.builtin.complex(a.real, new self.Sk.builtin.float_(-a.imag.v))
      }
      self.Sk.builtin.complex.prototype.int$conjugate.co_name = new self.Sk.builtin.str(
        "conjugate",
      )
      self.Sk.builtin.complex.prototype.conjugate = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$conjugate,
      )
      self.Sk.builtin.complex.prototype.int$divmod = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("__divmod__", arguments.length, 1, 1, !0)
        var c = self.Sk.builtin.complex.check_number_or_complex(a)
        var d = self.Sk.builtin.complex.check_number_or_complex(b)
        var e = c.nb$divide.call(c, d)
        e.real = new self.Sk.builtin.float_(Math.floor(e.real.v))
        e.imag = new self.Sk.builtin.float_(0)
        c = c.nb$subtract.call(c, d.nb$multiply.call(d, e))
        return new self.Sk.builtin.tuple([e, c])
      }
      self.Sk.builtin.complex.prototype.int$divmod.co_name = new self.Sk.builtin.str(
        "__divmod__",
      )
      self.Sk.builtin.complex.prototype.__divmod__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$divmod,
      )
      self.Sk.builtin.complex.prototype.int$getnewargs = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__getnewargs__", arguments.length, 0, 0, !0)
        return new self.Sk.builtin.tuple([a.real, a.imag])
      }
      self.Sk.builtin.complex.prototype.int$getnewargs.co_name = new self.Sk.builtin.str(
        "__getnewargs__",
      )
      self.Sk.builtin.complex.prototype.__getnewargs__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$getnewargs,
      )
      self.Sk.builtin.complex.prototype.int$nonzero = function(a) {
        self.Sk.builtin.pyCheckArgsLen("__nonzero__", arguments.length, 0, 0, !0)
        return 0 !== a.real.v || 0 !== a.imag.v
          ? self.Sk.builtin.bool.true$
          : self.Sk.builtin.bool.false$
      }
      self.Sk.builtin.complex.prototype.int$nonzero.co_name = new self.Sk.builtin.str(
        "__nonzero__",
      )
      self.Sk.builtin.complex.prototype.__nonzero__ = new self.Sk.builtin.func(
        self.Sk.builtin.complex.prototype.int$nonzero,
      )
      self.Sk.exportSymbol("Sk.builtin.complex", self.Sk.builtin.complex)
      self.Sk.builtin.complex.PyOS_double_to_string = function(a, b, c, d, e) {
        e = !1
        switch (b) {
          case "e":
          case "f":
          case "g":
            break
          case "E":
            e = !0
            b = "e"
            break
          case "F":
            e = !0
            b = "f"
            break
          case "r":
            if (0 !== c) throw Error("Bad internall call")
            c = 17
            b = "g"
            break
          default:
            throw Error("Bad internall call")
        }
        if (isNaN(a)) a = "nan"
        else if (Infinity === a) a = "inf"
        else if (-Infinity === a) a = "-inf"
        else {
          d & self.Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_ADD_DOT_0 &&
            (b = "g")
          var f =
            "%" +
            (d & self.Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_ALT
              ? "#"
              : "")
          null != c && (f = f + "." + c)
          f = new self.Sk.builtin.str(f + b)
          a = f.nb$remainder(new self.Sk.builtin.float_(a))
          a = a.v
        }
        d & self.Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_SIGN &&
          "-" !== a[0] &&
          (a = "+" + a)
        e && (a = a.toUpperCase())
        return a
      }
      self.Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_SIGN = 1
      self.Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_ADD_DOT_0 = 2
      self.Sk.builtin.complex.PyOS_double_to_string.Py_DTSF_ALT = 4
      self.Sk.builtin.complex.PyOS_double_to_string.Py_DTST_FINITE = 0
      self.Sk.builtin.complex.PyOS_double_to_string.Py_DTST_INFINITE = 1
      self.Sk.builtin.complex.PyOS_double_to_string.Py_DTST_NAN = 2
    },
    function(m, p) {
      self.Sk.builtin.slice = function(a, b, c) {
        self.Sk.builtin.pyCheckArgsLen("slice", arguments.length, 1, 3, !1, !1)
        if (
          void 0 !== c &&
          self.Sk.misceval.isIndex(c) &&
          0 === self.Sk.misceval.asIndex(c)
        )
          throw new self.Sk.builtin.ValueError("slice step cannot be zero")
        if (!(this instanceof self.Sk.builtin.slice))
          return new self.Sk.builtin.slice(a, b, c)
        void 0 === b && void 0 === c && ((b = a), (a = self.Sk.builtin.none.none$))
        void 0 === b && (b = self.Sk.builtin.none.none$)
        void 0 === c && (c = self.Sk.builtin.none.none$)
        this.start = a
        this.stop = b
        this.step = c
        this.__class__ = self.Sk.builtin.slice
        this.$d = new self.Sk.builtin.dict([
          self.Sk.builtin.slice$start,
          this.start,
          self.Sk.builtin.slice$stop,
          this.stop,
          self.Sk.builtin.slice$step,
          this.step,
        ])
        return this
      }
      self.Sk.abstr.setUpInheritance("slice", self.Sk.builtin.slice, self.Sk.builtin.object)
      self.Sk.builtin.slice.prototype.$r = function() {
        var a = self.Sk.builtin.repr(this.start).v,
          b = self.Sk.builtin.repr(this.stop).v,
          c = self.Sk.builtin.repr(this.step).v
        return new self.Sk.builtin.str("slice(" + a + ", " + b + ", " + c + ")")
      }
      self.Sk.builtin.slice.prototype.tp$richcompare = function(a, b) {
        if (!a.__class__ || a.__class__ != self.Sk.builtin.slice)
          return "Eq" === b
            ? !1
            : "NotEq" === b
            ? !0
            : self.Sk.__future__.python3
            ? self.Sk.builtin.NotImplemented.NotImplemented$
            : !1
        var c = new self.Sk.builtin.tuple([this.start, this.stop, this.step])
        a = new self.Sk.builtin.tuple([a.start, a.stop, a.step])
        return c.tp$richcompare(a, b)
      }
      self.Sk.builtin.slice.prototype.slice_indices_ = function(a) {
        if (self.Sk.builtin.checkNone(this.start)) var b = null
        else if (self.Sk.misceval.isIndex(this.start))
          b = self.Sk.misceval.asIndex(this.start)
        else
          throw new self.Sk.builtin.TypeError(
            "slice indices must be integers or None",
          )
        if (self.Sk.builtin.checkNone(this.stop)) var c = null
        else if (self.Sk.misceval.isIndex(this.stop))
          c = self.Sk.misceval.asIndex(this.stop)
        else
          throw new self.Sk.builtin.TypeError(
            "slice indices must be integers or None",
          )
        if (self.Sk.builtin.checkNone(this.step)) var d = null
        else if (self.Sk.misceval.isIndex(this.step))
          d = self.Sk.misceval.asIndex(this.step)
        else
          throw new self.Sk.builtin.TypeError(
            "slice indices must be integers or None",
          )
        null === d && (d = 1)
        0 < d
          ? (null === b && (b = 0),
            null === c && (c = a),
            c > a && (c = a),
            0 > b && ((b = a + b), 0 > b && (b = 0)),
            0 > c && (c = a + c))
          : (null === b && (b = a - 1),
            b >= a && (b = a - 1),
            null === c ? (c = -1) : 0 > c && ((c = a + c), 0 > c && (c = -1)),
            0 > b && (b = a + b))
        return [b, c, d]
      }
      self.Sk.builtin.slice.prototype.indices = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("indices", arguments.length, 2, 2, !1, !1)
        b = self.Sk.builtin.asnum$(b)
        var c = a.slice_indices_(b)
        return new self.Sk.builtin.tuple([
          new self.Sk.builtin.int_(c[0]),
          new self.Sk.builtin.int_(c[1]),
          new self.Sk.builtin.int_(c[2]),
        ])
      })
      self.Sk.builtin.slice.prototype.sssiter$ = function(a, b) {
        var c = self.Sk.builtin.asnum$(a),
          d = this.slice_indices_("number" === typeof c ? c : a.v.length)
        if (0 < d[2]) for (a = d[0]; a < d[1] && !1 !== b(a, c); a += d[2]);
        else for (a = d[0]; a > d[1] && !1 !== b(a, c); a += d[2]);
      }
      self.Sk.builtin.slice$start = new self.Sk.builtin.str("start")
      self.Sk.builtin.slice$stop = new self.Sk.builtin.str("stop")
      self.Sk.builtin.slice$step = new self.Sk.builtin.str("step")
    },
    function(m, p) {
      self.Sk.builtin.set = function(a) {
        var b
        if (!(this instanceof self.Sk.builtin.set))
          return (
            self.Sk.builtin.pyCheckArgsLen("set", arguments.length, 0, 1),
            new self.Sk.builtin.set(a)
          )
        "undefined" === typeof a && (a = [])
        this.set_reset_()
        var c = new self.Sk.builtin.list(a)
        c = self.Sk.abstr.iter(c)
        for (b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
          self.Sk.builtin.set.prototype.add.func_code(this, b)
        this.__class__ = self.Sk.builtin.set
        this.v = this.v
        return this
      }
      self.Sk.abstr.setUpInheritance("set", self.Sk.builtin.set, self.Sk.builtin.object)
      self.Sk.abstr.markUnhashable(self.Sk.builtin.set)
      self.Sk.builtin.set.prototype.set_reset_ = function() {
        this.v = new self.Sk.builtin.dict([])
      }
      self.Sk.builtin.set.prototype.$r = function() {
        var a,
          b = []
        var c = self.Sk.abstr.iter(this)
        for (a = c.tp$iternext(); void 0 !== a; a = c.tp$iternext())
          b.push(self.Sk.misceval.objectRepr(a).v)
        return self.Sk.__future__.set_repr
          ? 0 === b.length
            ? new self.Sk.builtin.str("set()")
            : new self.Sk.builtin.str("{" + b.join(", ") + "}")
          : new self.Sk.builtin.str("set([" + b.join(", ") + "])")
      }
      self.Sk.builtin.set.prototype.ob$eq = function(a) {
        return this === a
          ? self.Sk.builtin.bool.true$
          : a instanceof self.Sk.builtin.set &&
            self.Sk.builtin.set.prototype.sq$length.call(this) ===
              self.Sk.builtin.set.prototype.sq$length.call(a)
          ? this.issubset.func_code(this, a)
          : self.Sk.builtin.bool.false$
      }
      self.Sk.builtin.set.prototype.ob$ne = function(a) {
        return this === a
          ? self.Sk.builtin.bool.false$
          : a instanceof self.Sk.builtin.set &&
            self.Sk.builtin.set.prototype.sq$length.call(this) ===
              self.Sk.builtin.set.prototype.sq$length.call(a)
          ? this.issubset.func_code(this, a).v
            ? self.Sk.builtin.bool.false$
            : self.Sk.builtin.bool.true$
          : self.Sk.builtin.bool.true$
      }
      self.Sk.builtin.set.prototype.ob$lt = function(a) {
        return this === a ||
          self.Sk.builtin.set.prototype.sq$length.call(this) >=
            self.Sk.builtin.set.prototype.sq$length.call(a)
          ? self.Sk.builtin.bool.false$
          : this.issubset.func_code(this, a)
      }
      self.Sk.builtin.set.prototype.ob$le = function(a) {
        return this === a
          ? self.Sk.builtin.bool.true$
          : self.Sk.builtin.set.prototype.sq$length.call(this) >
            self.Sk.builtin.set.prototype.sq$length.call(a)
          ? self.Sk.builtin.bool.false$
          : this.issubset.func_code(this, a)
      }
      self.Sk.builtin.set.prototype.ob$gt = function(a) {
        return this === a ||
          self.Sk.builtin.set.prototype.sq$length.call(this) <=
            self.Sk.builtin.set.prototype.sq$length.call(a)
          ? self.Sk.builtin.bool.false$
          : this.issuperset.func_code(this, a)
      }
      self.Sk.builtin.set.prototype.ob$ge = function(a) {
        return this === a
          ? self.Sk.builtin.bool.true$
          : self.Sk.builtin.set.prototype.sq$length.call(this) <
            self.Sk.builtin.set.prototype.sq$length.call(a)
          ? self.Sk.builtin.bool.false$
          : this.issuperset.func_code(this, a)
      }
      self.Sk.builtin.set.prototype.nb$and = function(a) {
        return this.intersection.func_code(this, a)
      }
      self.Sk.builtin.set.prototype.nb$or = function(a) {
        return this.union.func_code(this, a)
      }
      self.Sk.builtin.set.prototype.nb$xor = function(a) {
        return this.symmetric_difference.func_code(this, a)
      }
      self.Sk.builtin.set.prototype.nb$subtract = function(a) {
        return this.difference.func_code(this, a)
      }
      self.Sk.builtin.set.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("__iter__", arguments.length, 0, 0, !1, !0)
        return new self.Sk.builtin.set_iter_(a)
      })
      self.Sk.builtin.set.prototype.tp$iter = function() {
        return new self.Sk.builtin.set_iter_(this)
      }
      self.Sk.builtin.set.prototype.sq$length = function() {
        return this.v.mp$length()
      }
      self.Sk.builtin.set.prototype.sq$contains = function(a) {
        return this.v.sq$contains(a)
      }
      self.Sk.builtin.set.prototype.isdisjoint = new self.Sk.builtin.func(function(a, b) {
        var c
        self.Sk.builtin.pyCheckArgsLen("isdisjoint", arguments.length, 2, 2)
        if (!self.Sk.builtin.checkIterable(b))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(b) + "' object is not iterable",
          )
        var d = self.Sk.abstr.iter(a)
        for (c = d.tp$iternext(); void 0 !== c; c = d.tp$iternext())
          if ((c = self.Sk.abstr.sequenceContains(b, c)))
            return self.Sk.builtin.bool.false$
        return self.Sk.builtin.bool.true$
      })
      self.Sk.builtin.set.prototype.issubset = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("issubset", arguments.length, 2, 2)
        if (!self.Sk.builtin.checkIterable(b))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(b) + "' object is not iterable",
          )
        var c = a.sq$length()
        var d = b.sq$length()
        if (c > d) return self.Sk.builtin.bool.false$
        c = self.Sk.abstr.iter(a)
        for (d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
          if (((d = self.Sk.abstr.sequenceContains(b, d)), !d))
            return self.Sk.builtin.bool.false$
        return self.Sk.builtin.bool.true$
      })
      self.Sk.builtin.set.prototype.issuperset = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("issuperset", arguments.length, 2, 2)
        return self.Sk.builtin.set.prototype.issubset.func_code(b, a)
      })
      self.Sk.builtin.set.prototype.union = new self.Sk.builtin.func(function(a) {
        var b
        self.Sk.builtin.pyCheckArgsLen("union", arguments.length, 1)
        var c = self.Sk.builtin.set.prototype.copy.func_code(a)
        var d = [c]
        for (b = 1; b < arguments.length; b++) d.push(arguments[b])
        self.Sk.builtin.set.prototype.update.func_code.apply(null, d)
        return c
      })
      self.Sk.builtin.set.prototype.intersection = new self.Sk.builtin.func(function(a) {
        var b
        self.Sk.builtin.pyCheckArgsLen("intersection", arguments.length, 1)
        var c = self.Sk.builtin.set.prototype.copy.func_code(a)
        var d = [c]
        for (b = 1; b < arguments.length; b++) d.push(arguments[b])
        self.Sk.builtin.set.prototype.intersection_update.func_code.apply(null, d)
        return c
      })
      self.Sk.builtin.set.prototype.difference = new self.Sk.builtin.func(function(a, b) {
        var c
        self.Sk.builtin.pyCheckArgsLen("difference", arguments.length, 2)
        var d = self.Sk.builtin.set.prototype.copy.func_code(a)
        var e = [d]
        for (c = 1; c < arguments.length; c++) e.push(arguments[c])
        self.Sk.builtin.set.prototype.difference_update.func_code.apply(null, e)
        return d
      })
      self.Sk.builtin.set.prototype.symmetric_difference = new self.Sk.builtin.func(
        function(a, b) {
          var c
          self.Sk.builtin.pyCheckArgsLen(
            "symmetric_difference",
            arguments.length,
            2,
            2,
          )
          var d = self.Sk.builtin.set.prototype.union.func_code(a, b)
          var e = self.Sk.abstr.iter(d)
          for (c = e.tp$iternext(); void 0 !== c; c = e.tp$iternext())
            self.Sk.abstr.sequenceContains(a, c) &&
              self.Sk.abstr.sequenceContains(b, c) &&
              self.Sk.builtin.set.prototype.discard.func_code(d, c)
          return d
        },
      )
      self.Sk.builtin.set.prototype.copy = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("copy", arguments.length, 1, 1)
        return new self.Sk.builtin.set(a)
      })
      self.Sk.builtin.set.prototype.update = new self.Sk.builtin.func(function(a, b) {
        var c, d
        self.Sk.builtin.pyCheckArgsLen("update", arguments.length, 2)
        for (c = 1; c < arguments.length; c++) {
          var e = arguments[c]
          if (!self.Sk.builtin.checkIterable(e))
            throw new self.Sk.builtin.TypeError(
              "'" + self.Sk.abstr.typeName(e) + "' object is not iterable",
            )
          e = self.Sk.abstr.iter(e)
          for (d = e.tp$iternext(); void 0 !== d; d = e.tp$iternext())
            self.Sk.builtin.set.prototype.add.func_code(a, d)
        }
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.set.prototype.intersection_update = new self.Sk.builtin.func(
        function(a, b) {
          var c, d
          self.Sk.builtin.pyCheckArgsLen("intersection_update", arguments.length, 2)
          for (c = 1; c < arguments.length; c++)
            if (!self.Sk.builtin.checkIterable(arguments[c]))
              throw new self.Sk.builtin.TypeError(
                "'" +
                  self.Sk.abstr.typeName(arguments[c]) +
                  "' object is not iterable",
              )
          var e = self.Sk.abstr.iter(a)
          for (d = e.tp$iternext(); void 0 !== d; d = e.tp$iternext())
            for (c = 1; c < arguments.length; c++)
              if (!self.Sk.abstr.sequenceContains(arguments[c], d)) {
                self.Sk.builtin.set.prototype.discard.func_code(a, d)
                break
              }
          return self.Sk.builtin.none.none$
        },
      )
      self.Sk.builtin.set.prototype.difference_update = new self.Sk.builtin.func(function(
        a,
        b,
      ) {
        var c, d
        self.Sk.builtin.pyCheckArgsLen("difference_update", arguments.length, 2)
        for (c = 1; c < arguments.length; c++)
          if (!self.Sk.builtin.checkIterable(arguments[c]))
            throw new self.Sk.builtin.TypeError(
              "'" +
                self.Sk.abstr.typeName(arguments[c]) +
                "' object is not iterable",
            )
        var e = self.Sk.abstr.iter(a)
        for (d = e.tp$iternext(); void 0 !== d; d = e.tp$iternext())
          for (c = 1; c < arguments.length; c++)
            if (self.Sk.abstr.sequenceContains(arguments[c], d)) {
              self.Sk.builtin.set.prototype.discard.func_code(a, d)
              break
            }
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.set.prototype.symmetric_difference_update = new self.Sk.builtin.func(
        function(a, b) {
          self.Sk.builtin.pyCheckArgsLen(
            "symmetric_difference_update",
            arguments.length,
            2,
            2,
          )
          var c = self.Sk.builtin.set.prototype.symmetric_difference.func_code(a, b)
          a.set_reset_()
          self.Sk.builtin.set.prototype.update.func_code(a, c)
          return self.Sk.builtin.none.none$
        },
      )
      self.Sk.builtin.set.prototype.add = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("add", arguments.length, 2, 2)
        a.v.mp$ass_subscript(b, !0)
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.set.prototype.discard = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("discard", arguments.length, 2, 2)
        self.Sk.builtin.dict.prototype.pop.func_code(a.v, b, self.Sk.builtin.none.none$)
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.set.prototype.pop = new self.Sk.builtin.func(function(a) {
        self.Sk.builtin.pyCheckArgsLen("pop", arguments.length, 1, 1)
        if (0 === a.sq$length())
          throw new self.Sk.builtin.KeyError("pop from an empty set")
        var b = self.Sk.abstr.iter(a).tp$iternext()
        self.Sk.builtin.set.prototype.discard.func_code(a, b)
        return b
      })
      self.Sk.builtin.set.prototype.remove = new self.Sk.builtin.func(function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("remove", arguments.length, 2, 2)
        a.v.mp$del_subscript(b)
        return self.Sk.builtin.none.none$
      })
      self.Sk.exportSymbol("Sk.builtin.set", self.Sk.builtin.set)
      self.Sk.builtin.set_iter_ = function(a) {
        var b, c
        if (!(this instanceof self.Sk.builtin.set_iter_))
          return new self.Sk.builtin.set_iter_(a)
        this.$obj = a
        this.tp$iter = this
        var d = []
        var e = a.v.buckets
        for (b in e)
          if (
            e.hasOwnProperty(b) &&
            (c = e[b]) &&
            void 0 !== c.$hash &&
            void 0 !== c.items
          )
            for (a = 0; a < c.items.length; a++) d.push(c.items[a].lhs)
        this.$index = 0
        this.$keys = d
        this.tp$iternext = function() {
          if (!(this.$index >= this.$keys.length))
            return this.$keys[this.$index++]
        }
        this.$r = function() {
          return new self.Sk.builtin.str("setiterator")
        }
        return this
      }
      self.Sk.abstr.setUpInheritance(
        "setiterator",
        self.Sk.builtin.set_iter_,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.set_iter_.prototype.__class__ = self.Sk.builtin.set_iter_
      self.Sk.builtin.set_iter_.prototype.__iter__ = new self.Sk.builtin.func(function(
        a,
      ) {
        self.Sk.builtin.pyCheckArgsLen("__iter__", arguments.length, 0, 0, !0, !1)
        return a
      })
      self.Sk.builtin.set_iter_.prototype.next$ = function(a) {
        a = a.tp$iternext()
        if (void 0 === a) throw new self.Sk.builtin.StopIteration()
        return a
      }
    },
    function(m, p) {
      m = function(a) {
        self.Sk.builtin.pyCheckArgsLen(
          "print",
          arguments.length,
          0,
          Infinity,
          !0,
          !1,
        )
        var b = Array.prototype.slice.call(arguments, 1),
          c = new self.Sk.builtins.dict(a)
        self.Sk.ffi.remapToJs(c)
        var d = { sep: " ", end: "\n", file: null }
        var e = c.mp$lookup(new self.Sk.builtin.str("sep"))
        if (void 0 !== e) {
          var f = self.Sk.builtin.checkNone(e)
          if (self.Sk.builtin.checkString(e) || f)
            d.sep = f ? d.sep : self.Sk.ffi.remapToJs(e)
          else
            throw new self.Sk.builtin.TypeError(
              "sep must be None or a string, not " + self.Sk.abstr.typeName(e),
            )
        }
        e = c.mp$lookup(new self.Sk.builtin.str("end"))
        if (void 0 !== e)
          if (((f = self.Sk.builtin.checkNone(e)), self.Sk.builtin.checkString(e) || f))
            d.end = f ? d.end : self.Sk.ffi.remapToJs(e)
          else
            throw new self.Sk.builtin.TypeError(
              "end must be None or a string, not " + self.Sk.abstr.typeName(e),
            )
        e = c.mp$lookup(new self.Sk.builtin.str("file"))
        if (void 0 !== e)
          if ((f = self.Sk.builtin.checkNone(e)) || void 0 !== e.tp$getattr("write"))
            d.file = f ? d.file : e
          else
            throw new self.Sk.builtin.AttributeError(
              "'" + self.Sk.abstr.typeName(e) + "' object has no attribute 'write'",
            )
        var g = ""
        for (c = 0; c < b.length; c++)
          (g += new self.Sk.builtin.str(b[c]).v), (g += d.sep)
        0 < b.length &&
          0 < d.sep.length &&
          (g = g.substring(0, g.length - d.sep.length))
        g += d.end
        if (null !== d.file)
          self.Sk.misceval.callsimArray(d.file.write, [
            d.file,
            new self.Sk.builtin.str(g),
          ])
        else
          return self.Sk.misceval.chain(self.Sk.importModule("sys", !1, !0), function(a) {
            return self.Sk.misceval.apply(
              a.$d.stdout.write,
              void 0,
              void 0,
              void 0,
              [a.$d.stdout, new self.Sk.builtin.str(g)],
            )
          })
      }
      m.co_kwargs = !0
      self.Sk.builtin.print = new self.Sk.builtin.func(m)
      self.Sk.builtin.print.__doc__ = new self.Sk.builtin.str(
        "print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream.",
      )
    },
    function(m, p) {
      self.Sk.builtin.module = function() {}
      self.Sk.exportSymbol("Sk.builtin.module", self.Sk.builtin.module)
      self.Sk.builtin.module.prototype.ob$type = self.Sk.builtin.type.makeIntoTypeObj(
        "module",
        self.Sk.builtin.module,
      )
      self.Sk.builtin.module.prototype.tp$getattr =
        self.Sk.builtin.object.prototype.GenericGetAttr
      self.Sk.builtin.module.prototype.tp$setattr =
        self.Sk.builtin.object.prototype.GenericSetAttr
      self.Sk.builtin.module.prototype.tp$name = "module"
    },
    function(m, p) {
      self.Sk.builtin.structseq_types = {}
      self.Sk.builtin.make_structseq = function(a, b, c, d) {
        var e = a + "." + b,
          f = []
        a = []
        for (var g in c) f.push(g), a.push(c[g])
        c = function(a) {
          self.Sk.builtin.pyCheckArgsLen(e, arguments.length, 1, 1)
          var b
          if (!(this instanceof self.Sk.builtin.structseq_types[e])) {
            var c = Object.create(self.Sk.builtin.structseq_types[e].prototype)
            c.constructor.apply(c, arguments)
            return c
          }
          if (Array.isArray(a)) var d = a
          else {
            d = []
            c = self.Sk.abstr.iter(a)
            for (b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
              d.push(b)
            if (d.length != f.length)
              throw new self.Sk.builtin.TypeError(
                e +
                  "() takes a " +
                  f.length +
                  "-sequence (" +
                  d.length +
                  "-sequence given)",
              )
          }
          self.Sk.builtin.tuple.call(this, d)
          this.__class__ = self.Sk.builtin.structseq_types[e]
        }
        self.Sk.builtin.structseq_types[e] = c
        self.Sk.abstr.inherits(c, self.Sk.builtin.tuple)
        d && (c.prototype.__doc__ = d)
        c.prototype.tp$name = e
        c.prototype.ob$type = self.Sk.builtin.type.makeIntoTypeObj(
          e,
          self.Sk.builtin.structseq_types[e],
        )
        c.prototype.ob$type.$d = new self.Sk.builtin.dict([])
        c.prototype.ob$type.$d.mp$ass_subscript(
          self.Sk.builtin.type.basesStr_,
          new self.Sk.builtin.tuple([self.Sk.builtin.tuple]),
        )
        c.prototype.__getitem__ = new self.Sk.builtin.func(function(a, b) {
          return self.Sk.builtin.tuple.prototype.mp$subscript.call(a, b)
        })
        c.prototype.__reduce__ = new self.Sk.builtin.func(function(a) {
          throw new self.Sk.builtin.Exception("__reduce__ is not implemented")
        })
        c.prototype.$r = function() {
          var a
          if (0 === this.v.length) return new self.Sk.builtin.str(e + "()")
          var b = []
          for (a = 0; a < this.v.length; ++a)
            b[a] = f[a] + "=" + self.Sk.misceval.objectRepr(this.v[a]).v
          a = b.join(", ")
          1 === this.v.length && (a += ",")
          return new self.Sk.builtin.str(e + "(" + a + ")")
        }
        c.prototype.tp$setattr = function(a, b) {
          throw new self.Sk.builtin.AttributeError("readonly property")
        }
        c.prototype.tp$getattr = function(a) {
          var b = a.$jsstr()
          b = f.indexOf(b)
          return 0 <= b
            ? this.v[b]
            : self.Sk.builtin.object.prototype.GenericGetAttr(a)
        }
        return c
      }
      self.Sk.exportSymbol("Sk.builtin.make_structseq", self.Sk.builtin.make_structseq)
    },
    function(m, p) {
      self.Sk.builtin.generator = function(a, b, c, d, e) {
        var f
        if (a) {
          if (!(this instanceof self.Sk.builtin.generator))
            return new self.Sk.builtin.generator(a, b, c, d, e)
          this.func_code = a
          this.func_globals = b || null
          this.gi$running = !1
          this.gi$resumeat = 0
          this.gi$sentvalue = void 0
          this.gi$locals = {}
          this.gi$cells = {}
          if (0 < c.length)
            for (b = 0; b < a.co_varnames.length; ++b)
              this.gi$locals[a.co_varnames[b]] = c[b]
          if (void 0 !== e) for (f in e) d[f] = e[f]
          this.func_closure = d
          return this
        }
      }
      self.Sk.exportSymbol("Sk.builtin.generator", self.Sk.builtin.generator)
      self.Sk.abstr.setUpInheritance(
        "generator",
        self.Sk.builtin.generator,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.generator.prototype.tp$iter = function() {
        return this
      }
      self.Sk.builtin.generator.prototype.tp$iternext = function(a, b) {
        var c = this
        this.gi$running = !0
        void 0 === b && (b = null)
        this.gi$sentvalue = b
        b = [this]
        this.func_closure && b.push(this.func_closure)
        return (function f(b) {
          if (b instanceof self.Sk.misceval.Suspension) {
            if (a) return new self.Sk.misceval.Suspension(f, b)
            b = self.Sk.misceval.retryOptionalSuspensionOrThrow(b)
          }
          c.gi$running = !1
          self.Sk.asserts.assert(void 0 !== b)
          if (b !== self.Sk.builtin.none.none$)
            return (c.gi$resumeat = b[0]), (b = b[1])
        })(this.func_code.apply(this.func_globals, b))
      }
      self.Sk.builtin.generator.prototype.next$ = function(a) {
        return a.tp$iternext(!0)
      }
      self.Sk.builtin.generator.prototype.$r = function() {
        return new self.Sk.builtin.str(
          "<generator object " + this.func_code.co_name.v + ">",
        )
      }
      self.Sk.builtin.generator.prototype.send = new self.Sk.builtin.func(function(a, b) {
        return a.tp$iternext(!0, b)
      })
      self.Sk.builtin.makeGenerator = function(a, b) {
        var c,
          d = new self.Sk.builtin.generator(null, null, null)
        d.tp$iternext = a
        for (c in b) b.hasOwnProperty(c) && (d[c] = b[c])
        return d
      }
      self.Sk.exportSymbol("Sk.builtin.makeGenerator", self.Sk.builtin.makeGenerator)
    },
    function(m, p) {
      self.Sk.builtin.file = function(a, b, c) {
        var d
        if (!(this instanceof self.Sk.builtin.file))
          return new self.Sk.builtin.file(a, b, c)
        this.mode = b
        this.name = self.Sk.ffi.remapToJs(a)
        this.closed = !1
        if ("/dev/stdout" === this.name)
          (this.data$ = self.Sk.builtin.none.none$), (this.fileno = 1)
        else if ("/dev/stdin" === this.name) this.fileno = 0
        else if ("/dev/stderr" === this.name) this.fileno = 2
        else {
          if (self.Sk.inBrowser)
            if (
              ((this.fileno = 10),
              (c = document.getElementById(a.v)),
              null == c)
            )
              if ("w" == b.v || "a" == b.v) this.data$ = ""
              else
                throw new self.Sk.builtin.IOError(
                  "[Errno 2] No such file or directory: '" + a.v + "'",
                )
            else
              "textarea" == c.nodeName.toLowerCase()
                ? (this.data$ = c.value)
                : (this.data$ = c.textContent)
          else (this.fileno = 11), (this.data$ = self.Sk.read(a.v))
          this.lineList = this.data$.split("\n")
          this.lineList = this.lineList.slice(0, -1)
          for (d in this.lineList) this.lineList[d] += "\n"
          this.currentLine = 0
        }
        this.pos$ = 0
        this.__class__ = self.Sk.builtin.file
        self.Sk.fileopen && 10 <= this.fileno && self.Sk.fileopen(this)
        return this
      }
      self.Sk.abstr.setUpInheritance("file", self.Sk.builtin.file, self.Sk.builtin.object)
      self.Sk.builtin.file.prototype.$r = function() {
        return new self.Sk.builtin.str(
          "<" +
            (this.closed ? "closed" : "open") +
            "file '" +
            this.name +
            "', mode '" +
            self.Sk.ffi.remapToJs(this.mode) +
            "'>",
        )
      }
      self.Sk.builtin.file.prototype.__enter__ = new self.Sk.builtin.func(function(a) {
        return a
      })
      self.Sk.builtin.file.prototype.__exit__ = new self.Sk.builtin.func(function(a) {
        return self.Sk.misceval.callsimArray(self.Sk.builtin.file.prototype.close, [a])
      })
      self.Sk.builtin.file.prototype.tp$iter = function() {
        var a = {
          tp$iter: function() {
            return a
          },
          $obj: this,
          $index: this.currentLine,
          $lines: this.lineList,
          tp$iternext: function() {
            if (!(a.$index >= a.$lines.length))
              return new self.Sk.builtin.str(a.$lines[a.$index++])
          },
        }
        return a
      }
      self.Sk.builtin.file.prototype.close = new self.Sk.builtin.func(function(a) {
        a.closed = !0
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.file.prototype.flush = new self.Sk.builtin.func(function(a) {})
      self.Sk.builtin.file.prototype.fileno = new self.Sk.builtin.func(function(a) {
        return this.fileno
      })
      self.Sk.builtin.file.prototype.isatty = new self.Sk.builtin.func(function(a) {
        return !1
      })
      self.Sk.builtin.file.prototype.read = new self.Sk.builtin.func(function(a, b) {
        var c = a.data$.length
        if (a.closed)
          throw new self.Sk.builtin.ValueError("I/O operation on closed file")
        var d = void 0 === b ? c : self.Sk.ffi.remapToJs(b)
        d = new self.Sk.builtin.str(a.data$.substr(a.pos$, d))
        a.pos$ = void 0 === b ? c : a.pos$ + self.Sk.ffi.remapToJs(b)
        a.pos$ >= c && (a.pos$ = c)
        return d
      })
      self.Sk.builtin.file.$readline = function(a, b, c) {
        if (0 === a.fileno) {
          a = self.Sk.ffi.remapToJs(c)
          a = self.Sk.inputfun(a ? a : "")
          if (a instanceof Promise) {
            var d = new self.Sk.misceval.Suspension()
            d.resume = function() {
              if (d.data.error) throw d.data.error
              return new self.Sk.builtin.str(d.data.result)
            }
            d.data = { type: "Sk.promise", promise: a }
            return d
          }
          return new self.Sk.builtin.str(a)
        }
        b = ""
        a.currentLine < a.lineList.length &&
          ((b = a.lineList[a.currentLine]), a.currentLine++)
        return new self.Sk.builtin.str(b)
      }
      self.Sk.builtin.file.prototype.readline = new self.Sk.builtin.func(function(a, b) {
        return self.Sk.builtin.file.$readline(a, b, void 0)
      })
      self.Sk.builtin.file.prototype.readlines = new self.Sk.builtin.func(function(a, b) {
        if (0 === a.fileno)
          return new self.Sk.builtin.NotImplementedError(
            "readlines ins't implemented because the web doesn't support Ctrl+D",
          )
        var c = []
        for (b = a.currentLine; b < a.lineList.length; b++)
          c.push(new self.Sk.builtin.str(a.lineList[b]))
        return new self.Sk.builtin.list(c)
      })
      self.Sk.builtin.file.prototype.seek = new self.Sk.builtin.func(function(a, b, c) {
        b = self.Sk.ffi.remapToJs(b)
        void 0 === c && (c = 0)
        0 === c
          ? (a.pos$ = b)
          : 1 == c
          ? (a.pos$ = a.data$.length + b)
          : 2 == c && (a.pos$ = a.data$.length + b)
        return self.Sk.builtin.none.none$
      })
      self.Sk.builtin.file.prototype.tell = new self.Sk.builtin.func(function(a) {
        return self.Sk.ffi.remapToPy(a.pos$)
      })
      self.Sk.builtin.file.prototype.truncate = new self.Sk.builtin.func(function(a, b) {
        self.Sk.asserts.fail()
      })
      self.Sk.builtin.file.prototype.write = new self.Sk.builtin.func(function(a, b) {
        var c = self.Sk.ffi.remapToJs(a.mode)
        if ("w" === c || "wb" === c || "a" === c || "ab" === c)
          if (self.Sk.filewrite) {
            if (a.closed)
              throw new self.Sk.builtin.ValueError("I/O operation on closed file")
            1 === a.fileno ? self.Sk.output(self.Sk.ffi.remapToJs(b)) : self.Sk.filewrite(a, b)
          } else
            1 === a.fileno ? self.Sk.output(self.Sk.ffi.remapToJs(b)) : self.Sk.asserts.fail()
        else throw new self.Sk.builtin.IOError("File not open for writing")
      })
      self.Sk.exportSymbol("Sk.builtin.file", self.Sk.builtin.file)
    },
    function(m, p) {
      self.Sk.ffi = self.Sk.ffi || {}
      self.Sk.ffi.remapToPy = function(a) {
        var b
        if (null === a || "undefined" === typeof a) return self.Sk.builtin.none.none$
        if (a.ob$type) return a
        if (a instanceof self.Sk.misceval.Suspension) return a
        if ("[object Array]" === Object.prototype.toString.call(a)) {
          var c = []
          for (b = 0; b < a.length; ++b) c.push(self.Sk.ffi.remapToPy(a[b]))
          return new self.Sk.builtin.list(c)
        }
        if ("object" === typeof a) {
          c = []
          for (b in a)
            c.push(self.Sk.ffi.remapToPy(b)), c.push(self.Sk.ffi.remapToPy(a[b]))
          return new self.Sk.builtin.dict(c)
        }
        if ("string" === typeof a) return new self.Sk.builtin.str(a)
        if ("number" === typeof a) return self.Sk.builtin.assk$(a)
        if ("boolean" === typeof a) return new self.Sk.builtin.bool(a)
        if ("undefined" === typeof a) return self.Sk.builtin.none.none$
        if ("function" === typeof a) return new self.Sk.builtin.func(a)
        self.Sk.asserts.fail("unhandled remap type " + typeof a)
      }
      self.Sk.exportSymbol("Sk.ffi.remapToPy", self.Sk.ffi.remapToPy)
      self.Sk.ffi.remapToJs = function(a) {
        var b
        if (a instanceof self.Sk.builtin.dict) {
          var c = {}
          var d = a.tp$iter()
          for (b = d.tp$iternext(); void 0 !== b; b = d.tp$iternext()) {
            var e = a.mp$subscript(b)
            void 0 === e && (e = null)
            b = self.Sk.ffi.remapToJs(b)
            c[b] = self.Sk.ffi.remapToJs(e)
          }
          return c
        }
        if (a instanceof self.Sk.builtin.list || a instanceof self.Sk.builtin.tuple) {
          c = []
          for (e = 0; e < a.v.length; ++e) c.push(self.Sk.ffi.remapToJs(a.v[e]))
          return c
        }
        if (a instanceof self.Sk.builtin.bool) return a.v ? !0 : !1
        if (a instanceof self.Sk.builtin.int_) return self.Sk.builtin.asnum$(a)
        if (a instanceof self.Sk.builtin.float_) return self.Sk.builtin.asnum$(a)
        if (a instanceof self.Sk.builtin.lng) return self.Sk.builtin.asnum$(a)
        if (
          "number" === typeof a ||
          "boolean" === typeof a ||
          "string" === typeof a
        )
          return a
        if (void 0 !== a) return a.v
      }
      self.Sk.exportSymbol("Sk.ffi.remapToJs", self.Sk.ffi.remapToJs)
      self.Sk.ffi.callback = function(a) {
        return void 0 === a
          ? a
          : function() {
              return self.Sk.misceval.apply(
                a,
                void 0,
                void 0,
                void 0,
                Array.prototype.slice.call(arguments, 0),
              )
            }
      }
      self.Sk.exportSymbol("Sk.ffi.callback", self.Sk.ffi.callback)
      self.Sk.ffi.stdwrap = function(a, b) {
        a = new a()
        a.v = b
        return a
      }
      self.Sk.exportSymbol("Sk.ffi.stdwrap", self.Sk.ffi.stdwrap)
      self.Sk.ffi.basicwrap = function(a) {
        if (a instanceof self.Sk.builtin.int_) return self.Sk.builtin.asnum$(a)
        if (a instanceof self.Sk.builtin.float_) return self.Sk.builtin.asnum$(a)
        if (a instanceof self.Sk.builtin.lng) return self.Sk.builtin.asnum$(a)
        if ("number" === typeof a || "boolean" === typeof a) return a
        if ("string" === typeof a) return new self.Sk.builtin.str(a)
        self.Sk.asserts.fail("unexpected type for basicwrap")
      }
      self.Sk.exportSymbol("Sk.ffi.basicwrap", self.Sk.ffi.basicwrap)
      self.Sk.ffi.unwrapo = function(a) {
        if (void 0 !== a) return a.v
      }
      self.Sk.exportSymbol("Sk.ffi.unwrapo", self.Sk.ffi.unwrapo)
      self.Sk.ffi.unwrapn = function(a) {
        return null === a ? null : a.v
      }
      self.Sk.exportSymbol("Sk.ffi.unwrapn", self.Sk.ffi.unwrapn)
    },
    function(m, p) {
      self.Sk.builtin.iterator = function(a, b) {
        var c
        if (a instanceof self.Sk.builtin.generator) return a
        if ((c = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$iter)))
          return self.Sk.misceval.callsimArray(c, [a])
        this.sentinel = b
        this.flag = !1
        this.idx = 0
        this.obj = a
        void 0 === b
          ? ((this.getitem = self.Sk.abstr.lookupSpecial(
              a,
              self.Sk.builtin.str.$getitem,
            )),
            (this.$r = function() {
              return new self.Sk.builtin.str("<iterator object>")
            }))
          : ((this.call = self.Sk.abstr.lookupSpecial(a, self.Sk.builtin.str.$call)),
            (this.$r = function() {
              return new self.Sk.builtin.str("<callable-iterator object>")
            }))
        return this
      }
      self.Sk.abstr.setUpInheritance(
        "iterator",
        self.Sk.builtin.iterator,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.iterator.prototype.__class__ = self.Sk.builtin.iterator
      self.Sk.builtin.iterator.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        return a.tp$iter()
      })
      self.Sk.builtin.iterator.prototype.tp$iter = function() {
        return this
      }
      self.Sk.builtin.iterator.prototype.tp$iternext = function(a) {
        var b = this
        if (!0 !== this.flag) {
          if (this.getitem) {
            var c = self.Sk.misceval.tryCatch(
              function() {
                return self.Sk.misceval.callsimOrSuspendArray(b.getitem, [
                  b.obj,
                  self.Sk.ffi.remapToPy(b.idx++),
                ])
              },
              function(a) {
                if (
                  !(
                    a instanceof self.Sk.builtin.StopIteration ||
                    a instanceof self.Sk.builtin.IndexError
                  )
                )
                  throw a
              },
            )
            return a ? c : self.Sk.misceval.retryOptionalSuspensionOrThrow(c)
          }
          c = function(a) {
            if (self.Sk.misceval.richCompareBool(a, b.sentinel, "Eq")) b.flag = !0
            else return a
          }
          c = this.call
            ? self.Sk.misceval.chain(
                self.Sk.misceval.callsimOrSuspendArray(this.call, [this.obj]),
                c,
              )
            : self.Sk.misceval.chain(self.Sk.misceval.callsimOrSuspendArray(this.obj), c)
          return a ? c : self.Sk.misceval.retryOptionalSuspensionOrThrow(c)
        }
      }
      self.Sk.builtin.iterator.prototype.next$ = function(a) {
        a = a.tp$iternext()
        if (!a) throw new self.Sk.builtin.StopIteration()
        return a
      }
      self.Sk.exportSymbol("Sk.builtin.iterator", self.Sk.builtin.iterator)
    },
    function(m, p) {
      self.Sk.builtin.enumerate = function(a, b) {
        if (!(this instanceof self.Sk.builtin.enumerate))
          return new self.Sk.builtin.enumerate(a, b)
        self.Sk.builtin.pyCheckArgsLen("enumerate", arguments.length, 1, 2)
        if (!self.Sk.builtin.checkIterable(a))
          throw new self.Sk.builtin.TypeError(
            "'" + self.Sk.abstr.typeName(a) + "' object is not iterable",
          )
        if (void 0 !== b)
          if (self.Sk.misceval.isIndex(b)) b = self.Sk.misceval.asIndex(b)
          else
            throw new self.Sk.builtin.TypeError(
              "'" +
                self.Sk.abstr.typeName(b) +
                "' object cannot be interpreted as an index",
            )
        else b = 0
        var c = a.tp$iter()
        this.tp$iter = function() {
          return this
        }
        this.$index = b
        this.tp$iternext = function() {
          var a = c.tp$iternext()
          if (void 0 !== a) {
            var b = new self.Sk.builtin.int_(this.$index++)
            return new self.Sk.builtin.tuple([b, a])
          }
        }
        this.__class__ = self.Sk.builtin.enumerate
        return this
      }
      self.Sk.abstr.setUpInheritance(
        "enumerate",
        self.Sk.builtin.enumerate,
        self.Sk.builtin.object,
      )
      self.Sk.builtin.enumerate.prototype.__iter__ = new self.Sk.builtin.func(function(
        a,
      ) {
        return a.tp$iter()
      })
      self.Sk.builtin.enumerate.prototype.next$ = function(a) {
        return a.tp$iternext()
      }
      self.Sk.builtin.enumerate.co_varnames = ["iterable", "start"]
      self.Sk.builtin.enumerate.co_argcount = 2
      self.Sk.builtin.enumerate.$defaults = [self.Sk.builtin.none.none$, 0]
      self.Sk.builtin.enumerate.co_name = self.Sk.builtin.str("enumerate")
      self.Sk.builtin.enumerate.prototype.$r = function() {
        return new self.Sk.builtin.str("<enumerate object>")
      }
    },
    function(m, p) {
      self.Sk.builtin.filter_ = function(a, b) {
        var c, d
        self.Sk.builtin.pyCheckArgsLen("filter_", arguments.length, 2, 2)
        if (!(this instanceof self.Sk.builtin.filter_))
          return new self.Sk.builtin.filter_(a, b)
        var e = self.Sk.abstr.iter(b)
        var f = function(b) {
          c = a === self.Sk.builtin.none.none$ ? b : self.Sk.misceval.callsimArray(a, [b])
          if (self.Sk.misceval.isTrue(c)) return c
        }
        this.tp$iter = function() {
          return this
        }
        this.tp$iternext = function() {
          d = e.tp$iternext()
          if (void 0 !== d) {
            for (c = f(d); void 0 === c; ) {
              d = e.tp$iternext()
              if (void 0 === d) return
              c = f(d)
            }
            return d
          }
        }
        this.__class__ = self.Sk.builtin.filter_
        return this
      }
      self.Sk.abstr.setUpInheritance("filter", self.Sk.builtin.filter_, self.Sk.builtin.object)
      self.Sk.builtin.filter_.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        return a.tp$iter()
      })
      self.Sk.builtin.filter_.prototype.next$ = function(a) {
        return a.tp$iternext()
      }
      self.Sk.builtin.filter_.prototype.$r = function() {
        return new self.Sk.builtin.str("<filter object>")
      }
      self.Sk.exportSymbol("Sk.builtin.filter_", self.Sk.builtin.filter_)
    },
    function(m, p) {
      self.Sk.builtin.zip_ = function() {
        var a, b
        if (!(this instanceof self.Sk.builtin.zip_))
          return new self.Sk.builtin.zip_(...arguments)
        if (0 === arguments.length)
          return new self.Sk.builtin.zip_(new self.Sk.builtin.list([]))
        var c = []
        for (a = 0; a < arguments.length; a++)
          try {
            c.push(self.Sk.abstr.iter(arguments[a]))
          } catch (d) {
            if (d instanceof self.Sk.builtin.TypeError)
              throw new self.Sk.builtin.TypeError(
                "zip argument #" + (a + 1) + " must support iteration",
              )
            throw d
          }
        this.tp$iter = function() {
          return this
        }
        this.tp$iternext = function() {
          var d = []
          for (a = 0; a < c.length; a++) {
            b = c[a].tp$iternext()
            if (void 0 === b) return
            d.push(b)
          }
          return new self.Sk.builtin.tuple(d)
        }
        this.__class__ = self.Sk.builtin.zip_
        return this
      }
      self.Sk.abstr.setUpInheritance("zip", self.Sk.builtin.zip_, self.Sk.builtin.object)
      self.Sk.builtin.zip_.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        return a.tp$iter()
      })
      self.Sk.builtin.zip_.prototype.next$ = function(a) {
        return a.tp$iternext()
      }
      self.Sk.builtin.zip_.prototype.$r = function() {
        return new self.Sk.builtin.str("<zip object>")
      }
      self.Sk.exportSymbol("Sk.builtin.zip_", self.Sk.builtin.zip_)
    },
    function(m, p) {
      self.Sk.builtin.map_ = function(a, b) {
        var c, d, e, f
        self.Sk.builtin.pyCheckArgsLen("map_", arguments.length, 2)
        if (!(this instanceof self.Sk.builtin.map_)) {
          var g = Array.prototype.slice.apply(arguments).slice(1)
          return new self.Sk.builtin.map_(a, ...g)
        }
        if (2 < arguments.length) {
          var h = Array.prototype.slice.apply(arguments).slice(1)
          for (d = 0; d < h.length; d++) h[d] = self.Sk.abstr.iter(h[d])
          var k = function() {
            f = []
            for (d = 0; d < h.length; d++) {
              c = h[d].tp$iternext()
              if (void 0 === c) return
              f.push(c)
            }
            return f
          }
        } else
          (b = self.Sk.abstr.iter(b)),
            (k = function() {
              return b.tp$iternext()
            })
        this.tp$iternext = function() {
          e = k()
          if (void 0 !== e) {
            if (a === self.Sk.builtin.none.none$)
              return e instanceof Array && (e = new self.Sk.builtin.tuple(e)), e
            e instanceof Array || (e = [e])
            return self.Sk.misceval.applyOrSuspend(a, void 0, void 0, void 0, e)
          }
        }
        this.tp$iter = function() {
          return this
        }
        this.__class__ = self.Sk.builtin.map_
        return this
      }
      self.Sk.abstr.setUpInheritance("map", self.Sk.builtin.map_, self.Sk.builtin.object)
      self.Sk.builtin.map_.prototype.__iter__ = new self.Sk.builtin.func(function(a) {
        return a.tp$iter()
      })
      self.Sk.builtin.map_.prototype.next$ = function(a) {
        return a.tp$iternext()
      }
      self.Sk.builtin.map_.prototype.$r = function() {
        return new self.Sk.builtin.str("<map object>")
      }
      self.Sk.exportSymbol("Sk.builtin.map_", self.Sk.builtin.map_)
    },
    function(m, p) {
      var a = {
        T_ENDMARKER: 0,
        T_NAME: 1,
        T_NUMBER: 2,
        T_STRING: 3,
        T_NEWLINE: 4,
        T_INDENT: 5,
        T_DEDENT: 6,
        T_LPAR: 7,
        T_RPAR: 8,
        T_LSQB: 9,
        T_RSQB: 10,
        T_COLON: 11,
        T_COMMA: 12,
        T_SEMI: 13,
        T_PLUS: 14,
        T_MINUS: 15,
        T_STAR: 16,
        T_SLASH: 17,
        T_VBAR: 18,
        T_AMPER: 19,
        T_LESS: 20,
        T_GREATER: 21,
        T_EQUAL: 22,
        T_DOT: 23,
        T_PERCENT: 24,
        T_LBRACE: 25,
        T_RBRACE: 26,
        T_EQEQUAL: 27,
        T_NOTEQUAL: 28,
        T_LESSEQUAL: 29,
        T_GREATEREQUAL: 30,
        T_TILDE: 31,
        T_CIRCUMFLEX: 32,
        T_LEFTSHIFT: 33,
        T_RIGHTSHIFT: 34,
        T_DOUBLESTAR: 35,
        T_PLUSEQUAL: 36,
        T_MINEQUAL: 37,
        T_STAREQUAL: 38,
        T_SLASHEQUAL: 39,
        T_PERCENTEQUAL: 40,
        T_AMPEREQUAL: 41,
        T_VBAREQUAL: 42,
        T_CIRCUMFLEXEQUAL: 43,
        T_LEFTSHIFTEQUAL: 44,
        T_RIGHTSHIFTEQUAL: 45,
        T_DOUBLESTAREQUAL: 46,
        T_DOUBLESLASH: 47,
        T_DOUBLESLASHEQUAL: 48,
        T_AT: 49,
        T_ATEQUAL: 50,
        T_RARROW: 51,
        T_ELLIPSIS: 52,
        T_OP: 53,
        T_AWAIT: 54,
        T_ASYNC: 55,
        T_ERRORTOKEN: 56,
        T_NT_OFFSET: 256,
        T_N_TOKENS: 60,
        T_COMMENT: 57,
        T_NL: 58,
        T_ENCODING: 59,
      }
      m = {
        "!=": a.NOTEQUAL,
        "%": a.PERCENT,
        "%=": a.PERCENTEQUAL,
        "&": a.AMPER,
        "&=": a.AMPEREQUAL,
        "(": a.LPAR,
        ")": a.RPAR,
        "*": a.STAR,
        "**": a.DOUBLESTAR,
        "**=": a.DOUBLESTAREQUAL,
        "*=": a.STAREQUAL,
        "+": a.PLUS,
        "+=": a.PLUSEQUAL,
        ",": a.COMMA,
        "-": a.MINUS,
        "-=": a.MINEQUAL,
        "->": a.RARROW,
        ".": a.DOT,
        "...": a.ELLIPSIS,
        "/": a.SLASH,
        "//": a.DOUBLESLASH,
        "//=": a.DOUBLESLASHEQUAL,
        "/=": a.SLASHEQUAL,
        ":": a.COLON,
        ":=": a.COLONEQUAL,
        ";": a.SEMI,
        "<": a.LESS,
        "<<": a.LEFTSHIFT,
        "<<=": a.LEFTSHIFTEQUAL,
        "<=": a.LESSEQUAL,
        "=": a.EQUAL,
        "==": a.EQEQUAL,
        ">": a.GREATER,
        ">=": a.GREATEREQUAL,
        ">>": a.RIGHTSHIFT,
        ">>=": a.RIGHTSHIFTEQUAL,
        "@": a.AT,
        "@=": a.ATEQUAL,
        "[": a.LSQB,
        "]": a.RSQB,
        "^": a.CIRCUMFLEX,
        "^=": a.CIRCUMFLEXEQUAL,
        "{": a.LBRACE,
        "|": a.VBAR,
        "|=": a.VBAREQUAL,
        "}": a.RBRACE,
        "~": a.TILDE,
      }
      var b = {}
      ;(function() {
        for (var c in a) b[a[c]] = c
      })()
      ;["tok_name", "ISTERMINAL", "ISNONTERMINAL", "ISEOF"].concat(
        Object.keys(b).map(function(a) {
          return b[a]
        }),
      )
      self.Sk.token = {}
      self.Sk.token.tokens = a
      self.Sk.token.tok_name = b
      self.Sk.token.EXACT_TOKEN_TYPES = m
      self.Sk.token.ISTERMINAL = function(b) {
        return b < a.T_NT_OFFSET
      }
      self.Sk.token.ISNONTERMINAL = function(b) {
        return b >= a.T_NT_OFFSET
      }
      self.Sk.token.ISEOF = function(b) {
        return b == a.T_ENDMARKER
      }
      self.Sk.exportSymbol("Sk.token", self.Sk.token)
      self.Sk.exportSymbol("Sk.token.tokens", self.Sk.token.tokens)
      self.Sk.exportSymbol("Sk.token.tok_name", self.Sk.token.tok_name)
      self.Sk.exportSymbol("Sk.token.EXACT_TOKEN_TYPES")
      self.Sk.exportSymbol("Sk.token.ISTERMINAL", self.Sk.token.ISTERMINAL)
      self.Sk.exportSymbol("Sk.token.ISNONTERMINAL", self.Sk.token.ISNONTERMINAL)
      self.Sk.exportSymbol("Sk.token.ISEOF", self.Sk.token.ISEOF)
    },
    function(m, p) {
      function a(a, b, c, d, e) {
        this.type = a
        this.string = b
        this.start = c
        this.end = d
        this.line = e
      }
      function b(a) {
        return "(" + Array.prototype.slice.call(arguments).join("|") + ")"
      }
      function c(a) {
        return b.apply(null, arguments) + "?"
      }
      function d(a, b) {
        for (var c = a.length; c--; ) if (a[c] === b) return !0
        return !1
      }
      function e() {
        return " FR RF Br BR Fr r B R b bR f rb rB F Rf U rF u RB br fR fr rf Rb".split(
          " ",
        )
      }
      var f = self.Sk.token.tokens
      const g = self.Sk.builtin.SyntaxError,
        h = self.Sk.builtin.SyntaxError
      a.prototype.exact_type = function() {
        return this.type == f.T_OP && this.string in self.Sk.token.EXACT_TOKEN_TYPES
          ? self.Sk.token.EXACT_TOKEN_TYPES[this.string]
          : this.type
      }
      var k = /[\\^$.*+?()[\]{}|]/g,
        l = RegExp(k.source)
      const r = (function() {
        var a = b(
            "[A-Z]",
            "[a-z]",
            "[\\u{10B99}-\\u{10B9C}\\u{112A9}\\u{115DC}-\\u{115DD}\\u034F\\u115F-\\u1160\\u17B4-\\u17B5\\u2065\\u3164\\uFFA0\\uFFF0-\\uFFF8\\u{E0000}\\u{E0002}-\\u{E001F}\\u{E0080}-\\u{E00FF}\\u{E01F0}-\\u{E0FFF}\\u{112A9}\\u00D7]",
            "[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u06E5-\\u06E6\\u07F4-\\u07F5\\u0971\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1DFD-\\u1DFF\\u2E2F\\u30FC\\uA67F\\uA69C-\\uA69D\\uA717-\\uA71F\\uA788\\uA7F8-\\uA7F9\\uAB5C-\\uAB5F\\uFF70\\uFF9E-\\uFF9F\\u{16F93}-\\u{16F9F}\\u02D0-\\u02D1\\u0640\\u07FA\\u0E46\\u0EC6\\u1843\\u1AA7\\u1C7B\\u3005\\u3031-\\u3035\\u309D-\\u309E\\u30FC-\\u30FE\\uA015\\uA60C\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3-\\uAAF4\\uFF70\\u{16B42}-\\u{16B43}\\u{16FE0}-\\u{16FE1}\\u02B0-\\u02B8\\u02C0-\\u02C1\\u02E0-\\u02E4\\u037A\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C-\\u2C7D\\uA69C-\\uA69D\\uA770\\uA7F8-\\uA7F9\\uAB5C-\\uAB5F\\uFF9E-\\uFF9F\\u02B2\\u1D62\\u1DA4\\u1DA8\\u2071\\u2C7C\\u2E18-\\u2E19\\u2E2F]",
            "[\\u2135-\\u2138\\u{1EE00}-\\u{1EE03}\\u{1EE05}-\\u{1EE1F}\\u{1EE21}-\\u{1EE22}\\u{1EE24}\\u{1EE27}\\u{1EE29}-\\u{1EE32}\\u{1EE34}-\\u{1EE37}\\u{1EE39}\\u{1EE3B}\\u{1EE42}\\u{1EE47}\\u{1EE49}\\u{1EE4B}\\u{1EE4D}-\\u{1EE4F}\\u{1EE51}-\\u{1EE52}\\u{1EE54}\\u{1EE57}\\u{1EE59}\\u{1EE5B}\\u{1EE5D}\\u{1EE5F}\\u{1EE61}-\\u{1EE62}\\u{1EE64}\\u{1EE67}-\\u{1EE6A}\\u{1EE6C}-\\u{1EE72}\\u{1EE74}-\\u{1EE77}\\u{1EE79}-\\u{1EE7C}\\u{1EE7E}\\u{1EE80}-\\u{1EE89}\\u{1EE8B}-\\u{1EE9B}\\u{1EEA1}-\\u{1EEA3}\\u{1EEA5}-\\u{1EEA9}\\u{1EEAB}-\\u{1EEBB}\\u3006\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9\\u{17000}-\\u{187F1}\\u{18800}-\\u{18AF2}\\u{1B170}-\\u{1B2FB}\\u{20000}-\\u{2A6D6}\\u{2A700}-\\u{2B734}\\u{2B740}-\\u{2B81D}\\u{2B820}-\\u{2CEA1}\\u{2CEB0}-\\u{2EBE0}\\u{2F800}-\\u{2FA1D}\\uAAC0\\uAAC2\\uFE20-\\uFE2F\\u{10D22}-\\u{10D23}\\u{1135D}\\u00AA\\u00BA\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uFA0E-\\uFA0F\\uFA11\\uFA13-\\uFA14\\uFA1F\\uFA21\\uFA23-\\uFA24\\uFA27-\\uFA29\\u{20000}-\\u{2A6D6}\\u{2A700}-\\u{2B734}\\u{2B740}-\\u{2B81D}\\u{2B820}-\\u{2CEA1}\\u{2CEB0}-\\u{2EBE0}\\u115F-\\u1160\\u3164\\uFFA0\\u0673\\u17A3-\\u17A4\\u0E40-\\u0E44\\u0EC0-\\u0EC4\\u19B5-\\u19B7\\u19BA\\uAAB5-\\uAAB6\\uAAB9\\uAABB-\\uAABC]",
            "[\\u3007\\u3021-\\u3029\\u3038-\\u303A\\u2170-\\u217F\\u2160-\\u216F]",
            "_",
            "[\\u1885-\\u1886\\u2118\\u212E\\u309B-\\u309C]",
          ),
          c = b(
            a,
            "[\\u104A-\\u104B\\u102B-\\u102C\\u102D-\\u1030\\u1031\\u1032-\\u1036\\u1038\\u103B-\\u103C\\u103D-\\u103E\\u1056-\\u1057\\u1058-\\u1059\\u105E-\\u1060\\u1062\\u1067-\\u1068\\u1071-\\u1074\\u1082\\u1083-\\u1084\\u1085-\\u1086\\u109C\\u109D\\u1037\\u1039-\\u103A\\u1087-\\u108C\\u108D\\u108F\\u109A-\\u109B\\uA9E5\\uAA7B\\uAA7C\\uAA7D\\uA9E6\\uAA70\\u104A-\\u104B]",
            "[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E-\\u094F\\u0982-\\u0983\\u09BE-\\u09C0\\u09C7-\\u09C8\\u09CB-\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB-\\u0ACC\\u0B02-\\u0B03\\u0B3E\\u0B40\\u0B47-\\u0B48\\u0B4B-\\u0B4C\\u0B57\\u0BBE-\\u0BBF\\u0BC1-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82-\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7-\\u0CC8\\u0CCA-\\u0CCB\\u0CD5-\\u0CD6\\u0D02-\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82-\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0F7F\\u102B-\\u102C\\u1031\\u1038\\u103B-\\u103C\\u1056-\\u1057\\u1062\\u1067-\\u1068\\u1083-\\u1084\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930-\\u1931\\u1933-\\u1938\\u1A19-\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63-\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B82\\u1BA1\\u1BA6-\\u1BA7\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1C24-\\u1C2B\\u1C34-\\u1C35\\u1CF2-\\u1CF3\\uA823-\\uA824\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C3\\uA952\\uA983\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BD-\\uA9BF\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA4D\\uAAEB\\uAAEE-\\uAAEF\\uAAF5\\uABE3-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEA\\u{11000}\\u{11002}\\u{11082}\\u{110B0}-\\u{110B2}\\u{110B7}-\\u{110B8}\\u{1112C}\\u{11145}-\\u{11146}\\u{11182}\\u{111B3}-\\u{111B5}\\u{111BF}\\u{1122C}-\\u{1122E}\\u{11232}-\\u{11233}\\u{112E0}-\\u{112E2}\\u{11302}-\\u{11303}\\u{1133E}-\\u{1133F}\\u{11341}-\\u{11344}\\u{11347}-\\u{11348}\\u{1134B}-\\u{1134C}\\u{11357}\\u{11362}-\\u{11363}\\u{11435}-\\u{11437}\\u{11440}-\\u{11441}\\u{11445}\\u{114B0}-\\u{114B2}\\u{114B9}\\u{114BB}-\\u{114BE}\\u{114C1}\\u{115AF}-\\u{115B1}\\u{115B8}-\\u{115BB}\\u{115BE}\\u{11630}-\\u{11632}\\u{1163B}-\\u{1163C}\\u{1163E}\\u{116AC}\\u{116AE}-\\u{116AF}\\u{11720}-\\u{11721}\\u{11726}\\u{1182C}-\\u{1182E}\\u{11838}\\u{11A39}\\u{11A57}-\\u{11A58}\\u{11A97}\\u{11C2F}\\u{11C3E}\\u{11CA9}\\u{11CB1}\\u{11CB4}\\u{11D8A}-\\u{11D8E}\\u{11D93}-\\u{11D94}\\u{11D96}\\u{11EF5}-\\u{11EF6}\\u{16F51}-\\u{16F7E}\\u0F3E-\\u0F3F\\u1087-\\u108C\\u108F\\u109A-\\u109B\\u1B44\\u1BAA\\u1CE1\\u1CF7\\u302E-\\u302F\\uA953\\uA9C0\\uAA7B\\uAA7D\\uABEC\\u{111C0}\\u{11235}\\u{1134D}\\u{116B6}\\u{1D16D}-\\u{1D172}\\u09BE\\u09D7\\u0B3E\\u0B57\\u0BBE\\u0BD7\\u0CC2\\u0CD5-\\u0CD6\\u0D3E\\u0D57\\u0DCF\\u0DDF\\u302E-\\u302F\\u{1133E}\\u{11357}\\u{114B0}\\u{114BD}\\u{115AF}\\u{1D165}\\u{1D16E}-\\u{1D172}]",
            "[\\u{1D7CE}-\\u{1D7FF}\\uFF10-\\uFF19]",
            "\\u2040",
            "[\\u00B7\\u0387\\u1369-\\u1371\\u19DA]",
          )
        if (!1 === RegExp().unicode)
          return new RegExp("^" + a + "+" + c + "*$", "u")
        a = b("[A-Z]", "[a-z]", "_")
        c = b(a, "[0-9]")
        return new RegExp("^" + a + "+" + c + "*$")
      })()
      ;(function(a) {
        return b.apply(null, arguments) + "*"
      })("\\\\\\r?\\n[ \\f\\t]*")
      c("#[^\\r\\n]*")
      m =
        b(
          "[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?",
          "\\.[0-9](?:_?[0-9])*",
        ) + c("[eE][-+]?[0-9](?:_?[0-9])*")
      var n = b(m, "[0-9](?:_?[0-9])*[eE][-+]?[0-9](?:_?[0-9])*"),
        q = b("[0-9](?:_?[0-9])*[jJ]", n + "[jJ]")
      m = b.apply(null, e())
      p = b(m + "'''", m + '"""')
      b(
        m + "'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'",
        m + '"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"',
      )
      var D = Object.keys(self.Sk.token.EXACT_TOKEN_TYPES).sort()
      D = b.apply(
        this,
        D.reverse().map(function(a) {
          return a && l.test(a) ? a.replace(k, "\\$&") : a
        }),
      )
      var x = b("\\r?\\n", D),
        H = b(
          m + "'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*" + b("'", "\\\\\\r?\\n"),
          m + '"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' + b('"', "\\\\\\r?\\n"),
        ),
        J = b("\\\\\\r?\\n|$", "#[^\\r\\n]*", p),
        A = {}
      m = e()
      for (let a of m)
        (A[a + "'"] = "^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'"),
          (A[a + '"'] = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"'),
          (A[a + "'''"] = "^[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''"),
          (A[a + '"""'] = '^[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""')
      let C = [],
        K = []
      for (let a of m)
        C.push(a + '"'), C.push(a + "'"), K.push(a + '"""'), K.push(a + "'''")
      self.Sk._tokenize = function(c, e, k, l) {
        var m = self.Sk.__future__.python3 ? "" : "(?:L?)"
        m = b(
          "0[xX](?:_?[0-9a-fA-F])+" + m,
          "0[bB](?:_?[01])+" + m,
          self.Sk.__future__.silent_octal_literal
            ? "0([oO]?)(?:_?[0-7])+" + m
            : "0([oO])(?:_?[0-7])+" + m,
          "(?:0(?:_?0)*|[1-9](?:_?[0-9])*)" + m,
        )
        m = b(q, n, m)
        m = "[ \\f\\t]*" + b(J, m, x, H, "\\w+")
        m = new RegExp(m)
        var p = 0,
          D = 0,
          B = 0,
          z = "",
          G = 0,
          S = null,
          I = [0],
          E,
          N = void 0,
          U = void 0,
          F,
          Q
        void 0 !== k &&
          ("utf-8-sig" == k && (k = "utf-8"),
          l(new a(f.T_ENCODING, k, [0, 0], [0, 0], "")))
        for (var y = (k = ""); ; ) {
          try {
            ;(k = y), (y = e())
          } catch (M) {
            y = ""
          }
          p += 1
          var u = 0,
            L = y.length
          if (z) {
            if (!y) throw new g("EOF in multi-line string", c, U[0], U[1])
            N.lastIndex = 0
            var t = N.exec(y)
            if (t)
              (u = F = t[0].length),
                l(new a(f.T_STRING, z + y.substring(0, F), U, [p, F], S + y)),
                (z = ""),
                (G = 0),
                (S = null)
            else {
              G &&
              "\\\n" !== y.substring(y.length - 2) &&
              "\\\r\n" !== y.substring(y.length - 3)
                ? (l(new a(f.T_ERRORTOKEN, z + y, U, [p, y.length], S)),
                  (z = ""),
                  (S = null))
                : ((z += y), (S += y))
              continue
            }
          } else if (0 != D || B) {
            if (!y) throw new g("EOF in multi-line statement", c, p, 0)
            B = 0
          } else {
            if (!y) break
            for (E = 0; u < L; ) {
              if (" " == y[u]) E += 1
              else if ("\t" == y[u]) E = 8 * Math.floor(E / 8 + 1)
              else if ("\f" == y[u]) E = 0
              else break
              u += 1
            }
            if (u == L) break
            if (d("#\r\n", y[u])) {
              if ("#" == y[u]) {
                E = y.substring(u)
                for (
                  L = E.length;
                  0 < L && -1 !== "\r\n".indexOf(E.charAt(L - 1));
                  --L
                );
                L = E.substring(0, L)
                l(new a(f.T_COMMENT, L, [p, u], [p, u + L.length], y))
                u += L.length
              }
              l(new a(f.T_NL, y.substring(u), [p, u], [p, y.length], y))
              continue
            }
            E > I[I.length - 1] &&
              (I.push(E),
              l(new a(f.T_INDENT, y.substring(u), [p, 0], [p, u], y)))
            for (; E < I[I.length - 1]; ) {
              if (!d(I, E))
                throw new h(
                  "unindent does not match any outer indentation level",
                  c,
                  p,
                  u,
                )
              I = I.slice(0, -1)
              l(new a(f.T_DEDENT, "", [p, u], [p, u], y))
            }
          }
          for (; u < L; ) {
            for (E = y.charAt(u); " " === E || "\f" === E || "\t" === E; )
              (u += 1), (E = y.charAt(u))
            if ((Q = m.exec(y.substring(u)))) {
              if (
                ((E = u),
                (F = E + Q[1].length),
                (Q = [p, E]),
                (t = [p, F]),
                (u = F),
                E != F)
              ) {
                F = y.substring(E, F)
                var v = y[E]
                if (d("0123456789", v) || ("." == v && "." != F && "..." != F))
                  l(new a(f.T_NUMBER, F, Q, t, y))
                else if (d("\r\n", v))
                  0 < D
                    ? l(new a(f.T_NL, F, Q, t, y))
                    : l(new a(f.T_NEWLINE, F, Q, t, y))
                else if ("#" == v) l(new a(f.T_COMMENT, F, Q, t, y))
                else if (d(K, F))
                  if (((N = RegExp(A[F])), (t = N.exec(y.substring(u)))))
                    (u = t[0].length + u),
                      (F = y.substring(E, u)),
                      l(new a(f.T_STRING, F, Q, [p, u], y))
                  else {
                    U = [p, E]
                    z = y.substring(E)
                    S = y
                    break
                  }
                else if (
                  d(C, v) ||
                  d(C, F.substring(0, 2)) ||
                  d(C, F.substring(0, 3))
                )
                  if ("\n" == F[F.length - 1]) {
                    U = [p, E]
                    N = RegExp(A[v] || A[F[1]] || A[F[2]])
                    z = y.substring(E)
                    G = 1
                    S = y
                    break
                  } else l(new a(f.T_STRING, F, Q, t, y))
                else
                  (E = v.normalize("NFKC")),
                    r.test(E)
                      ? l(new a(f.T_NAME, F, Q, t, y))
                      : "\\" == v
                      ? (B = 1)
                      : (d("([{", v) ? (D += 1) : d(")]}", v) && --D,
                        l(new a(f.T_OP, F, Q, t, y)))
              }
            } else
              l(new a(f.T_ERRORTOKEN, y[u], [p, u], [p, u + 1], y)), (u += 1)
          }
        }
        k &&
          !d("\r\n", k[k.length - 1]) &&
          l(
            new a(
              f.T_NEWLINE,
              "",
              [p - 1, k.length],
              [p - 1, k.length + 1],
              "",
            ),
          )
        for (var W in I.slice(1)) l(new a(f.T_DEDENT, "", [p, 0], [p, 0], ""))
        l(new a(f.T_ENDMARKER, "", [p, 0], [p, 0], ""))
      }
      self.Sk.exportSymbol("Sk._tokenize", self.Sk._tokenize)
    },
    function(m, p) {
      self.Sk.OpMap = {
        "(": self.Sk.token.tokens.T_LPAR,
        ")": self.Sk.token.tokens.T_RPAR,
        "[": self.Sk.token.tokens.T_LSQB,
        "]": self.Sk.token.tokens.T_RSQB,
        ":": self.Sk.token.tokens.T_COLON,
        ",": self.Sk.token.tokens.T_COMMA,
        ";": self.Sk.token.tokens.T_SEMI,
        "+": self.Sk.token.tokens.T_PLUS,
        "-": self.Sk.token.tokens.T_MINUS,
        "*": self.Sk.token.tokens.T_STAR,
        "/": self.Sk.token.tokens.T_SLASH,
        "|": self.Sk.token.tokens.T_VBAR,
        "&": self.Sk.token.tokens.T_AMPER,
        "<": self.Sk.token.tokens.T_LESS,
        ">": self.Sk.token.tokens.T_GREATER,
        "=": self.Sk.token.tokens.T_EQUAL,
        ".": self.Sk.token.tokens.T_DOT,
        "%": self.Sk.token.tokens.T_PERCENT,
        "`": self.Sk.token.tokens.T_BACKQUOTE,
        "{": self.Sk.token.tokens.T_LBRACE,
        "}": self.Sk.token.tokens.T_RBRACE,
        "@": self.Sk.token.tokens.T_AT,
        "@=": self.Sk.token.tokens.T_ATEQUAL,
        "==": self.Sk.token.tokens.T_EQEQUAL,
        "!=": self.Sk.token.tokens.T_NOTEQUAL,
        "<>": self.Sk.token.tokens.T_NOTEQUAL,
        "<=": self.Sk.token.tokens.T_LESSEQUAL,
        ">=": self.Sk.token.tokens.T_GREATEREQUAL,
        "~": self.Sk.token.tokens.T_TILDE,
        "^": self.Sk.token.tokens.T_CIRCUMFLEX,
        "<<": self.Sk.token.tokens.T_LEFTSHIFT,
        ">>": self.Sk.token.tokens.T_RIGHTSHIFT,
        "**": self.Sk.token.tokens.T_DOUBLESTAR,
        "+=": self.Sk.token.tokens.T_PLUSEQUAL,
        "-=": self.Sk.token.tokens.T_MINEQUAL,
        "*=": self.Sk.token.tokens.T_STAREQUAL,
        "/=": self.Sk.token.tokens.T_SLASHEQUAL,
        "%=": self.Sk.token.tokens.T_PERCENTEQUAL,
        "&=": self.Sk.token.tokens.T_AMPEREQUAL,
        "|=": self.Sk.token.tokens.T_VBAREQUAL,
        "^=": self.Sk.token.tokens.T_CIRCUMFLEXEQUAL,
        "<<=": self.Sk.token.tokens.T_LEFTSHIFTEQUAL,
        ">>=": self.Sk.token.tokens.T_RIGHTSHIFTEQUAL,
        "**=": self.Sk.token.tokens.T_DOUBLESTAREQUAL,
        "//": self.Sk.token.tokens.T_DOUBLESLASH,
        "//=": self.Sk.token.tokens.T_DOUBLESLASHEQUAL,
        "->": self.Sk.token.tokens.T_RARROW,
        "...": self.Sk.token.tokens.T_ELLIPSIS,
      }
      self.Sk.ParseTables = {
        sym: {
          and_expr: 257,
          and_test: 258,
          annassign: 259,
          arglist: 260,
          argument: 261,
          arith_expr: 262,
          assert_stmt: 263,
          async_funcdef: 264,
          async_stmt: 265,
          atom: 266,
          atom_expr: 267,
          augassign: 268,
          break_stmt: 269,
          classdef: 270,
          comp_for: 271,
          comp_if: 272,
          comp_iter: 273,
          comp_op: 274,
          comparison: 275,
          compound_stmt: 276,
          continue_stmt: 277,
          debugger_stmt: 278,
          decorated: 279,
          decorator: 280,
          decorators: 281,
          del_stmt: 282,
          dictorsetmaker: 283,
          dotted_as_name: 284,
          dotted_as_names: 285,
          dotted_name: 286,
          encoding_decl: 287,
          eval_input: 288,
          except_clause: 289,
          expr: 290,
          expr_stmt: 291,
          exprlist: 292,
          factor: 293,
          file_input: 294,
          flow_stmt: 295,
          for_stmt: 296,
          funcdef: 297,
          global_stmt: 298,
          if_stmt: 299,
          import_as_name: 300,
          import_as_names: 301,
          import_from: 302,
          import_name: 303,
          import_stmt: 304,
          lambdef: 305,
          lambdef_nocond: 306,
          nonlocal_stmt: 307,
          not_test: 308,
          or_test: 309,
          parameters: 310,
          pass_stmt: 311,
          power: 312,
          print_stmt: 313,
          raise_stmt: 314,
          return_stmt: 315,
          shift_expr: 316,
          simple_stmt: 317,
          single_input: 256,
          sliceop: 318,
          small_stmt: 319,
          star_expr: 320,
          stmt: 321,
          subscript: 322,
          subscriptlist: 323,
          suite: 324,
          term: 325,
          test: 326,
          test_nocond: 327,
          testlist: 328,
          testlist_comp: 329,
          testlist_star_expr: 330,
          tfpdef: 331,
          trailer: 332,
          try_stmt: 333,
          typedargslist: 334,
          varargslist: 335,
          vfpdef: 336,
          while_stmt: 337,
          with_item: 338,
          with_stmt: 339,
          xor_expr: 340,
          yield_arg: 341,
          yield_expr: 342,
          yield_stmt: 343,
        },
        number2symbol: {
          256: "single_input",
          257: "and_expr",
          258: "and_test",
          259: "annassign",
          260: "arglist",
          261: "argument",
          262: "arith_expr",
          263: "assert_stmt",
          264: "async_funcdef",
          265: "async_stmt",
          266: "atom",
          267: "atom_expr",
          268: "augassign",
          269: "break_stmt",
          270: "classdef",
          271: "comp_for",
          272: "comp_if",
          273: "comp_iter",
          274: "comp_op",
          275: "comparison",
          276: "compound_stmt",
          277: "continue_stmt",
          278: "debugger_stmt",
          279: "decorated",
          280: "decorator",
          281: "decorators",
          282: "del_stmt",
          283: "dictorsetmaker",
          284: "dotted_as_name",
          285: "dotted_as_names",
          286: "dotted_name",
          287: "encoding_decl",
          288: "eval_input",
          289: "except_clause",
          290: "expr",
          291: "expr_stmt",
          292: "exprlist",
          293: "factor",
          294: "file_input",
          295: "flow_stmt",
          296: "for_stmt",
          297: "funcdef",
          298: "global_stmt",
          299: "if_stmt",
          300: "import_as_name",
          301: "import_as_names",
          302: "import_from",
          303: "import_name",
          304: "import_stmt",
          305: "lambdef",
          306: "lambdef_nocond",
          307: "nonlocal_stmt",
          308: "not_test",
          309: "or_test",
          310: "parameters",
          311: "pass_stmt",
          312: "power",
          313: "print_stmt",
          314: "raise_stmt",
          315: "return_stmt",
          316: "shift_expr",
          317: "simple_stmt",
          318: "sliceop",
          319: "small_stmt",
          320: "star_expr",
          321: "stmt",
          322: "subscript",
          323: "subscriptlist",
          324: "suite",
          325: "term",
          326: "test",
          327: "test_nocond",
          328: "testlist",
          329: "testlist_comp",
          330: "testlist_star_expr",
          331: "tfpdef",
          332: "trailer",
          333: "try_stmt",
          334: "typedargslist",
          335: "varargslist",
          336: "vfpdef",
          337: "while_stmt",
          338: "with_item",
          339: "with_stmt",
          340: "xor_expr",
          341: "yield_arg",
          342: "yield_expr",
          343: "yield_stmt",
        },
        dfas: {
          256: [
            [
              [
                [1, 1],
                [2, 1],
                [3, 2],
              ],
              [[0, 1]],
              [[2, 1]],
            ],
            {
              2: 1,
              4: 1,
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              10: 1,
              11: 1,
              12: 1,
              13: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              20: 1,
              21: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              34: 1,
              35: 1,
              36: 1,
              37: 1,
              38: 1,
              39: 1,
              40: 1,
              41: 1,
              42: 1,
              43: 1,
            },
          ],
          257: [
            [
              [[44, 1]],
              [
                [45, 0],
                [0, 1],
              ],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          258: [
            [
              [[46, 1]],
              [
                [47, 0],
                [0, 1],
              ],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          259: [
            [
              [[48, 1]],
              [[49, 2]],
              [
                [50, 3],
                [0, 2],
              ],
              [[49, 4]],
              [[0, 4]],
            ],
            { 48: 1 },
          ],
          260: [
            [
              [[51, 1]],
              [
                [52, 2],
                [0, 1],
              ],
              [
                [51, 1],
                [0, 2],
              ],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              53: 1,
            },
          ],
          261: [
            [
              [
                [49, 1],
                [15, 2],
                [53, 2],
              ],
              [
                [50, 2],
                [54, 3],
                [0, 1],
              ],
              [[49, 3]],
              [[0, 3]],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              53: 1,
            },
          ],
          262: [
            [
              [[55, 1]],
              [
                [30, 0],
                [43, 0],
                [0, 1],
              ],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          263: [
            [
              [[24, 1]],
              [[49, 2]],
              [
                [52, 3],
                [0, 2],
              ],
              [[49, 4]],
              [[0, 4]],
            ],
            { 24: 1 },
          ],
          264: [[[[10, 1]], [[56, 2]], [[0, 2]]], { 10: 1 }],
          265: [
            [
              [[10, 1]],
              [
                [57, 2],
                [56, 2],
                [58, 2],
              ],
              [[0, 2]],
            ],
            { 10: 1 },
          ],
          266: [
            [
              [
                [6, 1],
                [25, 1],
                [33, 1],
                [9, 1],
                [11, 1],
                [12, 2],
                [35, 3],
                [38, 4],
                [19, 1],
                [7, 5],
              ],
              [[0, 1]],
              [
                [59, 1],
                [60, 6],
              ],
              [
                [61, 1],
                [62, 7],
                [63, 7],
              ],
              [
                [64, 1],
                [63, 8],
              ],
              [
                [7, 5],
                [0, 5],
              ],
              [[59, 1]],
              [[61, 1]],
              [[64, 1]],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              25: 1,
              33: 1,
              35: 1,
              38: 1,
            },
          ],
          267: [
            [
              [
                [29, 1],
                [65, 2],
              ],
              [[65, 2]],
              [
                [66, 2],
                [0, 2],
              ],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              25: 1,
              29: 1,
              33: 1,
              35: 1,
              38: 1,
            },
          ],
          268: [
            [
              [
                [67, 1],
                [68, 1],
                [69, 1],
                [70, 1],
                [71, 1],
                [72, 1],
                [73, 1],
                [74, 1],
                [75, 1],
                [76, 1],
                [77, 1],
                [78, 1],
                [79, 1],
              ],
              [[0, 1]],
            ],
            {
              67: 1,
              68: 1,
              69: 1,
              70: 1,
              71: 1,
              72: 1,
              73: 1,
              74: 1,
              75: 1,
              76: 1,
              77: 1,
              78: 1,
              79: 1,
            },
          ],
          269: [[[[39, 1]], [[0, 1]]], { 39: 1 }],
          270: [
            [
              [[13, 1]],
              [[25, 2]],
              [
                [48, 3],
                [35, 4],
              ],
              [[80, 5]],
              [
                [61, 6],
                [81, 7],
              ],
              [[0, 5]],
              [[48, 3]],
              [[61, 6]],
            ],
            { 13: 1 },
          ],
          271: [
            [
              [
                [10, 1],
                [34, 2],
              ],
              [[34, 2]],
              [[82, 3]],
              [[83, 4]],
              [[84, 5]],
              [
                [85, 6],
                [0, 5],
              ],
              [[0, 6]],
            ],
            { 10: 1, 34: 1 },
          ],
          272: [
            [
              [[37, 1]],
              [[86, 2]],
              [
                [85, 3],
                [0, 2],
              ],
              [[0, 3]],
            ],
            { 37: 1 },
          ],
          273: [
            [
              [
                [87, 1],
                [54, 1],
              ],
              [[0, 1]],
            ],
            { 10: 1, 34: 1, 37: 1 },
          ],
          274: [
            [
              [
                [88, 1],
                [89, 1],
                [8, 2],
                [90, 1],
                [88, 1],
                [83, 1],
                [91, 1],
                [92, 3],
                [93, 1],
                [94, 1],
              ],
              [[0, 1]],
              [[83, 1]],
              [
                [8, 1],
                [0, 3],
              ],
            ],
            { 8: 1, 83: 1, 88: 1, 89: 1, 90: 1, 91: 1, 92: 1, 93: 1, 94: 1 },
          ],
          275: [
            [
              [[95, 1]],
              [
                [96, 0],
                [0, 1],
              ],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          276: [
            [
              [
                [97, 1],
                [98, 1],
                [58, 1],
                [99, 1],
                [57, 1],
                [100, 1],
                [56, 1],
                [101, 1],
                [102, 1],
              ],
              [[0, 1]],
            ],
            { 4: 1, 10: 1, 13: 1, 20: 1, 21: 1, 34: 1, 37: 1, 41: 1, 42: 1 },
          ],
          277: [[[[40, 1]], [[0, 1]]], { 40: 1 }],
          278: [[[[17, 1]], [[0, 1]]], { 17: 1 }],
          279: [
            [
              [[103, 1]],
              [
                [56, 2],
                [104, 2],
                [99, 2],
              ],
              [[0, 2]],
            ],
            { 41: 1 },
          ],
          280: [
            [
              [[41, 1]],
              [[105, 2]],
              [
                [2, 4],
                [35, 3],
              ],
              [
                [61, 5],
                [81, 6],
              ],
              [[0, 4]],
              [[2, 4]],
              [[61, 5]],
            ],
            { 41: 1 },
          ],
          281: [
            [
              [[106, 1]],
              [
                [106, 1],
                [0, 1],
              ],
            ],
            { 41: 1 },
          ],
          282: [[[[27, 1]], [[82, 2]], [[0, 2]]], { 27: 1 }],
          283: [
            [
              [
                [49, 1],
                [107, 2],
                [53, 3],
              ],
              [
                [48, 4],
                [54, 5],
                [52, 6],
                [0, 1],
              ],
              [
                [54, 5],
                [52, 6],
                [0, 2],
              ],
              [[95, 7]],
              [[49, 7]],
              [[0, 5]],
              [
                [49, 8],
                [107, 8],
                [0, 6],
              ],
              [
                [54, 5],
                [52, 9],
                [0, 7],
              ],
              [
                [52, 6],
                [0, 8],
              ],
              [
                [49, 10],
                [53, 11],
                [0, 9],
              ],
              [[48, 12]],
              [[95, 13]],
              [[49, 13]],
              [
                [52, 9],
                [0, 13],
              ],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              53: 1,
            },
          ],
          284: [
            [
              [[105, 1]],
              [
                [108, 2],
                [0, 1],
              ],
              [[25, 3]],
              [[0, 3]],
            ],
            { 25: 1 },
          ],
          285: [
            [
              [[109, 1]],
              [
                [52, 0],
                [0, 1],
              ],
            ],
            { 25: 1 },
          ],
          286: [
            [
              [[25, 1]],
              [
                [110, 0],
                [0, 1],
              ],
            ],
            { 25: 1 },
          ],
          287: [[[[25, 1]], [[0, 1]]], { 25: 1 }],
          288: [
            [
              [[111, 1]],
              [
                [2, 1],
                [112, 2],
              ],
              [[0, 2]],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          289: [
            [
              [[113, 1]],
              [
                [49, 2],
                [0, 1],
              ],
              [
                [108, 3],
                [52, 3],
                [0, 2],
              ],
              [[49, 4]],
              [[0, 4]],
            ],
            { 113: 1 },
          ],
          290: [
            [
              [[114, 1]],
              [
                [115, 0],
                [0, 1],
              ],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          291: [
            [
              [[116, 1]],
              [
                [117, 2],
                [50, 3],
                [118, 4],
                [0, 1],
              ],
              [
                [111, 4],
                [62, 4],
              ],
              [
                [116, 5],
                [62, 5],
              ],
              [[0, 4]],
              [
                [50, 3],
                [0, 5],
              ],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          292: [
            [
              [
                [95, 1],
                [107, 1],
              ],
              [
                [52, 2],
                [0, 1],
              ],
              [
                [95, 1],
                [107, 1],
                [0, 2],
              ],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          293: [
            [
              [
                [119, 2],
                [30, 1],
                [22, 1],
                [43, 1],
              ],
              [[120, 2]],
              [[0, 2]],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          294: [
            [
              [
                [2, 0],
                [112, 1],
                [121, 0],
              ],
              [[0, 1]],
            ],
            {
              2: 1,
              4: 1,
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              10: 1,
              11: 1,
              12: 1,
              13: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              20: 1,
              21: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              34: 1,
              35: 1,
              36: 1,
              37: 1,
              38: 1,
              39: 1,
              40: 1,
              41: 1,
              42: 1,
              43: 1,
              112: 1,
            },
          ],
          295: [
            [
              [
                [122, 1],
                [123, 1],
                [124, 1],
                [125, 1],
                [126, 1],
              ],
              [[0, 1]],
            ],
            { 5: 1, 23: 1, 31: 1, 39: 1, 40: 1 },
          ],
          296: [
            [
              [[34, 1]],
              [[82, 2]],
              [[83, 3]],
              [[111, 4]],
              [[48, 5]],
              [[80, 6]],
              [
                [127, 7],
                [0, 6],
              ],
              [[48, 8]],
              [[80, 9]],
              [[0, 9]],
            ],
            { 34: 1 },
          ],
          297: [
            [
              [[4, 1]],
              [[25, 2]],
              [[128, 3]],
              [
                [48, 4],
                [129, 5],
              ],
              [[80, 6]],
              [[49, 7]],
              [[0, 6]],
              [[48, 4]],
            ],
            { 4: 1 },
          ],
          298: [
            [
              [[26, 1]],
              [[25, 2]],
              [
                [52, 1],
                [0, 2],
              ],
            ],
            { 26: 1 },
          ],
          299: [
            [
              [[37, 1]],
              [[49, 2]],
              [[48, 3]],
              [[80, 4]],
              [
                [127, 5],
                [130, 1],
                [0, 4],
              ],
              [[48, 6]],
              [[80, 7]],
              [[0, 7]],
            ],
            { 37: 1 },
          ],
          300: [
            [
              [[25, 1]],
              [
                [108, 2],
                [0, 1],
              ],
              [[25, 3]],
              [[0, 3]],
            ],
            { 25: 1 },
          ],
          301: [
            [
              [[131, 1]],
              [
                [52, 2],
                [0, 1],
              ],
              [
                [131, 1],
                [0, 2],
              ],
            ],
            { 25: 1 },
          ],
          302: [
            [
              [[36, 1]],
              [
                [105, 2],
                [19, 3],
                [110, 3],
              ],
              [[32, 4]],
              [
                [105, 2],
                [19, 3],
                [32, 4],
                [110, 3],
              ],
              [
                [132, 5],
                [15, 5],
                [35, 6],
              ],
              [[0, 5]],
              [[132, 7]],
              [[61, 5]],
            ],
            { 36: 1 },
          ],
          303: [[[[32, 1]], [[133, 2]], [[0, 2]]], { 32: 1 }],
          304: [
            [
              [
                [134, 1],
                [135, 1],
              ],
              [[0, 1]],
            ],
            { 32: 1, 36: 1 },
          ],
          305: [
            [
              [[14, 1]],
              [
                [48, 2],
                [136, 3],
              ],
              [[49, 4]],
              [[48, 2]],
              [[0, 4]],
            ],
            { 14: 1 },
          ],
          306: [
            [
              [[14, 1]],
              [
                [48, 2],
                [136, 3],
              ],
              [[86, 4]],
              [[48, 2]],
              [[0, 4]],
            ],
            { 14: 1 },
          ],
          307: [
            [
              [[18, 1]],
              [[25, 2]],
              [
                [52, 1],
                [0, 2],
              ],
            ],
            { 18: 1 },
          ],
          308: [
            [
              [
                [8, 1],
                [137, 2],
              ],
              [[46, 2]],
              [[0, 2]],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          309: [
            [
              [[138, 1]],
              [
                [139, 0],
                [0, 1],
              ],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          310: [
            [
              [[35, 1]],
              [
                [61, 2],
                [140, 3],
              ],
              [[0, 2]],
              [[61, 2]],
            ],
            { 35: 1 },
          ],
          311: [[[[28, 1]], [[0, 1]]], { 28: 1 }],
          312: [
            [
              [[141, 1]],
              [
                [53, 2],
                [0, 1],
              ],
              [[120, 3]],
              [[0, 3]],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              25: 1,
              29: 1,
              33: 1,
              35: 1,
              38: 1,
            },
          ],
          313: [
            [
              [[16, 1]],
              [
                [49, 2],
                [142, 3],
                [0, 1],
              ],
              [
                [52, 4],
                [0, 2],
              ],
              [[49, 5]],
              [
                [49, 2],
                [0, 4],
              ],
              [
                [52, 6],
                [0, 5],
              ],
              [[49, 7]],
              [
                [52, 8],
                [0, 7],
              ],
              [
                [49, 7],
                [0, 8],
              ],
            ],
            { 16: 1 },
          ],
          314: [
            [
              [[5, 1]],
              [
                [49, 2],
                [0, 1],
              ],
              [
                [36, 3],
                [52, 3],
                [0, 2],
              ],
              [[49, 4]],
              [
                [52, 5],
                [0, 4],
              ],
              [[49, 6]],
              [[0, 6]],
            ],
            { 5: 1 },
          ],
          315: [
            [
              [[23, 1]],
              [
                [111, 2],
                [0, 1],
              ],
              [[0, 2]],
            ],
            { 23: 1 },
          ],
          316: [
            [
              [[143, 1]],
              [
                [144, 0],
                [142, 0],
                [0, 1],
              ],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          317: [
            [
              [[145, 1]],
              [
                [2, 2],
                [146, 3],
              ],
              [[0, 2]],
              [
                [145, 1],
                [2, 2],
              ],
            ],
            {
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              35: 1,
              36: 1,
              38: 1,
              39: 1,
              40: 1,
              43: 1,
            },
          ],
          318: [
            [
              [[48, 1]],
              [
                [49, 2],
                [0, 1],
              ],
              [[0, 2]],
            ],
            { 48: 1 },
          ],
          319: [
            [
              [
                [147, 1],
                [148, 1],
                [149, 1],
                [150, 1],
                [151, 1],
                [152, 1],
                [153, 1],
                [154, 1],
                [155, 1],
                [156, 1],
              ],
              [[0, 1]],
            ],
            {
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              35: 1,
              36: 1,
              38: 1,
              39: 1,
              40: 1,
              43: 1,
            },
          ],
          320: [[[[15, 1]], [[95, 2]], [[0, 2]]], { 15: 1 }],
          321: [
            [
              [
                [1, 1],
                [3, 1],
              ],
              [[0, 1]],
            ],
            {
              4: 1,
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              10: 1,
              11: 1,
              12: 1,
              13: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              20: 1,
              21: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              34: 1,
              35: 1,
              36: 1,
              37: 1,
              38: 1,
              39: 1,
              40: 1,
              41: 1,
              42: 1,
              43: 1,
            },
          ],
          322: [
            [
              [
                [49, 1],
                [48, 2],
              ],
              [
                [48, 2],
                [0, 1],
              ],
              [
                [49, 3],
                [157, 4],
                [0, 2],
              ],
              [
                [157, 4],
                [0, 3],
              ],
              [[0, 4]],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              48: 1,
            },
          ],
          323: [
            [
              [[158, 1]],
              [
                [52, 2],
                [0, 1],
              ],
              [
                [158, 1],
                [0, 2],
              ],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              48: 1,
            },
          ],
          324: [
            [
              [
                [1, 1],
                [2, 2],
              ],
              [[0, 1]],
              [[159, 3]],
              [[121, 4]],
              [
                [160, 1],
                [121, 4],
              ],
            ],
            {
              2: 1,
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              35: 1,
              36: 1,
              38: 1,
              39: 1,
              40: 1,
              43: 1,
            },
          ],
          325: [
            [
              [[120, 1]],
              [
                [161, 0],
                [15, 0],
                [162, 0],
                [41, 0],
                [163, 0],
                [0, 1],
              ],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          326: [
            [
              [
                [84, 1],
                [164, 2],
              ],
              [
                [37, 3],
                [0, 1],
              ],
              [[0, 2]],
              [[84, 4]],
              [[127, 5]],
              [[49, 2]],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          327: [
            [
              [
                [165, 1],
                [84, 1],
              ],
              [[0, 1]],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          328: [
            [
              [[49, 1]],
              [
                [52, 2],
                [0, 1],
              ],
              [
                [49, 1],
                [0, 2],
              ],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          329: [
            [
              [
                [49, 1],
                [107, 1],
              ],
              [
                [54, 2],
                [52, 3],
                [0, 1],
              ],
              [[0, 2]],
              [
                [49, 4],
                [107, 4],
                [0, 3],
              ],
              [
                [52, 3],
                [0, 4],
              ],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          330: [
            [
              [
                [49, 1],
                [107, 1],
              ],
              [
                [52, 2],
                [0, 1],
              ],
              [
                [49, 1],
                [107, 1],
                [0, 2],
              ],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          331: [
            [
              [[25, 1]],
              [
                [48, 2],
                [0, 1],
              ],
              [[49, 3]],
              [[0, 3]],
            ],
            { 25: 1 },
          ],
          332: [
            [
              [
                [35, 1],
                [110, 2],
                [38, 3],
              ],
              [
                [61, 4],
                [81, 5],
              ],
              [[25, 4]],
              [[166, 6]],
              [[0, 4]],
              [[61, 4]],
              [[64, 4]],
            ],
            { 35: 1, 38: 1, 110: 1 },
          ],
          333: [
            [
              [[20, 1]],
              [[48, 2]],
              [[80, 3]],
              [
                [167, 4],
                [168, 5],
              ],
              [[48, 6]],
              [[48, 7]],
              [[80, 8]],
              [[80, 9]],
              [
                [167, 4],
                [127, 10],
                [168, 5],
                [0, 8],
              ],
              [[0, 9]],
              [[48, 11]],
              [[80, 12]],
              [
                [168, 5],
                [0, 12],
              ],
            ],
            { 20: 1 },
          ],
          334: [
            [
              [
                [15, 1],
                [169, 2],
                [53, 3],
              ],
              [
                [169, 4],
                [52, 5],
                [0, 1],
              ],
              [
                [50, 6],
                [52, 7],
                [0, 2],
              ],
              [[169, 8]],
              [
                [52, 5],
                [0, 4],
              ],
              [
                [169, 9],
                [53, 3],
                [0, 5],
              ],
              [[49, 10]],
              [
                [15, 11],
                [169, 2],
                [53, 3],
                [0, 7],
              ],
              [
                [52, 12],
                [0, 8],
              ],
              [
                [50, 13],
                [52, 5],
                [0, 9],
              ],
              [
                [52, 7],
                [0, 10],
              ],
              [
                [169, 14],
                [52, 15],
                [0, 11],
              ],
              [[0, 12]],
              [[49, 4]],
              [
                [52, 15],
                [0, 14],
              ],
              [
                [169, 16],
                [53, 3],
                [0, 15],
              ],
              [
                [50, 17],
                [52, 15],
                [0, 16],
              ],
              [[49, 14]],
            ],
            { 15: 1, 25: 1, 53: 1 },
          ],
          335: [
            [
              [
                [15, 1],
                [53, 2],
                [170, 3],
              ],
              [
                [170, 5],
                [52, 4],
                [0, 1],
              ],
              [[170, 6]],
              [
                [50, 7],
                [52, 8],
                [0, 3],
              ],
              [
                [53, 2],
                [170, 9],
                [0, 4],
              ],
              [
                [52, 4],
                [0, 5],
              ],
              [
                [52, 10],
                [0, 6],
              ],
              [[49, 11]],
              [
                [15, 12],
                [53, 2],
                [170, 3],
                [0, 8],
              ],
              [
                [50, 13],
                [52, 4],
                [0, 9],
              ],
              [[0, 10]],
              [
                [52, 8],
                [0, 11],
              ],
              [
                [52, 15],
                [170, 14],
                [0, 12],
              ],
              [[49, 5]],
              [
                [52, 15],
                [0, 14],
              ],
              [
                [53, 2],
                [170, 16],
                [0, 15],
              ],
              [
                [50, 17],
                [52, 15],
                [0, 16],
              ],
              [[49, 14]],
            ],
            { 15: 1, 25: 1, 53: 1 },
          ],
          336: [[[[25, 1]], [[0, 1]]], { 25: 1 }],
          337: [
            [
              [[21, 1]],
              [[49, 2]],
              [[48, 3]],
              [[80, 4]],
              [
                [127, 5],
                [0, 4],
              ],
              [[48, 6]],
              [[80, 7]],
              [[0, 7]],
            ],
            { 21: 1 },
          ],
          338: [
            [
              [[49, 1]],
              [
                [108, 2],
                [0, 1],
              ],
              [[95, 3]],
              [[0, 3]],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          339: [
            [
              [[42, 1]],
              [[171, 2]],
              [
                [48, 3],
                [52, 1],
              ],
              [[80, 4]],
              [[0, 4]],
            ],
            { 42: 1 },
          ],
          340: [
            [
              [[172, 1]],
              [
                [173, 0],
                [0, 1],
              ],
            ],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
            },
          ],
          341: [
            [
              [
                [111, 2],
                [36, 1],
              ],
              [[49, 2]],
              [[0, 2]],
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              36: 1,
              38: 1,
              43: 1,
            },
          ],
          342: [
            [
              [[31, 1]],
              [
                [174, 2],
                [0, 1],
              ],
              [[0, 2]],
            ],
            { 31: 1 },
          ],
          343: [[[[62, 1]], [[0, 1]]], { 31: 1 }],
        },
        states: [
          [
            [
              [1, 1],
              [2, 1],
              [3, 2],
            ],
            [[0, 1]],
            [[2, 1]],
          ],
          [
            [[44, 1]],
            [
              [45, 0],
              [0, 1],
            ],
          ],
          [
            [[46, 1]],
            [
              [47, 0],
              [0, 1],
            ],
          ],
          [
            [[48, 1]],
            [[49, 2]],
            [
              [50, 3],
              [0, 2],
            ],
            [[49, 4]],
            [[0, 4]],
          ],
          [
            [[51, 1]],
            [
              [52, 2],
              [0, 1],
            ],
            [
              [51, 1],
              [0, 2],
            ],
          ],
          [
            [
              [49, 1],
              [15, 2],
              [53, 2],
            ],
            [
              [50, 2],
              [54, 3],
              [0, 1],
            ],
            [[49, 3]],
            [[0, 3]],
          ],
          [
            [[55, 1]],
            [
              [30, 0],
              [43, 0],
              [0, 1],
            ],
          ],
          [
            [[24, 1]],
            [[49, 2]],
            [
              [52, 3],
              [0, 2],
            ],
            [[49, 4]],
            [[0, 4]],
          ],
          [[[10, 1]], [[56, 2]], [[0, 2]]],
          [
            [[10, 1]],
            [
              [57, 2],
              [56, 2],
              [58, 2],
            ],
            [[0, 2]],
          ],
          [
            [
              [6, 1],
              [25, 1],
              [33, 1],
              [9, 1],
              [11, 1],
              [12, 2],
              [35, 3],
              [38, 4],
              [19, 1],
              [7, 5],
            ],
            [[0, 1]],
            [
              [59, 1],
              [60, 6],
            ],
            [
              [61, 1],
              [62, 7],
              [63, 7],
            ],
            [
              [64, 1],
              [63, 8],
            ],
            [
              [7, 5],
              [0, 5],
            ],
            [[59, 1]],
            [[61, 1]],
            [[64, 1]],
          ],
          [
            [
              [29, 1],
              [65, 2],
            ],
            [[65, 2]],
            [
              [66, 2],
              [0, 2],
            ],
          ],
          [
            [
              [67, 1],
              [68, 1],
              [69, 1],
              [70, 1],
              [71, 1],
              [72, 1],
              [73, 1],
              [74, 1],
              [75, 1],
              [76, 1],
              [77, 1],
              [78, 1],
              [79, 1],
            ],
            [[0, 1]],
          ],
          [[[39, 1]], [[0, 1]]],
          [
            [[13, 1]],
            [[25, 2]],
            [
              [48, 3],
              [35, 4],
            ],
            [[80, 5]],
            [
              [61, 6],
              [81, 7],
            ],
            [[0, 5]],
            [[48, 3]],
            [[61, 6]],
          ],
          [
            [
              [10, 1],
              [34, 2],
            ],
            [[34, 2]],
            [[82, 3]],
            [[83, 4]],
            [[84, 5]],
            [
              [85, 6],
              [0, 5],
            ],
            [[0, 6]],
          ],
          [
            [[37, 1]],
            [[86, 2]],
            [
              [85, 3],
              [0, 2],
            ],
            [[0, 3]],
          ],
          [
            [
              [87, 1],
              [54, 1],
            ],
            [[0, 1]],
          ],
          [
            [
              [88, 1],
              [89, 1],
              [8, 2],
              [90, 1],
              [88, 1],
              [83, 1],
              [91, 1],
              [92, 3],
              [93, 1],
              [94, 1],
            ],
            [[0, 1]],
            [[83, 1]],
            [
              [8, 1],
              [0, 3],
            ],
          ],
          [
            [[95, 1]],
            [
              [96, 0],
              [0, 1],
            ],
          ],
          [
            [
              [97, 1],
              [98, 1],
              [58, 1],
              [99, 1],
              [57, 1],
              [100, 1],
              [56, 1],
              [101, 1],
              [102, 1],
            ],
            [[0, 1]],
          ],
          [[[40, 1]], [[0, 1]]],
          [[[17, 1]], [[0, 1]]],
          [
            [[103, 1]],
            [
              [56, 2],
              [104, 2],
              [99, 2],
            ],
            [[0, 2]],
          ],
          [
            [[41, 1]],
            [[105, 2]],
            [
              [2, 4],
              [35, 3],
            ],
            [
              [61, 5],
              [81, 6],
            ],
            [[0, 4]],
            [[2, 4]],
            [[61, 5]],
          ],
          [
            [[106, 1]],
            [
              [106, 1],
              [0, 1],
            ],
          ],
          [[[27, 1]], [[82, 2]], [[0, 2]]],
          [
            [
              [49, 1],
              [107, 2],
              [53, 3],
            ],
            [
              [48, 4],
              [54, 5],
              [52, 6],
              [0, 1],
            ],
            [
              [54, 5],
              [52, 6],
              [0, 2],
            ],
            [[95, 7]],
            [[49, 7]],
            [[0, 5]],
            [
              [49, 8],
              [107, 8],
              [0, 6],
            ],
            [
              [54, 5],
              [52, 9],
              [0, 7],
            ],
            [
              [52, 6],
              [0, 8],
            ],
            [
              [49, 10],
              [53, 11],
              [0, 9],
            ],
            [[48, 12]],
            [[95, 13]],
            [[49, 13]],
            [
              [52, 9],
              [0, 13],
            ],
          ],
          [
            [[105, 1]],
            [
              [108, 2],
              [0, 1],
            ],
            [[25, 3]],
            [[0, 3]],
          ],
          [
            [[109, 1]],
            [
              [52, 0],
              [0, 1],
            ],
          ],
          [
            [[25, 1]],
            [
              [110, 0],
              [0, 1],
            ],
          ],
          [[[25, 1]], [[0, 1]]],
          [
            [[111, 1]],
            [
              [2, 1],
              [112, 2],
            ],
            [[0, 2]],
          ],
          [
            [[113, 1]],
            [
              [49, 2],
              [0, 1],
            ],
            [
              [108, 3],
              [52, 3],
              [0, 2],
            ],
            [[49, 4]],
            [[0, 4]],
          ],
          [
            [[114, 1]],
            [
              [115, 0],
              [0, 1],
            ],
          ],
          [
            [[116, 1]],
            [
              [117, 2],
              [50, 3],
              [118, 4],
              [0, 1],
            ],
            [
              [111, 4],
              [62, 4],
            ],
            [
              [116, 5],
              [62, 5],
            ],
            [[0, 4]],
            [
              [50, 3],
              [0, 5],
            ],
          ],
          [
            [
              [95, 1],
              [107, 1],
            ],
            [
              [52, 2],
              [0, 1],
            ],
            [
              [95, 1],
              [107, 1],
              [0, 2],
            ],
          ],
          [
            [
              [119, 2],
              [30, 1],
              [22, 1],
              [43, 1],
            ],
            [[120, 2]],
            [[0, 2]],
          ],
          [
            [
              [2, 0],
              [112, 1],
              [121, 0],
            ],
            [[0, 1]],
          ],
          [
            [
              [122, 1],
              [123, 1],
              [124, 1],
              [125, 1],
              [126, 1],
            ],
            [[0, 1]],
          ],
          [
            [[34, 1]],
            [[82, 2]],
            [[83, 3]],
            [[111, 4]],
            [[48, 5]],
            [[80, 6]],
            [
              [127, 7],
              [0, 6],
            ],
            [[48, 8]],
            [[80, 9]],
            [[0, 9]],
          ],
          [
            [[4, 1]],
            [[25, 2]],
            [[128, 3]],
            [
              [48, 4],
              [129, 5],
            ],
            [[80, 6]],
            [[49, 7]],
            [[0, 6]],
            [[48, 4]],
          ],
          [
            [[26, 1]],
            [[25, 2]],
            [
              [52, 1],
              [0, 2],
            ],
          ],
          [
            [[37, 1]],
            [[49, 2]],
            [[48, 3]],
            [[80, 4]],
            [
              [127, 5],
              [130, 1],
              [0, 4],
            ],
            [[48, 6]],
            [[80, 7]],
            [[0, 7]],
          ],
          [
            [[25, 1]],
            [
              [108, 2],
              [0, 1],
            ],
            [[25, 3]],
            [[0, 3]],
          ],
          [
            [[131, 1]],
            [
              [52, 2],
              [0, 1],
            ],
            [
              [131, 1],
              [0, 2],
            ],
          ],
          [
            [[36, 1]],
            [
              [105, 2],
              [19, 3],
              [110, 3],
            ],
            [[32, 4]],
            [
              [105, 2],
              [19, 3],
              [32, 4],
              [110, 3],
            ],
            [
              [132, 5],
              [15, 5],
              [35, 6],
            ],
            [[0, 5]],
            [[132, 7]],
            [[61, 5]],
          ],
          [[[32, 1]], [[133, 2]], [[0, 2]]],
          [
            [
              [134, 1],
              [135, 1],
            ],
            [[0, 1]],
          ],
          [
            [[14, 1]],
            [
              [48, 2],
              [136, 3],
            ],
            [[49, 4]],
            [[48, 2]],
            [[0, 4]],
          ],
          [
            [[14, 1]],
            [
              [48, 2],
              [136, 3],
            ],
            [[86, 4]],
            [[48, 2]],
            [[0, 4]],
          ],
          [
            [[18, 1]],
            [[25, 2]],
            [
              [52, 1],
              [0, 2],
            ],
          ],
          [
            [
              [8, 1],
              [137, 2],
            ],
            [[46, 2]],
            [[0, 2]],
          ],
          [
            [[138, 1]],
            [
              [139, 0],
              [0, 1],
            ],
          ],
          [
            [[35, 1]],
            [
              [61, 2],
              [140, 3],
            ],
            [[0, 2]],
            [[61, 2]],
          ],
          [[[28, 1]], [[0, 1]]],
          [
            [[141, 1]],
            [
              [53, 2],
              [0, 1],
            ],
            [[120, 3]],
            [[0, 3]],
          ],
          [
            [[16, 1]],
            [
              [49, 2],
              [142, 3],
              [0, 1],
            ],
            [
              [52, 4],
              [0, 2],
            ],
            [[49, 5]],
            [
              [49, 2],
              [0, 4],
            ],
            [
              [52, 6],
              [0, 5],
            ],
            [[49, 7]],
            [
              [52, 8],
              [0, 7],
            ],
            [
              [49, 7],
              [0, 8],
            ],
          ],
          [
            [[5, 1]],
            [
              [49, 2],
              [0, 1],
            ],
            [
              [36, 3],
              [52, 3],
              [0, 2],
            ],
            [[49, 4]],
            [
              [52, 5],
              [0, 4],
            ],
            [[49, 6]],
            [[0, 6]],
          ],
          [
            [[23, 1]],
            [
              [111, 2],
              [0, 1],
            ],
            [[0, 2]],
          ],
          [
            [[143, 1]],
            [
              [144, 0],
              [142, 0],
              [0, 1],
            ],
          ],
          [
            [[145, 1]],
            [
              [2, 2],
              [146, 3],
            ],
            [[0, 2]],
            [
              [145, 1],
              [2, 2],
            ],
          ],
          [
            [[48, 1]],
            [
              [49, 2],
              [0, 1],
            ],
            [[0, 2]],
          ],
          [
            [
              [147, 1],
              [148, 1],
              [149, 1],
              [150, 1],
              [151, 1],
              [152, 1],
              [153, 1],
              [154, 1],
              [155, 1],
              [156, 1],
            ],
            [[0, 1]],
          ],
          [[[15, 1]], [[95, 2]], [[0, 2]]],
          [
            [
              [1, 1],
              [3, 1],
            ],
            [[0, 1]],
          ],
          [
            [
              [49, 1],
              [48, 2],
            ],
            [
              [48, 2],
              [0, 1],
            ],
            [
              [49, 3],
              [157, 4],
              [0, 2],
            ],
            [
              [157, 4],
              [0, 3],
            ],
            [[0, 4]],
          ],
          [
            [[158, 1]],
            [
              [52, 2],
              [0, 1],
            ],
            [
              [158, 1],
              [0, 2],
            ],
          ],
          [
            [
              [1, 1],
              [2, 2],
            ],
            [[0, 1]],
            [[159, 3]],
            [[121, 4]],
            [
              [160, 1],
              [121, 4],
            ],
          ],
          [
            [[120, 1]],
            [
              [161, 0],
              [15, 0],
              [162, 0],
              [41, 0],
              [163, 0],
              [0, 1],
            ],
          ],
          [
            [
              [84, 1],
              [164, 2],
            ],
            [
              [37, 3],
              [0, 1],
            ],
            [[0, 2]],
            [[84, 4]],
            [[127, 5]],
            [[49, 2]],
          ],
          [
            [
              [165, 1],
              [84, 1],
            ],
            [[0, 1]],
          ],
          [
            [[49, 1]],
            [
              [52, 2],
              [0, 1],
            ],
            [
              [49, 1],
              [0, 2],
            ],
          ],
          [
            [
              [49, 1],
              [107, 1],
            ],
            [
              [54, 2],
              [52, 3],
              [0, 1],
            ],
            [[0, 2]],
            [
              [49, 4],
              [107, 4],
              [0, 3],
            ],
            [
              [52, 3],
              [0, 4],
            ],
          ],
          [
            [
              [49, 1],
              [107, 1],
            ],
            [
              [52, 2],
              [0, 1],
            ],
            [
              [49, 1],
              [107, 1],
              [0, 2],
            ],
          ],
          [
            [[25, 1]],
            [
              [48, 2],
              [0, 1],
            ],
            [[49, 3]],
            [[0, 3]],
          ],
          [
            [
              [35, 1],
              [110, 2],
              [38, 3],
            ],
            [
              [61, 4],
              [81, 5],
            ],
            [[25, 4]],
            [[166, 6]],
            [[0, 4]],
            [[61, 4]],
            [[64, 4]],
          ],
          [
            [[20, 1]],
            [[48, 2]],
            [[80, 3]],
            [
              [167, 4],
              [168, 5],
            ],
            [[48, 6]],
            [[48, 7]],
            [[80, 8]],
            [[80, 9]],
            [
              [167, 4],
              [127, 10],
              [168, 5],
              [0, 8],
            ],
            [[0, 9]],
            [[48, 11]],
            [[80, 12]],
            [
              [168, 5],
              [0, 12],
            ],
          ],
          [
            [
              [15, 1],
              [169, 2],
              [53, 3],
            ],
            [
              [169, 4],
              [52, 5],
              [0, 1],
            ],
            [
              [50, 6],
              [52, 7],
              [0, 2],
            ],
            [[169, 8]],
            [
              [52, 5],
              [0, 4],
            ],
            [
              [169, 9],
              [53, 3],
              [0, 5],
            ],
            [[49, 10]],
            [
              [15, 11],
              [169, 2],
              [53, 3],
              [0, 7],
            ],
            [
              [52, 12],
              [0, 8],
            ],
            [
              [50, 13],
              [52, 5],
              [0, 9],
            ],
            [
              [52, 7],
              [0, 10],
            ],
            [
              [169, 14],
              [52, 15],
              [0, 11],
            ],
            [[0, 12]],
            [[49, 4]],
            [
              [52, 15],
              [0, 14],
            ],
            [
              [169, 16],
              [53, 3],
              [0, 15],
            ],
            [
              [50, 17],
              [52, 15],
              [0, 16],
            ],
            [[49, 14]],
          ],
          [
            [
              [15, 1],
              [53, 2],
              [170, 3],
            ],
            [
              [170, 5],
              [52, 4],
              [0, 1],
            ],
            [[170, 6]],
            [
              [50, 7],
              [52, 8],
              [0, 3],
            ],
            [
              [53, 2],
              [170, 9],
              [0, 4],
            ],
            [
              [52, 4],
              [0, 5],
            ],
            [
              [52, 10],
              [0, 6],
            ],
            [[49, 11]],
            [
              [15, 12],
              [53, 2],
              [170, 3],
              [0, 8],
            ],
            [
              [50, 13],
              [52, 4],
              [0, 9],
            ],
            [[0, 10]],
            [
              [52, 8],
              [0, 11],
            ],
            [
              [52, 15],
              [170, 14],
              [0, 12],
            ],
            [[49, 5]],
            [
              [52, 15],
              [0, 14],
            ],
            [
              [53, 2],
              [170, 16],
              [0, 15],
            ],
            [
              [50, 17],
              [52, 15],
              [0, 16],
            ],
            [[49, 14]],
          ],
          [[[25, 1]], [[0, 1]]],
          [
            [[21, 1]],
            [[49, 2]],
            [[48, 3]],
            [[80, 4]],
            [
              [127, 5],
              [0, 4],
            ],
            [[48, 6]],
            [[80, 7]],
            [[0, 7]],
          ],
          [
            [[49, 1]],
            [
              [108, 2],
              [0, 1],
            ],
            [[95, 3]],
            [[0, 3]],
          ],
          [
            [[42, 1]],
            [[171, 2]],
            [
              [48, 3],
              [52, 1],
            ],
            [[80, 4]],
            [[0, 4]],
          ],
          [
            [[172, 1]],
            [
              [173, 0],
              [0, 1],
            ],
          ],
          [
            [
              [111, 2],
              [36, 1],
            ],
            [[49, 2]],
            [[0, 2]],
          ],
          [
            [[31, 1]],
            [
              [174, 2],
              [0, 1],
            ],
            [[0, 2]],
          ],
          [[[62, 1]], [[0, 1]]],
        ],
        labels: [
          [0, "EMPTY"],
          [317, null],
          [4, null],
          [276, null],
          [1, "def"],
          [1, "raise"],
          [1, "True"],
          [3, null],
          [1, "not"],
          [1, "null"],
          [55, null],
          [2, null],
          [25, null],
          [1, "class"],
          [1, "lambda"],
          [16, null],
          [1, "print"],
          [1, "debugger"],
          [1, "nonlocal"],
          [52, null],
          [1, "try"],
          [1, "while"],
          [31, null],
          [1, "return"],
          [1, "assert"],
          [1, null],
          [1, "global"],
          [1, "del"],
          [1, "pass"],
          [54, null],
          [15, null],
          [1, "yield"],
          [1, "import"],
          [1, "False"],
          [1, "for"],
          [7, null],
          [1, "from"],
          [1, "if"],
          [9, null],
          [1, "break"],
          [1, "continue"],
          [49, null],
          [1, "with"],
          [14, null],
          [316, null],
          [19, null],
          [308, null],
          [1, "and"],
          [11, null],
          [326, null],
          [22, null],
          [261, null],
          [12, null],
          [35, null],
          [271, null],
          [325, null],
          [297, null],
          [339, null],
          [296, null],
          [26, null],
          [283, null],
          [8, null],
          [342, null],
          [329, null],
          [10, null],
          [266, null],
          [332, null],
          [45, null],
          [38, null],
          [40, null],
          [50, null],
          [46, null],
          [41, null],
          [42, null],
          [36, null],
          [43, null],
          [48, null],
          [44, null],
          [37, null],
          [39, null],
          [324, null],
          [260, null],
          [292, null],
          [1, "in"],
          [309, null],
          [273, null],
          [327, null],
          [272, null],
          [28, null],
          [21, null],
          [27, null],
          [29, null],
          [1, "is"],
          [30, null],
          [20, null],
          [290, null],
          [274, null],
          [333, null],
          [299, null],
          [270, null],
          [337, null],
          [279, null],
          [265, null],
          [281, null],
          [264, null],
          [286, null],
          [280, null],
          [320, null],
          [1, "as"],
          [284, null],
          [23, null],
          [328, null],
          [0, null],
          [1, "except"],
          [340, null],
          [18, null],
          [330, null],
          [268, null],
          [259, null],
          [312, null],
          [293, null],
          [321, null],
          [269, null],
          [277, null],
          [314, null],
          [315, null],
          [343, null],
          [1, "else"],
          [310, null],
          [51, null],
          [1, "elif"],
          [300, null],
          [301, null],
          [285, null],
          [303, null],
          [302, null],
          [335, null],
          [275, null],
          [258, null],
          [1, "or"],
          [334, null],
          [267, null],
          [34, null],
          [262, null],
          [33, null],
          [319, null],
          [13, null],
          [295, null],
          [263, null],
          [291, null],
          [311, null],
          [307, null],
          [313, null],
          [282, null],
          [298, null],
          [304, null],
          [278, null],
          [318, null],
          [322, null],
          [5, null],
          [6, null],
          [47, null],
          [17, null],
          [24, null],
          [305, null],
          [306, null],
          [323, null],
          [289, null],
          [1, "finally"],
          [331, null],
          [336, null],
          [338, null],
          [257, null],
          [32, null],
          [341, null],
        ],
        keywords: {
          False: 33,
          null: 9,
          True: 6,
          and: 47,
          as: 108,
          assert: 24,
          break: 39,
          class: 13,
          continue: 40,
          debugger: 17,
          def: 4,
          del: 27,
          elif: 130,
          else: 127,
          except: 113,
          finally: 168,
          for: 34,
          from: 36,
          global: 26,
          if: 37,
          import: 32,
          in: 83,
          is: 92,
          lambda: 14,
          nonlocal: 18,
          not: 8,
          or: 139,
          pass: 28,
          print: 16,
          raise: 5,
          return: 23,
          try: 20,
          while: 21,
          with: 42,
          yield: 31,
        },
        tokens: {
          0: 112,
          1: 25,
          2: 11,
          3: 7,
          4: 2,
          5: 159,
          6: 160,
          7: 35,
          8: 61,
          9: 38,
          10: 64,
          11: 48,
          12: 52,
          13: 146,
          14: 43,
          15: 30,
          16: 15,
          17: 162,
          18: 115,
          19: 45,
          20: 94,
          21: 89,
          22: 50,
          23: 110,
          24: 163,
          25: 12,
          26: 59,
          27: 90,
          28: 88,
          29: 91,
          30: 93,
          31: 22,
          32: 173,
          33: 144,
          34: 142,
          35: 53,
          36: 74,
          37: 78,
          38: 68,
          39: 79,
          40: 69,
          41: 72,
          42: 73,
          43: 75,
          44: 77,
          45: 67,
          46: 71,
          47: 161,
          48: 76,
          49: 41,
          50: 70,
          51: 129,
          52: 19,
          54: 29,
          55: 10,
        },
        start: 256,
      }
    },
    function(m, p) {
      function a(a, b) {
        this.filename = a
        this.grammar = b
        this.p_flags = 0
        return this
      }
      function b(b, d) {
        void 0 === d && (d = "file_input")
        b = new a(b, self.Sk.ParseTables)
        "file_input" === d
          ? b.setup(self.Sk.ParseTables.sym.file_input)
          : self.Sk.asserts.fail("todo;")
        return b
      }
      a.FUTURE_PRINT_FUNCTION = "print_function"
      a.FUTURE_UNICODE_LITERALS = "unicode_literals"
      a.FUTURE_DIVISION = "division"
      a.FUTURE_ABSOLUTE_IMPORT = "absolute_import"
      a.FUTURE_WITH_STATEMENT = "with_statement"
      a.FUTURE_NESTED_SCOPES = "nested_scopes"
      a.FUTURE_GENERATORS = "generators"
      a.CO_FUTURE_PRINT_FUNCTION = 65536
      a.CO_FUTURE_UNICODE_LITERALS = 131072
      a.CO_FUTURE_DIVISON = 8192
      a.CO_FUTURE_ABSOLUTE_IMPORT = 16384
      a.CO_FUTURE_WITH_STATEMENT = 32768
      a.prototype.setup = function(a) {
        a = a || this.grammar.start
        this.stack = [
          {
            dfa: this.grammar.dfas[a],
            state: 0,
            node: { type: a, value: null, context: null, children: [] },
          },
        ]
        this.used_names = {}
      }
      a.prototype.addtoken = function(a, b, e) {
        var c,
          d = this.classify(a, b, e)
        a: for (;;) {
          var h = this.stack[this.stack.length - 1]
          var k = h.dfa[0]
          var l = k[h.state]
          for (c = 0; c < l.length; ++c) {
            var r = l[c][0]
            var n = l[c][1]
            var q = this.grammar.labels[r][0]
            if (d === r) {
              self.Sk.asserts.assert(256 > q)
              this.shift(a, b, n, e)
              for (
                e = n;
                1 === k[e].length && 0 === k[e][0][0] && k[e][0][1] === e;

              ) {
                this.pop()
                if (0 === this.stack.length) return !0
                h = this.stack[this.stack.length - 1]
                e = h.state
                k = h.dfa[0]
              }
              return !1
            }
            if (
              256 <= q &&
              ((r = this.grammar.dfas[q]), (r = r[1]), r.hasOwnProperty(d))
            ) {
              this.push(q, this.grammar.dfas[q], n, e)
              continue a
            }
          }
          b: {
            k = [0, h.state]
            for (h = l.length; h--; )
              if (l[h][0] === k[0] && l[h][1] === k[1]) {
                l = !0
                break b
              }
            l = !1
          }
          if (l) {
            if ((this.pop(), 0 === this.stack.length))
              throw new self.Sk.builtin.SyntaxError("too much input", this.filename)
          } else
            throw ((a = e[0][0]),
            new self.Sk.builtin.SyntaxError("bad input", this.filename, a, e))
        }
      }
      a.prototype.classify = function(b, d, e) {
        if (b === self.Sk.token.tokens.T_NAME) {
          this.used_names[d] = !0
          var c =
            this.grammar.keywords.hasOwnProperty(d) && this.grammar.keywords[d]
          "print" === d &&
            (this.p_flags & a.CO_FUTURE_PRINT_FUNCTION ||
              !0 === self.Sk.__future__.print_function) &&
            (c = !1)
          if (c) return c
        }
        c = this.grammar.tokens.hasOwnProperty(b) && this.grammar.tokens[b]
        if (!c) {
          d = "#" + b
          for (let a in self.Sk.token.tokens)
            if (self.Sk.token.tokens[a] == b) {
              d = a
              break
            }
          throw new self.Sk.builtin.SyntaxError(
            "bad token " + d,
            this.filename,
            e[0][0],
            e,
          )
        }
        return c
      }
      a.prototype.shift = function(a, b, e, f) {
        var c = this.stack[this.stack.length - 1].dfa,
          d = this.stack[this.stack.length - 1].node
        d.children.push({
          type: a,
          value: b,
          lineno: f[0][0],
          col_offset: f[0][1],
          children: null,
        })
        this.stack[this.stack.length - 1] = { dfa: c, state: e, node: d }
      }
      a.prototype.push = function(a, b, e, f) {
        a = {
          type: a,
          value: null,
          lineno: f[0][0],
          col_offset: f[0][1],
          children: [],
        }
        this.stack[this.stack.length - 1] = {
          dfa: this.stack[this.stack.length - 1].dfa,
          state: e,
          node: this.stack[this.stack.length - 1].node,
        }
        this.stack.push({ dfa: b, state: 0, node: a })
      }
      a.prototype.pop = function() {
        var a = this.stack.pop().node
        if (a)
          if (0 !== this.stack.length) {
            var b = this.stack[this.stack.length - 1].node
            b.children.push(a)
          } else
            (this.rootnode = a), (this.rootnode.used_names = this.used_names)
      }
      self.Sk.parse = function(a, d) {
        var c = self.Sk.token.tokens.T_COMMENT,
          f = self.Sk.token.tokens.T_NL,
          g = self.Sk.token.tokens.T_OP,
          h = self.Sk.token.tokens.T_ENDMARKER,
          k = self.Sk.token.tokens.T_ENCODING,
          l = !1,
          r = b(a)
        self.Sk._tokenize(
          a,
          (function(a) {
            var b = a
              .split("\n")
              .reverse()
              .map(function(a) {
                return a + "\n"
              })
            return function() {
              if (0 === b.length) throw new self.Sk.builtin.Exception("EOF")
              return b.pop()
            }
          })(d),
          "utf-8",
          function(a) {
            var b = null
            a.type !== c &&
              a.type !== f &&
              a.type !== k &&
              (a.type === g && (b = self.Sk.OpMap[a.string]),
              r.addtoken(b || a.type, a.string, [a.start, a.end, a.line]),
              a.type === h && (l = !0))
          },
        )
        if (!l)
          throw new self.Sk.builtin.SyntaxError("incomplete input", this.filename)
        return { cst: r.rootnode, flags: r.p_flags }
      }
      self.Sk.parseTreeDump = function(a, b) {
        var c
        b = b || ""
        var d = "" + b
        if (256 <= a.type)
          for (
            d += self.Sk.ParseTables.number2symbol[a.type] + "\n", c = 0;
            c < a.children.length;
            ++c
          )
            d += self.Sk.parseTreeDump(a.children[c], b + "  ")
        else
          d +=
            self.Sk.token.tok_name[a.type] +
            ": " +
            new self.Sk.builtin.str(a.value).$r().v +
            "\n"
        return d
      }
      self.Sk.exportSymbol("Sk.Parser", a)
      self.Sk.exportSymbol("Sk.parse", self.Sk.parse)
      self.Sk.exportSymbol("Sk.parseTreeDump", self.Sk.parseTreeDump)
    },
    function(m, p) {
      self.Sk.astnodes = {}
      self.Sk.astnodes.Load = function() {}
      self.Sk.astnodes.Store = function() {}
      self.Sk.astnodes.Del = function() {}
      self.Sk.astnodes.AugLoad = function() {}
      self.Sk.astnodes.AugStore = function() {}
      self.Sk.astnodes.Param = function() {}
      self.Sk.astnodes.And = function() {}
      self.Sk.astnodes.Or = function() {}
      self.Sk.astnodes.Add = function() {}
      self.Sk.astnodes.Sub = function() {}
      self.Sk.astnodes.Mult = function() {}
      self.Sk.astnodes.MatMult = function() {}
      self.Sk.astnodes.Div = function() {}
      self.Sk.astnodes.Mod = function() {}
      self.Sk.astnodes.Pow = function() {}
      self.Sk.astnodes.LShift = function() {}
      self.Sk.astnodes.RShift = function() {}
      self.Sk.astnodes.BitOr = function() {}
      self.Sk.astnodes.BitXor = function() {}
      self.Sk.astnodes.BitAnd = function() {}
      self.Sk.astnodes.FloorDiv = function() {}
      self.Sk.astnodes.Invert = function() {}
      self.Sk.astnodes.Not = function() {}
      self.Sk.astnodes.UAdd = function() {}
      self.Sk.astnodes.USub = function() {}
      self.Sk.astnodes.Eq = function() {}
      self.Sk.astnodes.NotEq = function() {}
      self.Sk.astnodes.Lt = function() {}
      self.Sk.astnodes.LtE = function() {}
      self.Sk.astnodes.Gt = function() {}
      self.Sk.astnodes.GtE = function() {}
      self.Sk.astnodes.Is = function() {}
      self.Sk.astnodes.IsNot = function() {}
      self.Sk.astnodes.In = function() {}
      self.Sk.astnodes.NotIn = function() {}
      self.Sk.astnodes.Module = function(a, b) {
        this.body = a
        this.docstring = b
        return this
      }
      self.Sk.astnodes.Interactive = function(a) {
        this.body = a
        return this
      }
      self.Sk.astnodes.Expression = function(a) {
        this.body = a
        return this
      }
      self.Sk.astnodes.Suite = function(a) {
        this.body = a
        return this
      }
      self.Sk.astnodes.FunctionDef = function(a, b, c, d, e, f, g, h) {
        self.Sk.asserts.assert(null !== g && void 0 !== g)
        self.Sk.asserts.assert(null !== h && void 0 !== h)
        this.name = a
        this.args = b
        this.body = c
        this.decorator_list = d
        this.returns = e
        this.docstring = f
        this.lineno = g
        this.col_offset = h
        return this
      }
      self.Sk.astnodes.AsyncFunctionDef = function(a, b, c, d, e, f, g, h) {
        self.Sk.asserts.assert(null !== g && void 0 !== g)
        self.Sk.asserts.assert(null !== h && void 0 !== h)
        this.name = a
        this.args = b
        this.body = c
        this.decorator_list = d
        this.returns = e
        this.docstring = f
        this.lineno = g
        this.col_offset = h
        return this
      }
      self.Sk.astnodes.ClassDef = function(a, b, c, d, e, f, g, h) {
        self.Sk.asserts.assert(null !== g && void 0 !== g)
        self.Sk.asserts.assert(null !== h && void 0 !== h)
        this.name = a
        this.bases = b
        this.keywords = c
        this.body = d
        this.decorator_list = e
        this.docstring = f
        this.lineno = g
        this.col_offset = h
        return this
      }
      self.Sk.astnodes.Return = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.value = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Delete = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.targets = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Assign = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.targets = a
        this.value = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.AugAssign = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.target = a
        this.op = b
        this.value = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.AnnAssign = function(a, b, c, d, e, f) {
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        self.Sk.asserts.assert(null !== f && void 0 !== f)
        this.target = a
        this.annotation = b
        this.value = c
        this.simple = d
        this.lineno = e
        this.col_offset = f
        return this
      }
      self.Sk.astnodes.For = function(a, b, c, d, e, f) {
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        self.Sk.asserts.assert(null !== f && void 0 !== f)
        this.target = a
        this.iter = b
        this.body = c
        this.orelse = d
        this.lineno = e
        this.col_offset = f
        return this
      }
      self.Sk.astnodes.AsyncFor = function(a, b, c, d, e, f) {
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        self.Sk.asserts.assert(null !== f && void 0 !== f)
        this.target = a
        this.iter = b
        this.body = c
        this.orelse = d
        this.lineno = e
        this.col_offset = f
        return this
      }
      self.Sk.astnodes.While = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.test = a
        this.body = b
        this.orelse = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.If = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.test = a
        this.body = b
        this.orelse = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.With = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.items = a
        this.body = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.AsyncWith = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.items = a
        this.body = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.Raise = function(a, b, c, d, e, f) {
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        self.Sk.asserts.assert(null !== f && void 0 !== f)
        this.exc = a
        this.cause = b
        this.inst = c
        this.tback = d
        this.lineno = e
        this.col_offset = f
        return this
      }
      self.Sk.astnodes.Try = function(a, b, c, d, e, f) {
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        self.Sk.asserts.assert(null !== f && void 0 !== f)
        this.body = a
        this.handlers = b
        this.orelse = c
        this.finalbody = d
        this.lineno = e
        this.col_offset = f
        return this
      }
      self.Sk.astnodes.Assert = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.test = a
        this.msg = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.Import = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.names = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.ImportFrom = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.module = a
        this.names = b
        this.level = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.Global = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.names = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Nonlocal = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.names = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Expr = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.value = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Pass = function(a, b) {
        self.Sk.asserts.assert(null !== a && void 0 !== a)
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        this.lineno = a
        this.col_offset = b
        return this
      }
      self.Sk.astnodes.Break = function(a, b) {
        self.Sk.asserts.assert(null !== a && void 0 !== a)
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        this.lineno = a
        this.col_offset = b
        return this
      }
      self.Sk.astnodes.Continue = function(a, b) {
        self.Sk.asserts.assert(null !== a && void 0 !== a)
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        this.lineno = a
        this.col_offset = b
        return this
      }
      self.Sk.astnodes.Print = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.dest = a
        this.values = b
        this.nl = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.Debugger = function(a, b) {
        self.Sk.asserts.assert(null !== a && void 0 !== a)
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        this.lineno = a
        this.col_offset = b
        return this
      }
      self.Sk.astnodes.BoolOp = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.op = a
        this.values = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.BinOp = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.left = a
        this.op = b
        this.right = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.UnaryOp = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.op = a
        this.operand = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.Lambda = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.args = a
        this.body = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.IfExp = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.test = a
        this.body = b
        this.orelse = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.Dict = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.keys = a
        this.values = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.Set = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.elts = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.ListComp = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.elt = a
        this.generators = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.SetComp = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.elt = a
        this.generators = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.DictComp = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.key = a
        this.value = b
        this.generators = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.GeneratorExp = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.elt = a
        this.generators = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.Await = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.value = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Yield = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.value = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.YieldFrom = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.value = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Compare = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.left = a
        this.ops = b
        this.comparators = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.Call = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.func = a
        this.args = b
        this.keywords = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.Num = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.n = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Str = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.s = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.FormattedValue = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.value = a
        this.conversion = b
        this.format_spec = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.JoinedStr = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.values = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Bytes = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.s = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.NameConstant = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.value = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Ellipsis = function(a, b) {
        self.Sk.asserts.assert(null !== a && void 0 !== a)
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        this.lineno = a
        this.col_offset = b
        return this
      }
      self.Sk.astnodes.Constant = function(a, b, c) {
        self.Sk.asserts.assert(null !== b && void 0 !== b)
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        this.value = a
        this.lineno = b
        this.col_offset = c
        return this
      }
      self.Sk.astnodes.Attribute = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.value = a
        this.attr = b
        this.ctx = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.Subscript = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.value = a
        this.slice = b
        this.ctx = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.Starred = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.value = a
        this.ctx = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.Name = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.id = a
        this.ctx = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.List = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.elts = a
        this.ctx = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.Tuple = function(a, b, c, d) {
        self.Sk.asserts.assert(null !== c && void 0 !== c)
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        this.elts = a
        this.ctx = b
        this.lineno = c
        this.col_offset = d
        return this
      }
      self.Sk.astnodes.Slice = function(a, b, c) {
        this.lower = a
        this.upper = b
        this.step = c
        return this
      }
      self.Sk.astnodes.ExtSlice = function(a) {
        this.dims = a
        return this
      }
      self.Sk.astnodes.Index = function(a) {
        this.value = a
        return this
      }
      self.Sk.astnodes.comprehension = function(a, b, c, d) {
        this.target = a
        this.iter = b
        this.ifs = c
        this.is_async = d
        return this
      }
      self.Sk.astnodes.ExceptHandler = function(a, b, c, d, e) {
        self.Sk.asserts.assert(null !== d && void 0 !== d)
        self.Sk.asserts.assert(null !== e && void 0 !== e)
        this.type = a
        this.name = b
        this.body = c
        this.lineno = d
        this.col_offset = e
        return this
      }
      self.Sk.astnodes.arguments_ = function(a, b, c, d, e, f) {
        this.args = a
        this.vararg = b
        this.kwonlyargs = c
        this.kw_defaults = d
        this.kwarg = e
        this.defaults = f
        return this
      }
      self.Sk.astnodes.arg = function a(a, b) {
        this.arg = a
        this.annotation = b
        return this
      }
      self.Sk.astnodes.keyword = function(a, b) {
        this.arg = a
        this.value = b
        return this
      }
      self.Sk.astnodes.alias = function(a, b) {
        this.name = a
        this.asname = b
        return this
      }
      self.Sk.astnodes.withitem = function(a, b) {
        this.context_expr = a
        this.optional_vars = b
        return this
      }
      self.Sk.astnodes.Module.prototype._astname = "Module"
      self.Sk.astnodes.Module.prototype._fields = [
        "body",
        function(a) {
          return a.body
        },
        "docstring",
        function(a) {
          return a.docstring
        },
      ]
      self.Sk.astnodes.Interactive.prototype._astname = "Interactive"
      self.Sk.astnodes.Interactive.prototype._fields = [
        "body",
        function(a) {
          return a.body
        },
      ]
      self.Sk.astnodes.Expression.prototype._astname = "Expression"
      self.Sk.astnodes.Expression.prototype._fields = [
        "body",
        function(a) {
          return a.body
        },
      ]
      self.Sk.astnodes.Suite.prototype._astname = "Suite"
      self.Sk.astnodes.Suite.prototype._fields = [
        "body",
        function(a) {
          return a.body
        },
      ]
      self.Sk.astnodes.FunctionDef.prototype._astname = "FunctionDef"
      self.Sk.astnodes.FunctionDef.prototype._fields = [
        "name",
        function(a) {
          return a.name
        },
        "args",
        function(a) {
          return a.args
        },
        "body",
        function(a) {
          return a.body
        },
        "decorator_list",
        function(a) {
          return a.decorator_list
        },
        "returns",
        function(a) {
          return a.returns
        },
        "docstring",
        function(a) {
          return a.docstring
        },
      ]
      self.Sk.astnodes.AsyncFunctionDef.prototype._astname = "AsyncFunctionDef"
      self.Sk.astnodes.AsyncFunctionDef.prototype._fields = [
        "name",
        function(a) {
          return a.name
        },
        "args",
        function(a) {
          return a.args
        },
        "body",
        function(a) {
          return a.body
        },
        "decorator_list",
        function(a) {
          return a.decorator_list
        },
        "returns",
        function(a) {
          return a.returns
        },
        "docstring",
        function(a) {
          return a.docstring
        },
      ]
      self.Sk.astnodes.ClassDef.prototype._astname = "ClassDef"
      self.Sk.astnodes.ClassDef.prototype._fields = [
        "name",
        function(a) {
          return a.name
        },
        "bases",
        function(a) {
          return a.bases
        },
        "keywords",
        function(a) {
          return a.keywords
        },
        "body",
        function(a) {
          return a.body
        },
        "decorator_list",
        function(a) {
          return a.decorator_list
        },
        "docstring",
        function(a) {
          return a.docstring
        },
      ]
      self.Sk.astnodes.Return.prototype._astname = "Return"
      self.Sk.astnodes.Return.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.Delete.prototype._astname = "Delete"
      self.Sk.astnodes.Delete.prototype._fields = [
        "targets",
        function(a) {
          return a.targets
        },
      ]
      self.Sk.astnodes.Assign.prototype._astname = "Assign"
      self.Sk.astnodes.Assign.prototype._fields = [
        "targets",
        function(a) {
          return a.targets
        },
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.AugAssign.prototype._astname = "AugAssign"
      self.Sk.astnodes.AugAssign.prototype._fields = [
        "target",
        function(a) {
          return a.target
        },
        "op",
        function(a) {
          return a.op
        },
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.AnnAssign.prototype._astname = "AnnAssign"
      self.Sk.astnodes.AnnAssign.prototype._fields = [
        "target",
        function(a) {
          return a.target
        },
        "annotation",
        function(a) {
          return a.annotation
        },
        "value",
        function(a) {
          return a.value
        },
        "simple",
        function(a) {
          return a.simple
        },
      ]
      self.Sk.astnodes.For.prototype._astname = "For"
      self.Sk.astnodes.For.prototype._fields = [
        "target",
        function(a) {
          return a.target
        },
        "iter",
        function(a) {
          return a.iter
        },
        "body",
        function(a) {
          return a.body
        },
        "orelse",
        function(a) {
          return a.orelse
        },
      ]
      self.Sk.astnodes.AsyncFor.prototype._astname = "AsyncFor"
      self.Sk.astnodes.AsyncFor.prototype._fields = [
        "target",
        function(a) {
          return a.target
        },
        "iter",
        function(a) {
          return a.iter
        },
        "body",
        function(a) {
          return a.body
        },
        "orelse",
        function(a) {
          return a.orelse
        },
      ]
      self.Sk.astnodes.While.prototype._astname = "While"
      self.Sk.astnodes.While.prototype._fields = [
        "test",
        function(a) {
          return a.test
        },
        "body",
        function(a) {
          return a.body
        },
        "orelse",
        function(a) {
          return a.orelse
        },
      ]
      self.Sk.astnodes.If.prototype._astname = "If"
      self.Sk.astnodes.If.prototype._fields = [
        "test",
        function(a) {
          return a.test
        },
        "body",
        function(a) {
          return a.body
        },
        "orelse",
        function(a) {
          return a.orelse
        },
      ]
      self.Sk.astnodes.With.prototype._astname = "With"
      self.Sk.astnodes.With.prototype._fields = [
        "items",
        function(a) {
          return a.items
        },
        "body",
        function(a) {
          return a.body
        },
      ]
      self.Sk.astnodes.AsyncWith.prototype._astname = "AsyncWith"
      self.Sk.astnodes.AsyncWith.prototype._fields = [
        "items",
        function(a) {
          return a.items
        },
        "body",
        function(a) {
          return a.body
        },
      ]
      self.Sk.astnodes.Raise.prototype._astname = "Raise"
      self.Sk.astnodes.Raise.prototype._fields = [
        "exc",
        function(a) {
          return a.exc
        },
        "cause",
        function(a) {
          return a.cause
        },
        "inst",
        function(a) {
          return a.inst
        },
        "tback",
        function(a) {
          return a.tback
        },
      ]
      self.Sk.astnodes.Try.prototype._astname = "Try"
      self.Sk.astnodes.Try.prototype._fields = [
        "body",
        function(a) {
          return a.body
        },
        "handlers",
        function(a) {
          return a.handlers
        },
        "orelse",
        function(a) {
          return a.orelse
        },
        "finalbody",
        function(a) {
          return a.finalbody
        },
      ]
      self.Sk.astnodes.Assert.prototype._astname = "Assert"
      self.Sk.astnodes.Assert.prototype._fields = [
        "test",
        function(a) {
          return a.test
        },
        "msg",
        function(a) {
          return a.msg
        },
      ]
      self.Sk.astnodes.Import.prototype._astname = "Import"
      self.Sk.astnodes.Import.prototype._fields = [
        "names",
        function(a) {
          return a.names
        },
      ]
      self.Sk.astnodes.ImportFrom.prototype._astname = "ImportFrom"
      self.Sk.astnodes.ImportFrom.prototype._fields = [
        "module",
        function(a) {
          return a.module
        },
        "names",
        function(a) {
          return a.names
        },
        "level",
        function(a) {
          return a.level
        },
      ]
      self.Sk.astnodes.Global.prototype._astname = "Global"
      self.Sk.astnodes.Global.prototype._fields = [
        "names",
        function(a) {
          return a.names
        },
      ]
      self.Sk.astnodes.Nonlocal.prototype._astname = "Nonlocal"
      self.Sk.astnodes.Nonlocal.prototype._fields = [
        "names",
        function(a) {
          return a.names
        },
      ]
      self.Sk.astnodes.Expr.prototype._astname = "Expr"
      self.Sk.astnodes.Expr.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.Pass.prototype._astname = "Pass"
      self.Sk.astnodes.Pass.prototype._fields = []
      self.Sk.astnodes.Break.prototype._astname = "Break"
      self.Sk.astnodes.Break.prototype._fields = []
      self.Sk.astnodes.Continue.prototype._astname = "Continue"
      self.Sk.astnodes.Continue.prototype._fields = []
      self.Sk.astnodes.Print.prototype._astname = "Print"
      self.Sk.astnodes.Print.prototype._fields = [
        "dest",
        function(a) {
          return a.dest
        },
        "values",
        function(a) {
          return a.values
        },
        "nl",
        function(a) {
          return a.nl
        },
      ]
      self.Sk.astnodes.Debugger.prototype._astname = "Debugger"
      self.Sk.astnodes.Debugger.prototype._fields = []
      self.Sk.astnodes.BoolOp.prototype._astname = "BoolOp"
      self.Sk.astnodes.BoolOp.prototype._fields = [
        "op",
        function(a) {
          return a.op
        },
        "values",
        function(a) {
          return a.values
        },
      ]
      self.Sk.astnodes.BinOp.prototype._astname = "BinOp"
      self.Sk.astnodes.BinOp.prototype._fields = [
        "left",
        function(a) {
          return a.left
        },
        "op",
        function(a) {
          return a.op
        },
        "right",
        function(a) {
          return a.right
        },
      ]
      self.Sk.astnodes.UnaryOp.prototype._astname = "UnaryOp"
      self.Sk.astnodes.UnaryOp.prototype._fields = [
        "op",
        function(a) {
          return a.op
        },
        "operand",
        function(a) {
          return a.operand
        },
      ]
      self.Sk.astnodes.Lambda.prototype._astname = "Lambda"
      self.Sk.astnodes.Lambda.prototype._fields = [
        "args",
        function(a) {
          return a.args
        },
        "body",
        function(a) {
          return a.body
        },
      ]
      self.Sk.astnodes.IfExp.prototype._astname = "IfExp"
      self.Sk.astnodes.IfExp.prototype._fields = [
        "test",
        function(a) {
          return a.test
        },
        "body",
        function(a) {
          return a.body
        },
        "orelse",
        function(a) {
          return a.orelse
        },
      ]
      self.Sk.astnodes.Dict.prototype._astname = "Dict"
      self.Sk.astnodes.Dict.prototype._fields = [
        "keys",
        function(a) {
          return a.keys
        },
        "values",
        function(a) {
          return a.values
        },
      ]
      self.Sk.astnodes.Set.prototype._astname = "Set"
      self.Sk.astnodes.Set.prototype._fields = [
        "elts",
        function(a) {
          return a.elts
        },
      ]
      self.Sk.astnodes.ListComp.prototype._astname = "ListComp"
      self.Sk.astnodes.ListComp.prototype._fields = [
        "elt",
        function(a) {
          return a.elt
        },
        "generators",
        function(a) {
          return a.generators
        },
      ]
      self.Sk.astnodes.SetComp.prototype._astname = "SetComp"
      self.Sk.astnodes.SetComp.prototype._fields = [
        "elt",
        function(a) {
          return a.elt
        },
        "generators",
        function(a) {
          return a.generators
        },
      ]
      self.Sk.astnodes.DictComp.prototype._astname = "DictComp"
      self.Sk.astnodes.DictComp.prototype._fields = [
        "key",
        function(a) {
          return a.key
        },
        "value",
        function(a) {
          return a.value
        },
        "generators",
        function(a) {
          return a.generators
        },
      ]
      self.Sk.astnodes.GeneratorExp.prototype._astname = "GeneratorExp"
      self.Sk.astnodes.GeneratorExp.prototype._fields = [
        "elt",
        function(a) {
          return a.elt
        },
        "generators",
        function(a) {
          return a.generators
        },
      ]
      self.Sk.astnodes.Await.prototype._astname = "Await"
      self.Sk.astnodes.Await.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.Yield.prototype._astname = "Yield"
      self.Sk.astnodes.Yield.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.YieldFrom.prototype._astname = "YieldFrom"
      self.Sk.astnodes.YieldFrom.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.Compare.prototype._astname = "Compare"
      self.Sk.astnodes.Compare.prototype._fields = [
        "left",
        function(a) {
          return a.left
        },
        "ops",
        function(a) {
          return a.ops
        },
        "comparators",
        function(a) {
          return a.comparators
        },
      ]
      self.Sk.astnodes.Call.prototype._astname = "Call"
      self.Sk.astnodes.Call.prototype._fields = [
        "func",
        function(a) {
          return a.func
        },
        "args",
        function(a) {
          return a.args
        },
        "keywords",
        function(a) {
          return a.keywords
        },
      ]
      self.Sk.astnodes.Num.prototype._astname = "Num"
      self.Sk.astnodes.Num.prototype._fields = [
        "n",
        function(a) {
          return a.n
        },
      ]
      self.Sk.astnodes.Str.prototype._astname = "Str"
      self.Sk.astnodes.Str.prototype._fields = [
        "s",
        function(a) {
          return a.s
        },
      ]
      self.Sk.astnodes.FormattedValue.prototype._astname = "FormattedValue"
      self.Sk.astnodes.FormattedValue.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
        "conversion",
        function(a) {
          return a.conversion
        },
        "format_spec",
        function(a) {
          return a.format_spec
        },
      ]
      self.Sk.astnodes.JoinedStr.prototype._astname = "JoinedStr"
      self.Sk.astnodes.JoinedStr.prototype._fields = [
        "values",
        function(a) {
          return a.values
        },
      ]
      self.Sk.astnodes.Bytes.prototype._astname = "Bytes"
      self.Sk.astnodes.Bytes.prototype._fields = [
        "s",
        function(a) {
          return a.s
        },
      ]
      self.Sk.astnodes.NameConstant.prototype._astname = "NameConstant"
      self.Sk.astnodes.NameConstant.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.Ellipsis.prototype._astname = "Ellipsis"
      self.Sk.astnodes.Ellipsis.prototype._fields = []
      self.Sk.astnodes.Constant.prototype._astname = "Constant"
      self.Sk.astnodes.Constant.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.Attribute.prototype._astname = "Attribute"
      self.Sk.astnodes.Attribute.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
        "attr",
        function(a) {
          return a.attr
        },
        "ctx",
        function(a) {
          return a.ctx
        },
      ]
      self.Sk.astnodes.Subscript.prototype._astname = "Subscript"
      self.Sk.astnodes.Subscript.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
        "slice",
        function(a) {
          return a.slice
        },
        "ctx",
        function(a) {
          return a.ctx
        },
      ]
      self.Sk.astnodes.Starred.prototype._astname = "Starred"
      self.Sk.astnodes.Starred.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
        "ctx",
        function(a) {
          return a.ctx
        },
      ]
      self.Sk.astnodes.Name.prototype._astname = "Name"
      self.Sk.astnodes.Name.prototype._fields = [
        "id",
        function(a) {
          return a.id
        },
        "ctx",
        function(a) {
          return a.ctx
        },
      ]
      self.Sk.astnodes.List.prototype._astname = "List"
      self.Sk.astnodes.List.prototype._fields = [
        "elts",
        function(a) {
          return a.elts
        },
        "ctx",
        function(a) {
          return a.ctx
        },
      ]
      self.Sk.astnodes.Tuple.prototype._astname = "Tuple"
      self.Sk.astnodes.Tuple.prototype._fields = [
        "elts",
        function(a) {
          return a.elts
        },
        "ctx",
        function(a) {
          return a.ctx
        },
      ]
      self.Sk.astnodes.Load.prototype._astname = "Load"
      self.Sk.astnodes.Load.prototype._isenum = !0
      self.Sk.astnodes.Store.prototype._astname = "Store"
      self.Sk.astnodes.Store.prototype._isenum = !0
      self.Sk.astnodes.Del.prototype._astname = "Del"
      self.Sk.astnodes.Del.prototype._isenum = !0
      self.Sk.astnodes.AugLoad.prototype._astname = "AugLoad"
      self.Sk.astnodes.AugLoad.prototype._isenum = !0
      self.Sk.astnodes.AugStore.prototype._astname = "AugStore"
      self.Sk.astnodes.AugStore.prototype._isenum = !0
      self.Sk.astnodes.Param.prototype._astname = "Param"
      self.Sk.astnodes.Param.prototype._isenum = !0
      self.Sk.astnodes.Slice.prototype._astname = "Slice"
      self.Sk.astnodes.Slice.prototype._fields = [
        "lower",
        function(a) {
          return a.lower
        },
        "upper",
        function(a) {
          return a.upper
        },
        "step",
        function(a) {
          return a.step
        },
      ]
      self.Sk.astnodes.ExtSlice.prototype._astname = "ExtSlice"
      self.Sk.astnodes.ExtSlice.prototype._fields = [
        "dims",
        function(a) {
          return a.dims
        },
      ]
      self.Sk.astnodes.Index.prototype._astname = "Index"
      self.Sk.astnodes.Index.prototype._fields = [
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.And.prototype._astname = "And"
      self.Sk.astnodes.And.prototype._isenum = !0
      self.Sk.astnodes.Or.prototype._astname = "Or"
      self.Sk.astnodes.Or.prototype._isenum = !0
      self.Sk.astnodes.Add.prototype._astname = "Add"
      self.Sk.astnodes.Add.prototype._isenum = !0
      self.Sk.astnodes.Sub.prototype._astname = "Sub"
      self.Sk.astnodes.Sub.prototype._isenum = !0
      self.Sk.astnodes.Mult.prototype._astname = "Mult"
      self.Sk.astnodes.Mult.prototype._isenum = !0
      self.Sk.astnodes.MatMult.prototype._astname = "MatMult"
      self.Sk.astnodes.MatMult.prototype._isenum = !0
      self.Sk.astnodes.Div.prototype._astname = "Div"
      self.Sk.astnodes.Div.prototype._isenum = !0
      self.Sk.astnodes.Mod.prototype._astname = "Mod"
      self.Sk.astnodes.Mod.prototype._isenum = !0
      self.Sk.astnodes.Pow.prototype._astname = "Pow"
      self.Sk.astnodes.Pow.prototype._isenum = !0
      self.Sk.astnodes.LShift.prototype._astname = "LShift"
      self.Sk.astnodes.LShift.prototype._isenum = !0
      self.Sk.astnodes.RShift.prototype._astname = "RShift"
      self.Sk.astnodes.RShift.prototype._isenum = !0
      self.Sk.astnodes.BitOr.prototype._astname = "BitOr"
      self.Sk.astnodes.BitOr.prototype._isenum = !0
      self.Sk.astnodes.BitXor.prototype._astname = "BitXor"
      self.Sk.astnodes.BitXor.prototype._isenum = !0
      self.Sk.astnodes.BitAnd.prototype._astname = "BitAnd"
      self.Sk.astnodes.BitAnd.prototype._isenum = !0
      self.Sk.astnodes.FloorDiv.prototype._astname = "FloorDiv"
      self.Sk.astnodes.FloorDiv.prototype._isenum = !0
      self.Sk.astnodes.Invert.prototype._astname = "Invert"
      self.Sk.astnodes.Invert.prototype._isenum = !0
      self.Sk.astnodes.Not.prototype._astname = "Not"
      self.Sk.astnodes.Not.prototype._isenum = !0
      self.Sk.astnodes.UAdd.prototype._astname = "UAdd"
      self.Sk.astnodes.UAdd.prototype._isenum = !0
      self.Sk.astnodes.USub.prototype._astname = "USub"
      self.Sk.astnodes.USub.prototype._isenum = !0
      self.Sk.astnodes.Eq.prototype._astname = "Eq"
      self.Sk.astnodes.Eq.prototype._isenum = !0
      self.Sk.astnodes.NotEq.prototype._astname = "NotEq"
      self.Sk.astnodes.NotEq.prototype._isenum = !0
      self.Sk.astnodes.Lt.prototype._astname = "Lt"
      self.Sk.astnodes.Lt.prototype._isenum = !0
      self.Sk.astnodes.LtE.prototype._astname = "LtE"
      self.Sk.astnodes.LtE.prototype._isenum = !0
      self.Sk.astnodes.Gt.prototype._astname = "Gt"
      self.Sk.astnodes.Gt.prototype._isenum = !0
      self.Sk.astnodes.GtE.prototype._astname = "GtE"
      self.Sk.astnodes.GtE.prototype._isenum = !0
      self.Sk.astnodes.Is.prototype._astname = "Is"
      self.Sk.astnodes.Is.prototype._isenum = !0
      self.Sk.astnodes.IsNot.prototype._astname = "IsNot"
      self.Sk.astnodes.IsNot.prototype._isenum = !0
      self.Sk.astnodes.In.prototype._astname = "In"
      self.Sk.astnodes.In.prototype._isenum = !0
      self.Sk.astnodes.NotIn.prototype._astname = "NotIn"
      self.Sk.astnodes.NotIn.prototype._isenum = !0
      self.Sk.astnodes.comprehension.prototype._astname = "comprehension"
      self.Sk.astnodes.comprehension.prototype._fields = [
        "target",
        function(a) {
          return a.target
        },
        "iter",
        function(a) {
          return a.iter
        },
        "ifs",
        function(a) {
          return a.ifs
        },
        "is_async",
        function(a) {
          return a.is_async
        },
      ]
      self.Sk.astnodes.ExceptHandler.prototype._astname = "ExceptHandler"
      self.Sk.astnodes.ExceptHandler.prototype._fields = [
        "type",
        function(a) {
          return a.type
        },
        "name",
        function(a) {
          return a.name
        },
        "body",
        function(a) {
          return a.body
        },
      ]
      self.Sk.astnodes.arguments_.prototype._astname = "arguments"
      self.Sk.astnodes.arguments_.prototype._fields = [
        "args",
        function(a) {
          return a.args
        },
        "vararg",
        function(a) {
          return a.vararg
        },
        "kwonlyargs",
        function(a) {
          return a.kwonlyargs
        },
        "kw_defaults",
        function(a) {
          return a.kw_defaults
        },
        "kwarg",
        function(a) {
          return a.kwarg
        },
        "defaults",
        function(a) {
          return a.defaults
        },
      ]
      self.Sk.astnodes.arg.prototype._astname = "arg"
      self.Sk.astnodes.arg.prototype._fields = [
        "arg",
        function(a) {
          return a.arg
        },
        "annotation",
        function(a) {
          return a.annotation
        },
      ]
      self.Sk.astnodes.keyword.prototype._astname = "keyword"
      self.Sk.astnodes.keyword.prototype._fields = [
        "arg",
        function(a) {
          return a.arg
        },
        "value",
        function(a) {
          return a.value
        },
      ]
      self.Sk.astnodes.alias.prototype._astname = "alias"
      self.Sk.astnodes.alias.prototype._fields = [
        "name",
        function(a) {
          return a.name
        },
        "asname",
        function(a) {
          return a.asname
        },
      ]
      self.Sk.astnodes.withitem.prototype._astname = "withitem"
      self.Sk.astnodes.withitem.prototype._fields = [
        "context_expr",
        function(a) {
          return a.context_expr
        },
        "optional_vars",
        function(a) {
          return a.optional_vars
        },
      ]
      self.Sk.exportSymbol("Sk.astnodes", self.Sk.astnodes)
    },
    function(m, p) {
      function a(a, b, c) {
        this.c_encoding = a
        this.c_filename = b
        this.c_flags = c || 0
      }
      function b(a) {
        self.Sk.asserts.assert(void 0 !== a, "node must be defined")
        return null === a.children ? 0 : a.children.length
      }
      function c(a, b) {
        self.Sk.asserts.assert(void 0 !== a, "node must be defined")
        self.Sk.asserts.assert(void 0 !== b, "index of child must be specified")
        return a.children[b]
      }
      function d(a, b) {
        self.Sk.asserts.assert(a.type === b, "node wasn't expected type")
      }
      function e(a, b, c) {
        throw new self.Sk.builtin.SyntaxError(c, a.c_filename, b.lineno)
      }
      function f(a) {
        self.Sk.asserts.assert(
          "string" === typeof a,
          "expecting string, got " + typeof a,
        )
        return new self.Sk.builtin.str(a)
      }
      function g(a) {
        var d, e
        switch (a.type) {
          case t.single_input:
            if (c(a, 0).type === v.T_NEWLINE) break
            else return g(c(a, 0))
          case t.file_input:
            for (d = e = 0; d < b(a); ++d) {
              var k = c(a, d)
              k.type === t.stmt && (e += g(k))
            }
            return e
          case t.stmt:
            return g(c(a, 0))
          case t.compound_stmt:
            return 1
          case t.simple_stmt:
            return Math.floor(b(a) / 2)
          case t.suite:
            if (1 === b(a)) return g(c(a, 0))
            e = 0
            for (d = 2; d < b(a) - 1; ++d) e += g(c(a, d))
            return e
          default:
            self.Sk.asserts.fail("Non-statement found")
        }
        return 0
      }
      function h(a, b, c, d) {
        c instanceof self.Sk.builtin.str && (c = c.v)
        if ("None" === c)
          throw new self.Sk.builtin.SyntaxError(
            "assignment to None",
            a.c_filename,
            d,
          )
        if ("True" === c || "False" === c)
          throw new self.Sk.builtin.SyntaxError(
            "assignment to True or False is forbidden",
            a.c_filename,
            d,
          )
      }
      function k(a, b, c, d) {
        var e
        self.Sk.asserts.assert(
          c !== self.Sk.astnodes.AugStore && c !== self.Sk.astnodes.AugLoad,
          "context not AugStore or AugLoad",
        )
        var g = (e = null)
        switch (b.constructor) {
          case self.Sk.astnodes.Attribute:
          case self.Sk.astnodes.Name:
            c === self.Sk.astnodes.Store && h(a, d, b.attr, d.lineno)
            b.ctx = c
            break
          case self.Sk.astnodes.Subscript:
            b.ctx = c
            break
          case self.Sk.astnodes.List:
            b.ctx = c
            e = b.elts
            break
          case self.Sk.astnodes.Tuple:
            if (0 === b.elts.length)
              throw new self.Sk.builtin.SyntaxError(
                "can't assign to ()",
                a.c_filename,
                d.lineno,
              )
            b.ctx = c
            e = b.elts
            break
          case self.Sk.astnodes.Lambda:
            g = "lambda"
            break
          case self.Sk.astnodes.Call:
            g = "function call"
            break
          case self.Sk.astnodes.BoolOp:
          case self.Sk.astnodes.BinOp:
          case self.Sk.astnodes.UnaryOp:
            g = "operator"
            break
          case self.Sk.astnodes.GeneratorExp:
            g = "generator expression"
            break
          case self.Sk.astnodes.Yield:
            g = "yield expression"
            break
          case self.Sk.astnodes.ListComp:
            g = "list comprehension"
            break
          case self.Sk.astnodes.SetComp:
            g = "set comprehension"
            break
          case self.Sk.astnodes.DictComp:
            g = "dict comprehension"
            break
          case self.Sk.astnodes.Dict:
          case self.Sk.astnodes.Set:
          case self.Sk.astnodes.Num:
          case self.Sk.astnodes.Str:
            g = "literal"
            break
          case self.Sk.astnodes.NameConstant:
            g = "True, False or None"
            break
          case self.Sk.astnodes.Compare:
            g = "comparison"
            break
          case self.Sk.astnodes.Repr:
            g = "repr"
            break
          case self.Sk.astnodes.IfExp:
            g = "conditional expression"
            break
          default:
            self.Sk.asserts.fail("unhandled expression in assignment")
        }
        if (g)
          throw new self.Sk.builtin.SyntaxError(
            "can't " +
              (c === self.Sk.astnodes.Store ? "assign to" : "delete") +
              " " +
              g,
            a.c_filename,
            d.lineno,
          )
        if (e) for (b = 0; b < e.length; ++b) k(a, e[b], c, d)
      }
      function l(a) {
        if (void 0 === M[a.type])
          throw new self.Sk.builtin.SyntaxError("invalid syntax", a.type, a.lineno)
        return M[a.type]
      }
      function r(a, b) {
        return a.value ? self.Sk.builtin.str(a.value) : self.Sk.builtin.str(a)
      }
      function n(a, e) {
        d(e, t.comp_op)
        if (1 === b(e))
          switch (((e = c(e, 0)), e.type)) {
            case v.T_LESS:
              return self.Sk.astnodes.Lt
            case v.T_GREATER:
              return self.Sk.astnodes.Gt
            case v.T_EQEQUAL:
              return self.Sk.astnodes.Eq
            case v.T_LESSEQUAL:
              return self.Sk.astnodes.LtE
            case v.T_GREATEREQUAL:
              return self.Sk.astnodes.GtE
            case v.T_NOTEQUAL:
              return self.Sk.astnodes.NotEq
            case v.T_NAME:
              if ("in" === e.value) return self.Sk.astnodes.In
              if ("is" === e.value) return self.Sk.astnodes.Is
          }
        else if (2 === b(e) && c(e, 0).type === v.T_NAME) {
          if ("in" === c(e, 1).value) return self.Sk.astnodes.NotIn
          if ("is" === c(e, 0).value) return self.Sk.astnodes.IsNot
        }
        self.Sk.asserts.fail("invalid comp_op")
      }
      function q(a, b) {
        a &&
          ((a.lineno = b.lineno),
          (a.col_offset = b.col_offset),
          (a.end_lineno = b.end_lineno),
          (a.end_col_offset = b.end_col_offset))
        return a
      }
      function D(a, d) {
        var e,
          k = []
        self.Sk.asserts.assert(
          d.type === t.testlist ||
            d.type === t.testlist_star_expr ||
            d.type === t.listmaker ||
            d.type === t.testlist_comp ||
            d.type === t.testlist_safe ||
            d.type === t.testlist1,
          "node type must be listlike",
        )
        for (e = 0; e < b(d); e += 2)
          self.Sk.asserts.assert(
            c(d, e).type === t.test ||
              c(d, e).type === t.old_test ||
              c(d, e).type === t.star_expr,
          ),
            (k[e / 2] = u(a, c(d, e)))
        return k
      }
      function x(a, e) {
        var k
        d(e, t.suite)
        var f = []
        var l = 0
        if (c(e, 0).type === t.simple_stmt) {
          e = c(e, 0)
          var w = b(e) - 1
          c(e, w - 1).type === v.T_SEMI && --w
          for (k = 0; k < w; k += 2) f[l++] = L(a, c(e, k))
        } else
          for (k = 2; k < b(e) - 1; ++k) {
            w = c(e, k)
            d(w, t.stmt)
            var h = g(w)
            if (1 === h) f[l++] = L(a, w)
            else
              for (w = c(w, 0), d(w, t.simple_stmt), h = 0; h < b(w); h += 2) {
                if (0 === b(c(w, h))) {
                  self.Sk.asserts.assert(h + 1 === b(w))
                  break
                }
                f[l++] = L(a, c(w, h))
              }
          }
        self.Sk.asserts.assert(l === g(e))
        return f
      }
      function H(a, e, g) {
        var f
        d(e, t.exprlist)
        var l = []
        for (f = 0; f < b(e); f += 2) {
          var w = u(a, c(e, f))
          l[f / 2] = w
          g && k(a, w, g, c(e, f))
        }
        return l
      }
      function J(a, d) {
        a: for (;;)
          switch (d.type) {
            case t.import_as_name:
              a = null
              var e = f(c(d, 0).value)
              3 === b(d) && (a = c(d, 2).value)
              return new self.Sk.astnodes.alias(e, null == a ? null : f(a))
            case t.dotted_as_name:
              if (1 === b(d)) {
                d = c(d, 0)
                continue a
              } else
                return (
                  (a = J(a, c(d, 0))),
                  self.Sk.asserts.assert(!a.asname),
                  (a.asname = f(c(d, 2).value)),
                  a
                )
            case t.dotted_name:
              if (1 === b(d))
                return new self.Sk.astnodes.alias(f(c(d, 0).value), null)
              a = ""
              for (e = 0; e < b(d); e += 2) a += c(d, e).value + "."
              return new self.Sk.astnodes.alias(f(a.substr(0, a.length - 1)), null)
            case v.T_STAR:
              return new self.Sk.astnodes.alias(f("*"), null)
            default:
              throw new self.Sk.builtin.SyntaxError(
                "unexpected import name",
                a.c_filename,
                d.lineno,
              )
          }
      }
      function A(a, b) {
        self.Sk.asserts.assert(b.type == t.testlist_comp || b.type == t.argument)
        return Z(a, b, 0)
      }
      function C(a, d) {
        if (c(d, 0).type === v.T_MINUS && 2 === b(d)) {
          var e = c(d, 1)
          if (
            e.type === t.factor &&
            1 === b(e) &&
            ((e = c(e, 0)), e.type === t.power && 1 === b(e))
          ) {
            var k = c(e, 0)
            if (k.type === t.atom && ((e = c(k, 0)), e.type === v.T_NUMBER))
              return (e.value = "-" + e.value), Q(a, k)
          }
        }
        a = u(a, c(d, 1))
        switch (c(d, 0).type) {
          case v.T_PLUS:
            return new self.Sk.astnodes.UnaryOp(
              self.Sk.astnodes.UAdd,
              a,
              d.lineno,
              d.col_offset,
            )
          case v.T_MINUS:
            return new self.Sk.astnodes.UnaryOp(
              self.Sk.astnodes.USub,
              a,
              d.lineno,
              d.col_offset,
            )
          case v.T_TILDE:
            return new self.Sk.astnodes.UnaryOp(
              self.Sk.astnodes.Invert,
              a,
              d.lineno,
              d.col_offset,
            )
        }
        self.Sk.asserts.fail("unhandled factor")
      }
      function K(a, k, g, f) {
        var l, w, r
        d(k, t.arglist)
        for (l = r = w = 0; l < b(k); l++) {
          var n = c(k, l)
          n.type == t.argument &&
            (1 == b(n)
              ? w++
              : c(n, 1).type == t.comp_for
              ? (w++,
                f || e(a, n, "invalid syntax"),
                1 < b(k) &&
                  e(a, n, "Generator expression must be parenthesized"))
              : c(n, 0).type == v.T_STAR
              ? w++
              : r++)
        }
        var R = []
        var T = []
        for (l = f = r = w = 0; l < b(k); l++)
          if (((n = c(k, l)), n.type == t.argument)) {
            var O = c(n, 0)
            if (1 == b(n)) {
              r &&
                (f
                  ? e(
                      a,
                      O,
                      "positional argument follows keyword argument unpacking",
                    )
                  : e(a, O, "positional argument follows keyword argument"))
              var q = u(a, O)
              if (!q) return null
              R[w++] = q
            } else if (O.type == v.T_STAR) {
              if (f)
                return (
                  e(
                    a,
                    O,
                    "iterable argument unpacking follows keyword argument unpacking",
                  ),
                  null
                )
              q = u(a, c(n, 1))
              if (!q) return null
              n = new self.Sk.astnodes.Starred(
                q,
                self.Sk.astnodes.Load,
                O.lineno,
                O.col_offset,
              )
              R[w++] = n
            } else if (O.type == v.T_DOUBLESTAR) {
              l++
              q = u(a, c(n, 1))
              if (!q) return null
              n = new self.Sk.astnodes.keyword(null, q)
              T[r++] = n
              f++
            } else if (c(n, 1).type == t.comp_for) {
              q = A(a, n)
              if (!q) return null
              R[w++] = q
            } else {
              var m
              q = u(a, O)
              if (!q) return null
              if (q.constructor === self.Sk.astnodes.Lambda)
                return e(a, O, "lambda cannot contain assignment"), null
              if (q.constructor !== self.Sk.astnodes.Name)
                return e(a, O, "keyword can't be an expression"), null
              if (h(a, q.id, n, 1)) return null
              var p = q.id
              for (m = 0; m < r; m++)
                if ((q = T[m].arg) && q === p)
                  return e(a, O, "keyword argument repeated"), null
              q = u(a, c(n, 2))
              if (!q) return null
              n = new self.Sk.astnodes.keyword(p, q)
              T[r++] = n
            }
          }
        return new self.Sk.astnodes.Call(g, R, T, g.lineno, g.col_offset)
      }
      function B(a, e, k) {
        d(e, t.trailer)
        if (c(e, 0).type == v.T_LPAR)
          return 2 == b(e)
            ? new self.Sk.astnodes.Call(k, null, null, e.lineno, e.col_offset)
            : K(a, c(e, 1), k, !0)
        if (c(e, 0).type == v.T_DOT) {
          var g = r(c(e, 1))
          return g
            ? new self.Sk.astnodes.Attribute(
                k,
                g,
                self.Sk.astnodes.Load,
                e.lineno,
                e.col_offset,
              )
            : null
        }
        d(c(e, 0), v.T_LSQB)
        d(c(e, 2), v.T_RSQB)
        e = c(e, 1)
        if (1 == b(e))
          return (g = F(a, c(e, 0)))
            ? new self.Sk.astnodes.Subscript(
                k,
                g,
                self.Sk.astnodes.Load,
                e.lineno,
                e.col_offset,
              )
            : null
        var f,
          l = 1,
          w = []
        for (f = 0; f < b(e); f += 2) {
          g = F(a, c(e, f))
          if (!g) return null
          g.kind != W.Index_kind && (l = 0)
          w[f / 2] = g
        }
        if (!l)
          return new self.Sk.astnodes.Subscript(
            k,
            new self.Sk.astnodes.ExtSlice(w),
            self.Sk.astnodes.Load,
            e.lineno,
            e.col_offset,
          )
        a = []
        for (f = 0; f < w.length; ++f)
          (g = w[f]),
            self.Sk.asserts.assert(g.kind == W.Index_kind && g.v.Index.value),
            (a[f] = g.v.Index.value)
        g = new self.Sk.astnodes.Tuple(a, self.Sk.astnodes.Load, e.lineno, e.col_offset)
        return new self.Sk.astnodes.Subscript(
          k,
          new self.Sk.astnodes.Index(g),
          self.Sk.astnodes.Load,
          e.lineno,
          e.col_offset,
        )
      }
      function S(a, k) {
        d(k, t.flow_stmt)
        var g = c(k, 0)
        switch (g.type) {
          case t.break_stmt:
            return new self.Sk.astnodes.Break(
              k.lineno,
              k.col_offset,
              k.end_lineno,
              k.end_col_offset,
            )
          case t.continue_stmt:
            return new self.Sk.astnodes.Continue(
              k.lineno,
              k.col_offset,
              k.end_lineno,
              k.end_col_offset,
            )
          case t.yield_stmt:
            return (a = u(a, c(g, 0)))
              ? new self.Sk.astnodes.Expr(
                  a,
                  k.lineno,
                  k.col_offset,
                  k.end_lineno,
                  k.end_col_offset,
                )
              : null
          case t.return_stmt:
            if (1 == b(g))
              return new self.Sk.astnodes.Return(
                null,
                k.lineno,
                k.col_offset,
                k.end_lineno,
                k.end_col_offset,
              )
            var f = I(a, c(g, 1))
            return f
              ? new self.Sk.astnodes.Return(
                  f,
                  k.lineno,
                  k.col_offset,
                  k.end_lineno,
                  k.end_col_offset,
                )
              : null
          case t.raise_stmt:
            if (1 == b(g))
              return new self.Sk.astnodes.Raise(
                null,
                null,
                null,
                null,
                k.lineno,
                k.col_offset,
                k.end_lineno,
                k.end_col_offset,
              )
            if (2 <= b(g)) {
              var l = null
              f = u(a, c(g, 1))
              var w = null,
                h = null
              4 == b(g) && "from" == c(g, 2).value
                ? (self.Sk.__future__.python3 ||
                    e(
                      a,
                      c(g, 2),
                      "raise ... from ... is not available in Python 2",
                    ),
                  (l = u(a, c(g, 3))))
                : 4 <= b(g) &&
                  "," == c(g, 2).value &&
                  (self.Sk.__future__.python3 &&
                    e(a, k, "Old raise syntax is not available in Python 3"),
                  (w = u(a, c(g, 3))),
                  6 == b(g) && (h = u(a, c(g, 5))))
              return new self.Sk.astnodes.Raise(
                f,
                l,
                w,
                h,
                k.lineno,
                k.col_offset,
                k.end_lineno,
                k.end_col_offset,
              )
            }
          default:
            return self.Sk.asserts.fail("unexpected flow_stmt: ", g.type), null
        }
      }
      function G(a, d) {
        var e = null
        self.Sk.asserts.assert(d.type === t.tfpdef || d.type === t.vfpdef)
        var k = c(d, 0)
        h(a, k, k.value, k.lineno)
        k = f(k.value)
        3 == b(d) && c(d, 1).type === v.T_COLON && (e = u(a, c(d, 2)))
        return new self.Sk.astnodes.arg(k, e, d.lineno, d.col_offset)
      }
      function z(a, d, k, g, l) {
        var w = k,
          r = 0
        g || e(a, c(d, k), "named arguments must follow bare *")
        for (self.Sk.asserts.assert(l); w < b(d); ) {
          var n = c(d, w)
          switch (n.type) {
            case t.vfpdef:
            case t.tfpdef:
              w + 1 < b(d) && c(d, w + 1).type == v.T_EQUAL
                ? ((l[r] = u(a, c(d, w + 2))), (w += 2))
                : (l[r] = null)
              var R = 3 == b(n) ? u(a, c(n, 2)) : null
              n = c(n, 0)
              h(a, n, n.value, n.lineno)
              k = f(n.value)
              g[r++] = new self.Sk.astnodes.arg(k, R, n.lineno, n.col_offset)
              w += 2
              break
            case v.T_DOUBLESTAR:
              return w
            default:
              e(a, n, "unexpected node")
          }
        }
        return w
      }
      function P(a, d) {
        var e,
          k,
          g,
          f = [],
          l = [],
          h = [],
          w = [],
          r = null,
          n = null
        if (d.type === t.parameters) {
          if (2 === b(d))
            return new self.Sk.astnodes.arguments_([], null, [], [], null, [])
          d = c(d, 1)
        }
        self.Sk.asserts.assert(
          d.type === t.varargslist || d.type === t.typedargslist,
        )
        for (e = k = g = 0; g < b(d); ) {
          var q = c(d, g)
          switch (q.type) {
            case t.tfpdef:
            case t.vfpdef:
              if (g + 1 < b(d) && c(d, g + 1).type == v.T_EQUAL) {
                l[k++] = u(a, c(d, g + 2))
                g += 2
                var T = 1
              } else if (T)
                throw new self.Sk.builtin.SyntaxError(
                  "non-default argument follows default argument",
                  a.c_filename,
                  d.lineno,
                )
              f[e++] = G(a, q)
              g += 2
              break
            case v.T_STAR:
              if (
                g + 1 >= b(d) ||
                (g + 2 == b(d) && c(d, g + 1).type == v.T_COMMA)
              )
                throw new self.Sk.builtin.SyntaxError(
                  "named arguments must follow bare *",
                  a.c_filename,
                  d.lineno,
                )
              q = c(d, g + 1)
              q.type == v.T_COMMA
                ? ((g += 2), (g = z(a, d, g, h, w)))
                : ((r = G(a, q)),
                  (g += 3),
                  g < b(d) &&
                    (c(d, g).type == t.tfpdef || c(d, g).type == t.vfpdef) &&
                    (g = z(a, d, g, h, w)))
              break
            case v.T_DOUBLESTAR:
              q = c(d, g + 1)
              self.Sk.asserts.assert(q.type == t.tfpdef || q.type == t.vfpdef)
              n = G(a, q)
              g += 3
              break
            default:
              self.Sk.asserts.fail("unexpected node in varargslist")
              return
          }
        }
        return new self.Sk.astnodes.arguments_(f, r, h, w, n, l)
      }
      function V(a, k, g, f) {
        var l = f ? c(k, 1) : k,
          w = null,
          n = 1,
          R = null
        if (f && 5 > a.c_feature_version)
          return (
            e(
              a,
              l,
              "Async functions are only supported in Python 3.5 and greater",
            ),
            null
          )
        d(l, t.funcdef)
        var q = r(c(l, n))
        if (h(a, q, c(l, n), 0)) return null
        var T = P(a, c(l, n + 1))
        if (!T) return null
        if (c(l, n + 2).type == v.T_RARROW) {
          w = u(a, c(l, n + 3))
          if (!w) return null
          n += 2
        }
        if (c(l, n + 3).type == v.T_TYPE_COMMENT) {
          R = v.T_NEW_TYPE_COMMENT(c(l, n + 3))
          if (!R) return null
          n += 1
        }
        var O = x(a, c(l, n + 3))
        if (!O) return null
        if (
          1 < b(c(l, n + 3)) &&
          ((n = c(c(l, n + 3), 1)), n.type == v.T_TYPE_COMMENT)
        ) {
          if (null != R)
            return e(a, l, "Cannot have two type comments on def"), null
          R = v.T_NEW_TYPE_COMMENT(n)
          if (!R) return null
        }
        return f
          ? new self.Sk.astnodes.AsyncFunctionDef(
              q,
              T,
              O,
              g,
              w,
              R,
              k.lineno,
              k.col_offset,
              void 0,
              void 0,
            )
          : new self.Sk.astnodes.FunctionDef(
              q,
              T,
              O,
              g,
              w,
              R,
              l.lineno,
              l.col_offset,
              void 0,
              void 0,
            )
      }
      function X(a, e, k) {
        d(e, t.classdef)
        if (4 == b(e)) {
          var g = x(a, c(e, 3))
          var f = r(c(e, 1).value)
          h(a, c(e, 3), f, e.lineno)
          return new self.Sk.astnodes.ClassDef(
            f,
            [],
            [],
            g,
            k,
            null,
            e.lineno,
            e.col_offset,
          )
        }
        if (c(e, 3).type === v.T_RPAR)
          return (
            (g = x(a, c(e, 5))),
            (f = r(c(e, 1).value)),
            h(a, c(e, 3), f, c(e, 3).lineno),
            new self.Sk.astnodes.ClassDef(
              f,
              [],
              [],
              g,
              k,
              null,
              e.lineno,
              e.col_offset,
            )
          )
        f = r(c(e, 1))
        f = new self.Sk.astnodes.Name(f, self.Sk.astnodes.Load, e.lineno, e.col_offset)
        var l = K(a, c(e, 3), f, !1)
        g = x(a, c(e, 6))
        f = r(c(e, 1).value)
        h(a, c(e, 1), f, c(e, 1).lineno)
        return new self.Sk.astnodes.ClassDef(
          f,
          l.args,
          l.keywords,
          g,
          k,
          null,
          e.lineno,
          e.col_offset,
        )
      }
      function Y(a, e) {
        function k(a, e) {
          for (a = 0; ; ) {
            d(e, t.comp_iter)
            if (c(e, 0).type === t.comp_for) return a
            e = c(e, 0)
            d(e, t.comp_if)
            a++
            if (2 === b(e)) return a
            e = c(e, 2)
          }
        }
        var g
        var f = (function(a, e) {
          a = 0
          a: for (;;) {
            a++
            d(e, t.comp_for)
            if (5 === b(e)) e = c(e, 4)
            else return a
            b: for (;;) {
              d(e, t.comp_iter)
              e = c(e, 0)
              if (e.type === t.comp_for) continue a
              else if (e.type === t.comp_if)
                if (3 === b(e)) {
                  e = c(e, 2)
                  continue b
                } else return a
              break
            }
            break
          }
          self.Sk.asserts.fail("logic error in countCompFors")
        })(a, e)
        var l = []
        for (g = 0; g < f; ++g) {
          d(e, t.comp_for)
          var h = c(e, 1)
          var n = H(a, h, self.Sk.astnodes.Store)
          var r = u(a, c(e, 3))
          var w =
            1 === b(h)
              ? new self.Sk.astnodes.comprehension(n[0], r, [])
              : new self.Sk.astnodes.comprehension(
                  new self.Sk.astnodes.Tuple(
                    n,
                    self.Sk.astnodes.Store,
                    e.lineno,
                    e.col_offset,
                  ),
                  r,
                  [],
                )
          if (5 === b(e)) {
            e = c(e, 4)
            var q = k(a, e)
            h = []
            for (n = 0; n < q; ++n)
              d(e, t.comp_iter),
                (e = c(e, 0)),
                d(e, t.comp_if),
                (r = u(a, c(e, 1))),
                (h[n] = r),
                3 === b(e) && (e = c(e, 2))
            e.type === t.comp_iter && (e = c(e, 0))
            w.ifs = h
          }
          l[g] = w
        }
        return l
      }
      function aa(a, e) {
        var k = []
        a: {
          var g = e
          var f = 0
          b: for (;;) {
            var l = 0
            f++
            d(g, t.comp_for)
            c(g, 0).type == v.T_ASYNC && (l = 1)
            if (b(g) == 5 + l) g = c(g, 4 + l)
            else break a
            c: for (;;) {
              d(g, t.comp_iter)
              g = c(g, 0)
              if (g.type === t.comp_for) continue b
              else if (g.type === t.comp_if)
                if (3 === b(g)) {
                  g = c(g, 2)
                  continue c
                } else break a
              break
            }
            break
          }
          f = void 0
        }
        for (g = 0; g < f; g++) {
          var h = 0
          c(e, 0).type == v.T_ASYNC && (h = 1)
          var n = c(e, 1 + h)
          var r = H(a, n, self.Sk.astnodes.Store)
          if (!r) return null
          l = u(a, c(e, 3 + h))
          if (!l) return null
          var w = r[0]
          r =
            1 == b(n)
              ? new self.Sk.astnodes.comprehension(w, l, null, h)
              : new self.Sk.astnodes.comprehension(
                  new self.Sk.astnodes.Tuple(
                    r,
                    self.Sk.astnodes.Store,
                    w.lineno,
                    w.col_offset,
                    n.end_lineno,
                    n.end_col_offset,
                  ),
                  l,
                  null,
                  h,
                )
          if (b(e) == 5 + h) {
            w = []
            e = c(e, 4 + h)
            a: for (l = e, h = 0; ; ) {
              d(l, t.comp_iter)
              if (c(l, 0).type == t.comp_for) {
                n = h
                break a
              }
              l = c(l, 0)
              d(l, t.comp_if)
              h++
              if (2 == b(l)) {
                n = h
                break a
              }
              l = c(l, 2)
            }
            if (-1 == n) return null
            for (h = 0; h < n; h++) {
              d(e, t.comp_iter)
              e = c(e, 0)
              d(e, t.comp_if)
              l = u(a, c(e, 1))
              if (!l) return null
              w[h] = l
              3 == b(e) && (e = c(e, 2))
            }
            e.type == t.comp_iter && (e = c(e, 0))
            r.ifs = w
          }
          k[g] = r
        }
        return k
      }
      function Z(a, d, k) {
        self.Sk.asserts.assert(1 < b(d))
        var g = c(d, 0)
        var f = u(a, g)
        if (f.constructor === self.Sk.astnodes.Starred)
          return (
            e(a, g, "iterable unpacking cannot be used in comprehension"), null
          )
        a = aa(a, c(d, 1))
        return 0 == k
          ? new self.Sk.astnodes.GeneratorExp(
              f,
              a,
              d.lineno,
              d.col_offset,
              d.end_lineno,
              d.end_col_offset,
            )
          : 1 == k
          ? new self.Sk.astnodes.ListComp(
              f,
              a,
              d.lineno,
              d.col_offset,
              d.end_lineno,
              d.end_col_offset,
            )
          : 2 == k
          ? new self.Sk.astnodes.SetComp(
              f,
              a,
              d.lineno,
              d.col_offset,
              d.end_lineno,
              d.end_col_offset,
            )
          : null
      }
      function ba(a, b) {
        d(b, t.augassign)
        b = c(b, 0)
        switch (b.value.charAt(0)) {
          case "+":
            return self.Sk.astnodes.Add
          case "-":
            return self.Sk.astnodes.Sub
          case "/":
            return "/" === b.value.charAt(1)
              ? self.Sk.astnodes.FloorDiv
              : self.Sk.astnodes.Div
          case "%":
            return self.Sk.astnodes.Mod
          case "<":
            return self.Sk.astnodes.LShift
          case ">":
            return self.Sk.astnodes.RShift
          case "&":
            return self.Sk.astnodes.BitAnd
          case "^":
            return self.Sk.astnodes.BitXor
          case "|":
            return self.Sk.astnodes.BitOr
          case "*":
            return "*" === b.value.charAt(1)
              ? self.Sk.astnodes.Pow
              : self.Sk.astnodes.Mult
          case "@":
            if (self.Sk.__future__.python3) return self.Sk.astnodes.MatMult
          default:
            self.Sk.asserts.fail("invalid augassign")
        }
      }
      function I(a, d) {
        self.Sk.asserts.assert(0 < b(d))
        d.type === t.testlist_comp
          ? 1 < b(d) && self.Sk.asserts.assert(c(d, 1).type !== t.comp_for)
          : self.Sk.asserts.assert(
              d.type === t.testlist || d.type === t.testlist_star_expr,
            )
        return 1 === b(d)
          ? u(a, c(d, 0))
          : new self.Sk.astnodes.Tuple(
              D(a, d),
              self.Sk.astnodes.Load,
              d.lineno,
              d.col_offset,
            )
      }
      function E(a, e) {
        d(e, t.expr_stmt)
        if (1 === b(e))
          return new self.Sk.astnodes.Expr(I(a, c(e, 0)), e.lineno, e.col_offset)
        if (c(e, 1).type === t.augassign) {
          var g = c(e, 0)
          var f = I(a, g)
          k(a, f, self.Sk.astnodes.Store, g)
          switch (f.constructor) {
            case self.Sk.astnodes.Name:
              var l = f.id
              h(a, g, l, e.lineno)
              break
            case self.Sk.astnodes.Attribute:
            case self.Sk.astnodes.Subscript:
              break
            case self.Sk.astnodes.GeneratorExp:
              throw new self.Sk.builtin.SyntaxError(
                "augmented assignment to generator expression not possible",
                a.c_filename,
                e.lineno,
              )
            case self.Sk.astnodes.Yield:
              throw new self.Sk.builtin.SyntaxError(
                "augmented assignment to yield expression not possible",
                a.c_filename,
                e.lineno,
              )
            default:
              throw new self.Sk.builtin.SyntaxError(
                "illegal expression for augmented assignment",
                a.c_filename,
                e.lineno,
              )
          }
          g = c(e, 2)
          l = g.type === t.testlist ? I(a, g) : u(a, g)
          return new self.Sk.astnodes.AugAssign(
            f,
            ba(a, c(e, 1)),
            l,
            e.lineno,
            e.col_offset,
          )
        }
        if (c(e, 1).type === t.annassign) {
          if (!self.Sk.__future__.python3)
            throw new self.Sk.builtin.SyntaxError(
              "Annotated assignment is not supported in Python 2",
              a.c_filename,
              e.lineno,
            )
          g = c(e, 0)
          var n = c(e, 1)
          var r = 1
          for (f = g; 1 == b(f); ) f = c(f, 0)
          0 < b(f) && c(f, 0).type == v.T_LPAR && (r = 0)
          f = I(a, g)
          switch (f.constructor) {
            case self.Sk.astnodes.Name:
              l = f.id
              h(a, g, l, e.lineno)
              k(a, f, self.Sk.astnodes.Store, g)
              break
            case self.Sk.astnodes.Attribute:
              l = f.attr
              h(a, g, l, e.lineno)
              k(a, f, self.Sk.astnodes.Store, g)
              break
            case self.Sk.astnodes.Subscript:
              k(a, f, self.Sk.astnodes.Store, g)
              break
            case self.Sk.astnodes.List:
              throw new self.Sk.builtin.SyntaxError(
                "only single target (not list) can be annotated",
                a.c_filename,
                e.lineno,
              )
            case self.Sk.astnodes.Tuple:
              throw new self.Sk.builtin.SyntaxError(
                "only single target (not tuple) can be annotated",
                a.c_filename,
                e.lineno,
              )
            default:
              throw new self.Sk.builtin.SyntaxError(
                "illegal target for annotation",
                a.c_filename,
                e.lineno,
              )
          }
          f.constructor != self.Sk.astnodes.Name && (r = 0)
          g = c(n, 1)
          l = u(a, g)
          if (2 == b(n))
            return new self.Sk.astnodes.AnnAssign(
              f,
              l,
              null,
              r,
              e.lineno,
              e.col_offset,
            )
          g = c(n, 3)
          a = u(a, g)
          return new self.Sk.astnodes.AnnAssign(f, l, a, r, e.lineno, e.col_offset)
        }
        d(c(e, 1), v.T_EQUAL)
        r = []
        for (f = 0; f < b(e) - 2; f += 2) {
          g = c(e, f)
          if (g.type === t.yield_expr)
            throw new self.Sk.builtin.SyntaxError(
              "assignment to yield expression not possible",
              a.c_filename,
              e.lineno,
            )
          g = I(a, g)
          k(a, g, self.Sk.astnodes.Store, c(e, f))
          r[f / 2] = g
        }
        g = c(e, b(e) - 1)
        a = g.type === t.testlist_star_expr ? I(a, g) : u(a, g)
        return new self.Sk.astnodes.Assign(r, a, e.lineno, e.col_offset)
      }
      function N(a, b) {
        var c = b.charAt(0),
          d = !1,
          e = !1
        if (
          a.c_flags & self.Sk.Parser.CO_FUTURE_UNICODE_LITERALS ||
          !0 === self.Sk.__future__.unicode_literals
        )
          e = !0
        if ("u" === c || "U" === c)
          (b = b.substr(1)), (c = b.charAt(0)), (e = !0)
        else if ("r" === c || "R" === c)
          (b = b.substr(1)), (c = b.charAt(0)), (d = !0)
        self.Sk.asserts.assert(
          "b" !== c && "B" !== c,
          "todo; haven't done b'' strings yet",
        )
        self.Sk.asserts.assert(
          "'" === c || ('"' === c && b.charAt(b.length - 1) === c),
        )
        b = b.substr(1, b.length - 2)
        e && (b = unescape(encodeURIComponent(b)))
        4 <= b.length &&
          b.charAt(0) === c &&
          b.charAt(1) === c &&
          (self.Sk.asserts.assert(
            b.charAt(b.length - 1) === c && b.charAt(b.length - 2) === c,
          ),
          (b = b.substr(2, b.length - 4)))
        if (d || -1 === b.indexOf("\\")) a = f(decodeURIComponent(escape(b)))
        else {
          a = b
          c = a.length
          d = ""
          for (b = 0; b < c; ++b)
            if (((e = a.charAt(b)), "\\" === e))
              if ((++b, (e = a.charAt(b)), "n" === e)) d += "\n"
              else if ("\\" === e) d += "\\"
              else if ("t" === e) d += "\t"
              else if ("r" === e) d += "\r"
              else if ("b" === e) d += "\b"
              else if ("f" === e) d += "\f"
              else if ("v" === e) d += "\v"
              else if ("0" === e) d += "\x00"
              else if ('"' === e) d += '"'
              else if ("'" === e) d += "'"
              else {
                if ("\n" !== e)
                  if ("x" === e) {
                    var k = a.charAt(++b)
                    var g = a.charAt(++b)
                    d += unescape(
                      encodeURIComponent(
                        String.fromCharCode(parseInt(k + g, 16)),
                      ),
                    )
                  } else if ("u" === e || "U" === e) {
                    k = a.charAt(++b)
                    g = a.charAt(++b)
                    var l = a.charAt(++b)
                    e = a.charAt(++b)
                    d += unescape(
                      encodeURIComponent(
                        String.fromCharCode(
                          parseInt(k + g, 16),
                          parseInt(l + e, 16),
                        ),
                      ),
                    )
                  } else d += "\\" + e
              }
            else d += e
          a = decodeURIComponent(escape(d))
          a = f(a)
        }
        return a
      }
      function U(a, b, c) {
        a = b.charAt(b.length - 1)
        if ("j" === a || "J" === a)
          return self.Sk.builtin.complex.complex_subtype_from_string(b)
        if ("l" === a || "L" === a)
          return self.Sk.longFromStr(b.substr(0, b.length - 1), 0)
        if (-1 !== b.indexOf(".")) return new self.Sk.builtin.float_(parseFloat(b))
        c = b
        a = !1
        "-" === b.charAt(0) && ((c = b.substr(1)), (a = !0))
        if (
          "0" !== c.charAt(0) ||
          ("x" !== c.charAt(1) && "X" !== c.charAt(1))
        ) {
          if (-1 !== b.indexOf("e") || -1 !== b.indexOf("E"))
            return new self.Sk.builtin.float_(parseFloat(b))
          if (
            "0" !== c.charAt(0) ||
            ("b" !== c.charAt(1) && "B" !== c.charAt(1))
          )
            if ("0" === c.charAt(0))
              if ("0" === c) c = 0
              else {
                c = c.substring(1)
                if ("o" === c.charAt(0) || "O" === c.charAt(0))
                  c = c.substring(1)
                c = parseInt(c, 8)
              }
            else c = parseInt(c, 10)
          else (c = c.substring(2)), (c = parseInt(c, 2))
        } else (c = c.substring(2)), (c = parseInt(c, 16))
        return c > self.Sk.builtin.int_.threshold$ &&
          Math.floor(c) === c &&
          -1 === b.indexOf("e") &&
          -1 === b.indexOf("E")
          ? self.Sk.longFromStr(b, 0)
          : a
          ? new self.Sk.builtin.int_(-c)
          : new self.Sk.builtin.int_(c)
      }
      function F(a, e) {
        var k, g
        d(e, t.subscript)
        var f = c(e, 0)
        var l = (k = g = null)
        if (f.type === v.T_DOT) return new self.Sk.astnodes.Ellipsis()
        if (1 === b(e) && f.type === t.test)
          return new self.Sk.astnodes.Index(u(a, f))
        f.type === t.test && (g = u(a, f))
        f.type === v.T_COLON
          ? 1 < b(e) && ((f = c(e, 1)), f.type === t.test && (k = u(a, f)))
          : 2 < b(e) && ((f = c(e, 2)), f.type === t.test && (k = u(a, f)))
        f = c(e, b(e) - 1)
        f.type === t.sliceop &&
          (1 === b(f)
            ? ((f = c(f, 0)),
              (l = new self.Sk.astnodes.NameConstant(
                self.Sk.builtin.none.none$,
                self.Sk.astnodes.Load,
                f.lineno,
                f.col_offset,
              )))
            : ((f = c(f, 1)), f.type === t.test && (l = u(a, f))))
        return new self.Sk.astnodes.Slice(g, k, l)
      }
      function Q(a, k) {
        var g = c(k, 0)
        switch (g.type) {
          case v.T_NAME:
            g = g.value
            if (4 <= g.length && 5 >= g.length) {
              if ("None" === g)
                return new self.Sk.astnodes.NameConstant(
                  self.Sk.builtin.none.none$,
                  k.lineno,
                  k.col_offset,
                )
              if ("True" === g)
                return new self.Sk.astnodes.NameConstant(
                  self.Sk.builtin.bool.true$,
                  k.lineno,
                  k.col_offset,
                )
              if ("False" === g)
                return new self.Sk.astnodes.NameConstant(
                  self.Sk.builtin.bool.false$,
                  k.lineno,
                  k.col_offset,
                )
            }
            a = r(g, a)
            return new self.Sk.astnodes.Name(
              a,
              self.Sk.astnodes.Load,
              k.lineno,
              k.col_offset,
              k.end_lineno,
              k.end_col_offset,
            )
          case v.T_STRING:
            d(c(k, 0), v.T_STRING)
            var f = new self.Sk.builtin.str("")
            for (g = 0; g < b(k); ++g)
              try {
                f = f.sq$concat(N(a, c(k, g).value))
              } catch (ca) {
                throw new self.Sk.builtin.SyntaxError(
                  "invalid string (possibly contains a unicode character)",
                  a.c_filename,
                  c(k, g).lineno,
                )
              }
            return new self.Sk.astnodes.Str(
              f,
              k.lineno,
              k.col_offset,
              a.end_lineno,
              k.end_col_offset,
            )
          case v.T_NUMBER:
            return new self.Sk.astnodes.Num(
              U(a, g.value, k.lineno),
              k.lineno,
              k.col_offset,
            )
          case v.T_ELLIPSIS:
            return new self.Sk.astnodes.Ellipsis(
              k.lineno,
              k.col_offset,
              k.end_lineno,
              k.end_col_offset,
            )
          case v.T_LPAR:
            return (
              (g = c(k, 1)),
              g.type == v.T_RPAR
                ? new self.Sk.astnodes.Tuple(
                    [],
                    self.Sk.astnodes.Load,
                    k.lineno,
                    k.col_offset,
                    k.end_lineno,
                    k.end_col_offset,
                  )
                : g.type == t.yield_expr
                ? u(a, g)
                : 1 == b(g)
                ? I(a, g)
                : c(g, 1).type == t.comp_for
                ? q(A(a, g), k)
                : q(I(a, g), k)
            )
          case v.T_LSQB:
            g = c(k, 1)
            if (g.type == v.T_RSQB)
              return new self.Sk.astnodes.List(
                [],
                self.Sk.astnodes.Load,
                k.lineno,
                k.col_offset,
                k.end_lineno,
                k.end_col_offset,
              )
            d(g, t.testlist_comp)
            if (1 == b(g) || c(g, 1).type == v.T_COMMA)
              return (a = D(a, g))
                ? new self.Sk.astnodes.List(
                    a,
                    self.Sk.astnodes.Load,
                    k.lineno,
                    k.col_offset,
                    k.end_lineno,
                    k.end_col_offset,
                  )
                : null
            self.Sk.asserts.assert(g.type == t.testlist_comp)
            a = Z(a, g, 1)
            return q(a, k)
          case v.T_LBRACE:
            g = c(k, 1)
            if (g.type == v.T_RBRACE)
              return new self.Sk.astnodes.Dict(
                null,
                null,
                k.lineno,
                k.col_offset,
                k.end_lineno,
                k.end_col_offset,
              )
            f = c(g, 0).type == v.T_DOUBLESTAR
            if (1 == b(g) || (1 < b(g) && c(g, 1).type == v.T_COMMA)) {
              var l = []
              self.Sk.asserts.assert(g.type === t.dictorsetmaker)
              for (f = 0; f < b(g); f += 2) {
                var h = u(a, c(g, f))
                l[f / 2] = h
              }
              a = new self.Sk.astnodes.Set(l, g.lineno, g.col_offset)
            } else if (1 < b(g) && c(g, 1).type == t.comp_for)
              self.Sk.asserts.assert(g.type === t.dictorsetmaker),
                self.Sk.asserts.assert(1 < b(g)),
                (f = u(a, c(g, 0))),
                (a = Y(a, c(g, 1))),
                (a = new self.Sk.astnodes.SetComp(f, a, g.lineno, g.col_offset))
            else if (b(g) > 3 - f && c(g, 3 - f).type == t.comp_for) {
              if (f)
                return (
                  e(
                    a,
                    k,
                    "dict unpacking cannot be used in dict comprehension",
                  ),
                  null
                )
              self.Sk.asserts.assert(3 < b(g))
              d(c(g, 1), v.T_COLON)
              f = u(a, c(g, 0))
              l = u(a, c(g, 2))
              a = Y(a, c(g, 3))
              a = new self.Sk.astnodes.DictComp(f, l, a, g.lineno, g.col_offset)
            } else {
              var n
              l = []
              h = []
              for (n = f = 0; n < b(g); n++) {
                var m = a
                var w = g,
                  p = n
                if (c(w, p).type == v.T_DOUBLESTAR)
                  self.Sk.asserts.assert(2 <= b(w) - p),
                    (n = u(m, c(w, p + 1))),
                    (m = { key: null, value: n, i: p + 2 })
                else if (
                  (self.Sk.asserts.assert(3 <= b(w) - p), (n = u(m, c(w, p))))
                ) {
                  var x = n
                  d(c(w, p + 1), v.T_COLON)
                  m = (n = u(m, c(w, p + 2)))
                    ? { key: x, value: n, i: p + 3 }
                    : !1
                } else m = 0
                n = m.i
                l[f] = m.key
                h[f] = m.value
                f++
              }
              a = new self.Sk.astnodes.Dict(
                l,
                h,
                g.lineno,
                g.col_offset,
                g.end_lineno,
                g.end_col_offset,
              )
            }
            return q(a, k)
          default:
            return self.Sk.assert.fail("unhandled atom " + g.type), null
        }
      }
      function y(a, e) {
        var k,
          g = 0
        d(e, t.atom_expr)
        var f = b(e)
        c(e, 0).type === v.T_AWAIT && ((g = 1), self.Sk.asserts.assert(1 < f))
        var l = Q(a, c(e, g))
        if (!l) return null
        if (1 === f) return l
        if (g && 2 === f)
          return new self.Sk.astnodes.Await(l, e.lineno, e.col_offset)
        for (k = g + 1; k < f; k++) {
          var h = c(e, k)
          if (h.type !== t.trailer) break
          h = B(a, h, l)
          if (!h) return null
          h.lineno = l.lineno
          h.col_offset = l.col_offset
          l = h
        }
        return g ? new self.Sk.astnodes.Await(l, e.line, e.col_offset) : l
      }
      function u(a, e) {
        a: for (;;) {
          switch (e.type) {
            case t.test:
            case t.test_nocond:
              if (
                c(e, 0).type === t.lambdef ||
                c(e, 0).type === t.lambdef_nocond
              ) {
                var k = c(e, 0)
                3 === b(k)
                  ? ((e = new self.Sk.astnodes.arguments_([], null, null, [])),
                    (a = u(a, c(k, 2))))
                  : ((e = P(a, c(k, 1))), (a = u(a, c(k, 3))))
                return new self.Sk.astnodes.Lambda(e, a, k.lineno, k.col_offset)
              }
              if (1 < b(e))
                return (
                  self.Sk.asserts.assert(5 === b(e)),
                  new self.Sk.astnodes.IfExp(
                    u(a, c(e, 2)),
                    u(a, c(e, 0)),
                    u(a, c(e, 4)),
                    e.lineno,
                    e.col_offset,
                  )
                )
            case t.or_test:
            case t.and_test:
              if (1 === b(e)) {
                e = c(e, 0)
                continue a
              }
              var g = []
              for (k = 0; k < b(e); k += 2) g[k / 2] = u(a, c(e, k))
              if ("and" === c(e, 1).value)
                return new self.Sk.astnodes.BoolOp(
                  self.Sk.astnodes.And,
                  g,
                  e.lineno,
                  e.col_offset,
                )
              self.Sk.asserts.assert("or" === c(e, 1).value)
              return new self.Sk.astnodes.BoolOp(
                self.Sk.astnodes.Or,
                g,
                e.lineno,
                e.col_offset,
              )
            case t.not_test:
              if (1 === b(e)) {
                e = c(e, 0)
                continue a
              } else
                return new self.Sk.astnodes.UnaryOp(
                  self.Sk.astnodes.Not,
                  u(a, c(e, 1)),
                  e.lineno,
                  e.col_offset,
                )
            case t.comparison:
              if (1 === b(e)) {
                e = c(e, 0)
                continue a
              } else {
                var f = []
                g = []
                for (k = 1; k < b(e); k += 2)
                  (f[(k - 1) / 2] = n(a, c(e, k))),
                    (g[(k - 1) / 2] = u(a, c(e, k + 1)))
                return new self.Sk.astnodes.Compare(
                  u(a, c(e, 0)),
                  f,
                  g,
                  e.lineno,
                  e.col_offset,
                )
              }
            case t.star_expr:
              return (
                d(e, t.star_expr),
                new self.Sk.astnodes.Starred(
                  u(a, c(e, 1)),
                  self.Sk.astnodes.Load,
                  e.lineno,
                  e.col_offset,
                )
              )
            case t.expr:
            case t.xor_expr:
            case t.and_expr:
            case t.shift_expr:
            case t.arith_expr:
            case t.term:
              if (1 === b(e)) {
                e = c(e, 0)
                continue a
              }
              var h = e,
                r = new self.Sk.astnodes.BinOp(
                  u(a, c(h, 0)),
                  l(c(h, 1)),
                  u(a, c(h, 2)),
                  h.lineno,
                  h.col_offset,
                ),
                q = (b(h) - 1) / 2
              for (e = 1; e < q; ++e)
                (k = c(h, 2 * e + 1)),
                  (g = l(k)),
                  (f = u(a, c(h, 2 * e + 2))),
                  (r = new self.Sk.astnodes.BinOp(r, g, f, k.lineno, k.col_offset))
              return r
            case t.yield_expr:
              return (
                (g = !1),
                (f = null),
                1 < b(e) && (k = c(e, 1)),
                k &&
                  ((f = c(k, b(k) - 1)),
                  2 == b(k) ? ((g = !0), (f = u(a, f))) : (f = I(a, f))),
                g
                  ? new self.Sk.astnodes.YieldFrom(f, e.lineno, e.col_offset)
                  : new self.Sk.astnodes.Yield(f, e.lineno, e.col_offset)
              )
            case t.factor:
              if (1 === b(e)) {
                e = c(e, 0)
                continue a
              }
              return C(a, e)
            case t.power:
              return (
                (k = e),
                d(k, t.power),
                (e = y(a, c(k, 0))),
                1 !== b(k) &&
                  c(k, b(k) - 1).type === t.factor &&
                  ((a = u(a, c(k, b(k) - 1))),
                  (e = new self.Sk.astnodes.BinOp(
                    e,
                    self.Sk.astnodes.Pow,
                    a,
                    k.lineno,
                    k.col_offset,
                  ))),
                e
              )
            default:
              self.Sk.asserts.fail("unhandled expr", "n.type: %d", e.type)
          }
          break
        }
      }
      function L(a, l) {
        l.type === t.stmt && (self.Sk.asserts.assert(1 === b(l)), (l = c(l, 0)))
        l.type === t.simple_stmt &&
          (self.Sk.asserts.assert(1 === g(l)), (l = c(l, 0)))
        if (l.type === t.small_stmt)
          switch (((l = c(l, 0)), l.type)) {
            case t.expr_stmt:
              return E(a, l)
            case t.del_stmt:
              var h = l
              d(h, t.del_stmt)
              return new self.Sk.astnodes.Delete(
                H(a, c(h, 1), self.Sk.astnodes.Del),
                h.lineno,
                h.col_offset,
              )
            case t.pass_stmt:
              return new self.Sk.astnodes.Pass(l.lineno, l.col_offset)
            case t.flow_stmt:
              return S(a, l)
            case t.import_stmt:
              var n = l,
                r
              d(n, t.import_stmt)
              var q = n.lineno
              l = n.col_offset
              n = c(n, 0)
              if (n.type === t.import_name) {
                n = c(n, 1)
                d(n, t.dotted_as_names)
                var m = []
                for (r = 0; r < b(n); r += 2) m[r / 2] = J(a, c(n, r))
                a = new self.Sk.astnodes.Import(m, q, l)
              } else if (n.type === t.import_from) {
                var p = null
                h = 0
                for (m = 1; m < b(n); ++m)
                  if (c(n, m).type === t.dotted_name) {
                    p = J(a, c(n, m))
                    m++
                    break
                  } else if (c(n, m).type === v.T_DOT) h++
                  else if (c(n, m).type === v.T_ELLIPSIS) h += 3
                  else break
                ++m
                switch (c(n, m).type) {
                  case v.T_STAR:
                    n = c(n, m)
                    break
                  case v.T_LPAR:
                    n = c(n, m + 1)
                    b(n)
                    break
                  case t.import_as_names:
                    n = c(n, m)
                    m = b(n)
                    if (0 === m % 2)
                      throw new self.Sk.builtin.SyntaxError(
                        "trailing comma not allowed without surrounding parentheses",
                        a.c_filename,
                        n.lineno,
                      )
                    break
                  default:
                    throw new self.Sk.builtin.SyntaxError(
                      "Unexpected node-type in from-import",
                      a.c_filename,
                      n.lineno,
                    )
                }
                m = []
                if (n.type === v.T_STAR) m[0] = J(a, n)
                else for (r = 0; r < b(n); r += 2) m[r / 2] = J(a, c(n, r))
                a = p ? p.name.v : ""
                a = new self.Sk.astnodes.ImportFrom(f(a), m, h, q, l)
              } else
                throw new self.Sk.builtin.SyntaxError(
                  "unknown import statement",
                  a.c_filename,
                  n.lineno,
                )
              return a
            case t.global_stmt:
              a = l
              l = []
              d(a, t.global_stmt)
              for (h = 1; h < b(a); h += 2) l[(h - 1) / 2] = f(c(a, h).value)
              return new self.Sk.astnodes.Global(l, a.lineno, a.col_offset)
            case t.nonlocal_stmt:
              e(a, l, "Not implemented: nonlocal")
              break
            case t.assert_stmt:
              return (
                (h = l),
                d(h, t.assert_stmt),
                2 === b(h)
                  ? (a = new self.Sk.astnodes.Assert(
                      u(a, c(h, 1)),
                      null,
                      h.lineno,
                      h.col_offset,
                    ))
                  : 4 === b(h)
                  ? (a = new self.Sk.astnodes.Assert(
                      u(a, c(h, 1)),
                      u(a, c(h, 3)),
                      h.lineno,
                      h.col_offset,
                    ))
                  : (self.Sk.asserts.fail("improper number of parts to assert stmt"),
                    (a = void 0)),
                a
              )
            case t.print_stmt:
              h = l
              self.Sk.__future__.print_function &&
                e(a, h, "Missing parentheses in call to 'print'")
              n = 1
              q = null
              d(h, t.print_stmt)
              2 <= b(h) &&
                c(h, 1).type === v.T_RIGHTSHIFT &&
                ((q = u(a, c(h, 2))), (n = 4))
              l = []
              for (p = 0; n < b(h); n += 2, ++p) l[p] = u(a, c(h, n))
              a = c(h, b(h) - 1).type === v.T_COMMA ? !1 : !0
              return new self.Sk.astnodes.Print(q, l, a, h.lineno, h.col_offset)
            case t.debugger_stmt:
              return new self.Sk.astnodes.Debugger(l.lineno, l.col_offset)
            default:
              self.Sk.asserts.fail("unhandled small_stmt")
          }
        else
          switch (((h = c(l, 0)), d(l, t.compound_stmt), h.type)) {
            case t.if_stmt:
              d(h, t.if_stmt)
              if (4 === b(h))
                a = new self.Sk.astnodes.If(
                  u(a, c(h, 1)),
                  x(a, c(h, 3)),
                  [],
                  h.lineno,
                  h.col_offset,
                )
              else if (((l = c(h, 4).value.charAt(2)), "s" === l))
                a = new self.Sk.astnodes.If(
                  u(a, c(h, 1)),
                  x(a, c(h, 3)),
                  x(a, c(h, 6)),
                  h.lineno,
                  h.col_offset,
                )
              else if ("i" === l) {
                q = b(h) - 4
                n = !1
                l = []
                c(h, q + 1).type === v.T_NAME &&
                  "s" === c(h, q + 1).value.charAt(2) &&
                  ((n = !0), (q -= 3))
                q /= 4
                n &&
                  ((l = [
                    new self.Sk.astnodes.If(
                      u(a, c(h, b(h) - 6)),
                      x(a, c(h, b(h) - 4)),
                      x(a, c(h, b(h) - 1)),
                      c(h, b(h) - 6).lineno,
                      c(h, b(h) - 6).col_offset,
                    ),
                  ]),
                  q--)
                for (p = 0; p < q; ++p)
                  (n = 5 + 4 * (q - p - 1)),
                    (l = [
                      new self.Sk.astnodes.If(
                        u(a, c(h, n)),
                        x(a, c(h, n + 2)),
                        l,
                        c(h, n).lineno,
                        c(h, n).col_offset,
                      ),
                    ])
                a = new self.Sk.astnodes.If(
                  u(a, c(h, 1)),
                  x(a, c(h, 3)),
                  l,
                  h.lineno,
                  h.col_offset,
                )
              } else
                self.Sk.asserts.fail("unexpected token in 'if' statement"),
                  (a = void 0)
              return a
            case t.while_stmt:
              return (
                d(h, t.while_stmt),
                4 === b(h)
                  ? (a = new self.Sk.astnodes.While(
                      u(a, c(h, 1)),
                      x(a, c(h, 3)),
                      [],
                      h.lineno,
                      h.col_offset,
                    ))
                  : 7 === b(h)
                  ? (a = new self.Sk.astnodes.While(
                      u(a, c(h, 1)),
                      x(a, c(h, 3)),
                      x(a, c(h, 6)),
                      h.lineno,
                      h.col_offset,
                    ))
                  : (self.Sk.asserts.fail("wrong number of tokens for 'while' stmt"),
                    (a = void 0)),
                a
              )
            case t.for_stmt:
              return (
                (l = []),
                d(h, t.for_stmt),
                9 === b(h) && (l = x(a, c(h, 8))),
                (n = c(h, 1)),
                (q = H(a, n, self.Sk.astnodes.Store)),
                (q =
                  1 === b(n)
                    ? q[0]
                    : new self.Sk.astnodes.Tuple(
                        q,
                        self.Sk.astnodes.Store,
                        h.lineno,
                        h.col_offset,
                      )),
                new self.Sk.astnodes.For(
                  q,
                  I(a, c(h, 3)),
                  x(a, c(h, 5)),
                  l,
                  h.lineno,
                  h.col_offset,
                )
              )
            case t.try_stmt:
              l = []
              r = b(h)
              q = (r - 3) / 3
              p = []
              m = null
              d(h, t.try_stmt)
              n = x(a, c(h, 2))
              if (c(h, r - 3).type === v.T_NAME)
                "finally" === c(h, r - 3).value
                  ? (9 <= r &&
                      c(h, r - 6).type === v.T_NAME &&
                      ((p = x(a, c(h, r - 4))), q--),
                    (m = x(a, c(h, r - 1))))
                  : (p = x(a, c(h, r - 1))),
                  q--
              else if (c(h, r - 3).type !== t.except_clause)
                throw new self.Sk.builtin.SyntaxError(
                  "malformed 'try' statement",
                  a.c_filename,
                  h.lineno,
                )
              if (0 < q)
                for (r = 0; r < q; r++) {
                  var D = r
                  var A = a,
                    w = c(h, 3 + 3 * r),
                    B = c(h, 5 + 3 * r)
                  d(w, t.except_clause)
                  d(B, t.suite)
                  if (1 === b(w))
                    var C = new self.Sk.astnodes.ExceptHandler(
                      null,
                      null,
                      x(A, B),
                      w.lineno,
                      w.col_offset,
                    )
                  else
                    2 === b(w)
                      ? (C = new self.Sk.astnodes.ExceptHandler(
                          u(A, c(w, 1)),
                          null,
                          x(A, B),
                          w.lineno,
                          w.col_offset,
                        ))
                      : 4 === b(w)
                      ? (self.Sk.__future__.python3 &&
                          "," == c(w, 2).value &&
                          e(
                            A,
                            w,
                            "Old-style 'except' clauses are not supported in Python 3",
                          ),
                        u(A, c(w, 1)),
                        (C = u(A, c(w, 3))),
                        k(A, C, self.Sk.astnodes.Store, c(w, 3)),
                        (C = new self.Sk.astnodes.ExceptHandler(
                          u(A, c(w, 1)),
                          C,
                          x(A, B),
                          w.lineno,
                          w.col_offset,
                        )))
                      : (self.Sk.asserts.fail(
                          "wrong number of children for except clause",
                        ),
                        (C = void 0))
                  l[D] = C
                }
              self.Sk.asserts.assert(!!m || 0 != l.length)
              return new self.Sk.astnodes.Try(n, l, p, m, h.lineno, h.col_offset)
            case t.with_stmt:
              l = []
              d(h, t.with_stmt)
              for (q = 1; q < b(h) - 2; q += 2)
                (n = void 0),
                  (m = a),
                  (r = c(h, q)),
                  d(r, t.with_item),
                  (p = u(m, c(r, 0))),
                  3 == b(r) &&
                    ((n = u(m, c(r, 2))), k(m, n, self.Sk.astnodes.Store, r)),
                  (n = new self.Sk.astnodes.withitem(p, n)),
                  (l[(q - 1) / 2] = n)
              a = x(a, c(h, b(h) - 1))
              a = new self.Sk.astnodes.With(l, a, h.lineno, h.col_offset)
              return a
            case t.funcdef:
              return V(a, h, [], !1)
            case t.classdef:
              return X(a, h, [])
            case t.decorated:
              q = null
              d(h, t.decorated)
              n = c(h, 0)
              d(n, t.decorators)
              l = []
              for (p = 0; p < b(n); ++p) {
                m = l
                r = p
                D = a
                C = c(n, p)
                d(C, t.decorator)
                d(c(C, 0), v.T_AT)
                d(c(C, b(C) - 1), v.T_NEWLINE)
                var y,
                  z = c(C, 1)
                d(z, t.dotted_name)
                A = z.lineno
                w = z.col_offset
                B = f(c(z, 0).value)
                var G = new self.Sk.astnodes.Name(B, self.Sk.astnodes.Load, A, w)
                for (y = 2; y < b(z); y += 2)
                  (B = f(c(z, y).value)),
                    (G = new self.Sk.astnodes.Attribute(
                      G,
                      B,
                      self.Sk.astnodes.Load,
                      A,
                      w,
                    ))
                A = G
                D =
                  3 === b(C)
                    ? A
                    : 5 === b(C)
                    ? new self.Sk.astnodes.Call(
                        A,
                        [],
                        [],
                        null,
                        null,
                        C.lineno,
                        C.col_offset,
                      )
                    : K(D, c(C, 3), A)
                m[r] = D
              }
              self.Sk.asserts.assert(
                c(h, 1).type == t.funcdef ||
                  c(h, 1).type == t.async_funcdef ||
                  c(h, 1).type == t.classdef,
              )
              c(h, 1).type == t.funcdef
                ? ((q = c(h, 1)), (q = V(a, q, l, !1)))
                : c(h, 1).type == t.classdef
                ? (q = X(a, c(h, 1), l))
                : c(h, 1).type == t.async_funcdef &&
                  ((q = c(h, 1)),
                  d(q, t.async_funcdef),
                  d(c(q, 0), v.T_NAME),
                  self.Sk.asserts.assert(("async" === c(q, 0)).value),
                  d(c(q, 1), t.funcdef),
                  (q = V(a, q, l, !0)))
              q && ((q.lineno = h.lineno), (q.col_offset = h.col_offset))
              return q
            case t.async_stmt:
              e(a, h, "Not implemented: async")
              break
            default:
              self.Sk.asserts.assert("unhandled compound_stmt")
          }
      }
      var t = self.Sk.ParseTables.sym,
        v = self.Sk.token.tokens,
        W = { Slice_kind: 1, ExtSlice_kind: 2, Index_kind: 3 },
        M = {}
      M[v.T_VBAR] = self.Sk.astnodes.BitOr
      M[v.T_CIRCUMFLEX] = self.Sk.astnodes.BitXor
      M[v.T_AMPER] = self.Sk.astnodes.BitAnd
      M[v.T_LEFTSHIFT] = self.Sk.astnodes.LShift
      M[v.T_RIGHTSHIFT] = self.Sk.astnodes.RShift
      M[v.T_PLUS] = self.Sk.astnodes.Add
      M[v.T_MINUS] = self.Sk.astnodes.Sub
      M[v.T_STAR] = self.Sk.astnodes.Mult
      M[v.T_SLASH] = self.Sk.astnodes.Div
      M[v.T_DOUBLESLASH] = self.Sk.astnodes.FloorDiv
      M[v.T_PERCENT] = self.Sk.astnodes.Mod
      self.Sk.setupOperators = function(a) {
        a ? (M[v.T_AT] = self.Sk.astnodes.MatMult) : M[v.T_AT] && delete M[v.T_AT]
      }
      self.Sk.exportSymbol("Sk.setupOperators", self.Sk.setupOperators)
      self.Sk.astFromParse = function(e, k, f) {
        var l,
          h = new a("utf-8", k, f),
          n = [],
          r = 0
        switch (e.type) {
          case t.file_input:
            for (l = 0; l < b(e) - 1; ++l) {
              var q = c(e, l)
              if (e.type !== v.T_NEWLINE)
                if ((d(q, t.stmt), (f = g(q)), 1 === f)) n[r++] = L(h, q)
                else
                  for (q = c(q, 0), d(q, t.simple_stmt), k = 0; k < f; ++k)
                    n[r++] = L(h, c(q, 2 * k))
            }
            return new self.Sk.astnodes.Module(n)
          case t.eval_input:
            self.Sk.asserts.fail("todo;")
          case t.single_input:
            self.Sk.asserts.fail("todo;")
          default:
            self.Sk.asserts.fail("todo;")
        }
      }
      self.Sk.astDump = function(a) {
        var b = function(a) {
            var b,
              c = ""
            for (b = 0; b < a; ++b) c += " "
            return c
          },
          c = function(a, d) {
            var e
            if (null === a) return d + "None"
            if (
              a.prototype &&
              void 0 !== a.prototype._astname &&
              a.prototype._isenum
            )
              return d + a.prototype._astname + "()"
            if (void 0 !== a._astname) {
              var k = b(a._astname.length + 1)
              var g = []
              for (e = 0; e < a._fields.length; e += 2) {
                var f = a._fields[e]
                var l = a._fields[e + 1](a)
                var h = b(f.length + 1)
                g.push([f, c(l, d + k + h)])
              }
              l = []
              for (e = 0; e < g.length; ++e)
                (h = g[e]), l.push(h[0] + "=" + h[1].replace(/^\s+/, ""))
              e = l.join(",\n" + d + k)
              return d + a._astname + "(" + e + ")"
            }
            if (self.Sk.isArrayLike(a)) {
              k = []
              for (e = 0; e < a.length; ++e) (g = a[e]), k.push(c(g, d + " "))
              a = k.join(",\n")
              return d + "[" + a.replace(/^\s+/, "") + "]"
            }
            a =
              !0 === a
                ? "True"
                : !1 === a
                ? "False"
                : a instanceof self.Sk.builtin.lng
                ? a.tp$str().v
                : a instanceof self.Sk.builtin.str
                ? a.$r().v
                : "" + a
            return d + a
          }
        return c(a, "")
      }
      self.Sk.exportSymbol("Sk.astFromParse", self.Sk.astFromParse)
      self.Sk.exportSymbol("Sk.astDump", self.Sk.astDump)
    },
    function(m, p) {
      function a(a, b, c) {
        this.__name = a
        this.__flags = b
        this.__scope = (b >> 11) & 7
        this.__namespaces = c || []
      }
      function b(a, b, c, d, e) {
        this.symFlags = {}
        this.name = b
        this.varnames = []
        this.children = []
        this.blockType = c
        this.returnsValue = this.varkeywords = this.varargs = this.generator = this.childHasFree = this.hasFree = this.isNested = !1
        this.lineno = e
        this.table = a
        a.cur &&
          (a.cur.nested || "function" === a.cur.blockType) &&
          (this.isNested = !0)
        d.scopeId = f++
        a.stss[d.scopeId] = this
        this.symbols = {}
      }
      function c(a) {
        this.filename = a
        this.top = this.cur = null
        this.stack = []
        this.curClass = this.global = null
        this.tmpname = 0
        this.stss = {}
      }
      function d(a, b) {
        var c
        for (c = 0; c < b.length; c++) a(b[c])
      }
      function e(a, b) {
        for (var c in b) a[c] = b[c]
      }
      self.Sk.exportSymbol("Sk.SYMTAB_CONSTS", {
        DEF_GLOBAL: 1,
        DEF_LOCAL: 2,
        DEF_PARAM: 4,
        USE: 8,
        DEF_STAR: 16,
        DEF_DOUBLESTAR: 32,
        DEF_INTUPLE: 64,
        DEF_FREE: 128,
        DEF_FREE_GLOBAL: 256,
        DEF_FREE_CLASS: 512,
        DEF_IMPORT: 1024,
        DEF_BOUND: 1030,
        SCOPE_OFF: 11,
        SCOPE_MASK: 7,
        LOCAL: 1,
        GLOBAL_EXPLICIT: 2,
        GLOBAL_IMPLICIT: 3,
        FREE: 4,
        CELL: 5,
        OPT_IMPORT_STAR: 1,
        OPT_EXEC: 2,
        OPT_BARE_EXEC: 4,
        OPT_TOPLEVEL: 8,
        GENERATOR: 2,
        GENERATOR_EXPRESSION: 2,
        ModuleBlock: "module",
        FunctionBlock: "function",
        ClassBlock: "class",
      })
      a.prototype.get_name = function() {
        return this.__name
      }
      a.prototype.is_referenced = function() {
        return !!(this.__flags & 8)
      }
      a.prototype.is_parameter = function() {
        return !!(this.__flags & 4)
      }
      a.prototype.is_global = function() {
        return 3 === this.__scope || 2 == this.__scope
      }
      a.prototype.is_declared_global = function() {
        return 2 == this.__scope
      }
      a.prototype.is_local = function() {
        return !!(this.__flags & 1030)
      }
      a.prototype.is_free = function() {
        return 4 == this.__scope
      }
      a.prototype.is_imported = function() {
        return !!(this.__flags & 1024)
      }
      a.prototype.is_assigned = function() {
        return !!(this.__flags & 2)
      }
      a.prototype.is_namespace = function() {
        return this.__namespaces && 0 < this.__namespaces.length
      }
      a.prototype.get_namespaces = function() {
        return this.__namespaces
      }
      var f = 0
      b.prototype.get_type = function() {
        return this.blockType
      }
      b.prototype.get_name = function() {
        return this.name
      }
      b.prototype.get_lineno = function() {
        return this.lineno
      }
      b.prototype.is_nested = function() {
        return this.isNested
      }
      b.prototype.has_children = function() {
        return 0 < this.children.length
      }
      b.prototype.get_identifiers = function() {
        return this._identsMatching(function() {
          return !0
        })
      }
      b.prototype.lookup = function(b) {
        if (this.symbols.hasOwnProperty(b)) b = this.symbols[b]
        else {
          var c = this.symFlags[b]
          var d = this.__check_children(b)
          b = this.symbols[b] = new a(b, c, d)
        }
        return b
      }
      b.prototype.__check_children = function(a) {
        var b,
          c = []
        for (b = 0; b < this.children.length; ++b) {
          var d = this.children[b]
          d.name === a && c.push(d)
        }
        return c
      }
      b.prototype._identsMatching = function(a) {
        var b,
          c = []
        for (b in this.symFlags)
          this.symFlags.hasOwnProperty(b) && a(this.symFlags[b]) && c.push(b)
        c.sort()
        return c
      }
      b.prototype.get_parameters = function() {
        self.Sk.asserts.assert(
          "function" == this.get_type(),
          "get_parameters only valid for function scopes",
        )
        this._funcParams ||
          (this._funcParams = this._identsMatching(function(a) {
            return a & 4
          }))
        return this._funcParams
      }
      b.prototype.get_locals = function() {
        self.Sk.asserts.assert(
          "function" == this.get_type(),
          "get_locals only valid for function scopes",
        )
        this._funcLocals ||
          (this._funcLocals = this._identsMatching(function(a) {
            return a & 1030
          }))
        return this._funcLocals
      }
      b.prototype.get_globals = function() {
        self.Sk.asserts.assert(
          "function" == this.get_type(),
          "get_globals only valid for function scopes",
        )
        this._funcGlobals ||
          (this._funcGlobals = this._identsMatching(function(a) {
            a = (a >> 11) & 7
            return 3 == a || 2 == a
          }))
        return this._funcGlobals
      }
      b.prototype.get_frees = function() {
        self.Sk.asserts.assert(
          "function" == this.get_type(),
          "get_frees only valid for function scopes",
        )
        this._funcFrees ||
          (this._funcFrees = this._identsMatching(function(a) {
            return 4 == ((a >> 11) & 7)
          }))
        return this._funcFrees
      }
      b.prototype.get_methods = function() {
        var a
        self.Sk.asserts.assert(
          "class" == this.get_type(),
          "get_methods only valid for class scopes",
        )
        if (!this._classMethods) {
          var b = []
          for (a = 0; a < this.children.length; ++a)
            b.push(this.children[a].name)
          b.sort()
          this._classMethods = b
        }
        return this._classMethods
      }
      b.prototype.getScope = function(a) {
        a = this.symFlags[a]
        return void 0 === a ? 0 : (a >> 11) & 7
      }
      c.prototype.getStsForAst = function(a) {
        self.Sk.asserts.assert(void 0 !== a.scopeId, "ast wasn't added to st?")
        a = this.stss[a.scopeId]
        self.Sk.asserts.assert(void 0 !== a, "unknown sym tab entry")
        return a
      }
      c.prototype.SEQStmt = function(a) {
        var b, c
        if (null !== a) {
          self.Sk.asserts.assert(
            self.Sk.isArrayLike(a),
            "SEQ: nodes isn't array? got " + a.toString(),
          )
          var d = a.length
          for (c = 0; c < d; ++c) (b = a[c]) && this.visitStmt(b)
        }
      }
      c.prototype.SEQExpr = function(a) {
        var b, c
        if (null !== a) {
          self.Sk.asserts.assert(
            self.Sk.isArrayLike(a),
            "SEQ: nodes isn't array? got " + a.toString(),
          )
          var d = a.length
          for (c = 0; c < d; ++c) (b = a[c]) && this.visitExpr(b)
        }
      }
      c.prototype.enterBlock = function(a, c, d, e) {
        a = self.Sk.fixReservedNames(a)
        var k = null
        this.cur && ((k = this.cur), this.stack.push(this.cur))
        this.cur = new b(this, a, c, d, e)
        "top" === a && (this.global = this.cur.symFlags)
        k && k.children.push(this.cur)
      }
      c.prototype.exitBlock = function() {
        this.cur = null
        0 < this.stack.length && (this.cur = this.stack.pop())
      }
      c.prototype.visitParams = function(a, b) {
        var c
        for (c = 0; c < a.length; ++c)
          if (((b = a[c]), b.constructor === self.Sk.astnodes.arg))
            this.addDef(b.arg, 4, b.lineno)
          else
            throw new self.Sk.builtin.SyntaxError(
              "invalid expression in parameter list",
              this.filename,
            )
      }
      c.prototype.visitArguments = function(a, b) {
        a.args && this.visitParams(a.args, !0)
        a.kwonlyargs && this.visitParams(a.kwonlyargs, !0)
        a.vararg && (this.addDef(a.vararg.arg, 4, b), (this.cur.varargs = !0))
        a.kwarg && (this.addDef(a.kwarg.arg, 4, b), (this.cur.varkeywords = !0))
      }
      c.prototype.newTmpname = function(a) {
        this.addDef(new self.Sk.builtin.str("_[" + ++this.tmpname + "]"), 2, a)
      }
      c.prototype.addDef = function(a, b, c) {
        var d = self.Sk.mangleName(this.curClass, new self.Sk.builtin.str(a)).v
        d = self.Sk.fixReservedNames(d)
        var e = this.cur.symFlags[d]
        if (void 0 !== e) {
          if (b & 4 && e & 4)
            throw new self.Sk.builtin.SyntaxError(
              "duplicate argument '" + a.v + "' in function definition",
              this.filename,
              c,
            )
          e |= b
        } else e = b
        this.cur.symFlags[d] = e
        b & 4
          ? this.cur.varnames.push(d)
          : b & 1 &&
            ((e = b),
            (a = this.global[d]),
            void 0 !== a && (e |= a),
            (this.global[d] = e))
      }
      c.prototype.visitSlice = function(a) {
        var b
        switch (a.constructor) {
          case self.Sk.astnodes.Slice:
            a.lower && this.visitExpr(a.lower)
            a.upper && this.visitExpr(a.upper)
            a.step && this.visitExpr(a.step)
            break
          case self.Sk.astnodes.ExtSlice:
            for (b = 0; b < a.dims.length; ++b) this.visitSlice(a.dims[b])
            break
          case self.Sk.astnodes.Index:
            this.visitExpr(a.value)
        }
      }
      c.prototype.visitStmt = function(a) {
        var b
        self.Sk.asserts.assert(void 0 !== a, "visitStmt called with undefined")
        switch (a.constructor) {
          case self.Sk.astnodes.FunctionDef:
            this.addDef(a.name, 2, a.lineno)
            a.args.defaults && this.SEQExpr(a.args.defaults)
            a.decorator_list && this.SEQExpr(a.decorator_list)
            this.enterBlock(a.name.v, "function", a, a.lineno)
            this.visitArguments(a.args, a.lineno)
            this.SEQStmt(a.body)
            this.exitBlock()
            break
          case self.Sk.astnodes.ClassDef:
            this.addDef(a.name, 2, a.lineno)
            this.SEQExpr(a.bases)
            a.decorator_list && this.SEQExpr(a.decorator_list)
            this.enterBlock(a.name.v, "class", a, a.lineno)
            this.curClass = a.name
            this.SEQStmt(a.body)
            this.exitBlock()
            break
          case self.Sk.astnodes.Return:
            if (
              a.value &&
              (this.visitExpr(a.value),
              (this.cur.returnsValue = !0),
              this.cur.generator)
            )
              throw new self.Sk.builtin.SyntaxError(
                "'return' with argument inside generator",
                this.filename,
              )
            break
          case self.Sk.astnodes.Delete:
            this.SEQExpr(a.targets)
            break
          case self.Sk.astnodes.Assign:
            this.SEQExpr(a.targets)
            this.visitExpr(a.value)
            break
          case self.Sk.astnodes.AnnAssign:
            if (a.target.constructor == self.Sk.astnodes.Name) {
              var c = a.target
              var e = self.Sk.mangleName(this.curClass, c.id).v
              e = self.Sk.fixReservedNames(e)
              c = this.cur.symFlags[e]
              if (c & 2049 && this.global != this.cur.symFlags && a.simple)
                throw new self.Sk.builtin.SyntaxError(
                  "annotated name '" + e + "' can't be global",
                  this.filename,
                  a.lineno,
                )
              a.simple
                ? this.addDef(new self.Sk.builtin.str(e), 4098, a.lineno)
                : a.value && this.addDef(new self.Sk.builtin.str(e), 2, a.lineno)
            } else this.visitExpr(a.target)
            this.visitExpr(a.annotation)
            a.value && this.visitExpr(a.value)
            break
          case self.Sk.astnodes.AugAssign:
            this.visitExpr(a.target)
            this.visitExpr(a.value)
            break
          case self.Sk.astnodes.Print:
            a.dest && this.visitExpr(a.dest)
            this.SEQExpr(a.values)
            break
          case self.Sk.astnodes.For:
            this.visitExpr(a.target)
            this.visitExpr(a.iter)
            this.SEQStmt(a.body)
            a.orelse && this.SEQStmt(a.orelse)
            break
          case self.Sk.astnodes.While:
            this.visitExpr(a.test)
            this.SEQStmt(a.body)
            a.orelse && this.SEQStmt(a.orelse)
            break
          case self.Sk.astnodes.If:
            this.visitExpr(a.test)
            this.SEQStmt(a.body)
            a.orelse && this.SEQStmt(a.orelse)
            break
          case self.Sk.astnodes.Raise:
            a.exc &&
              (this.visitExpr(a.exc),
              a.inst &&
                (this.visitExpr(a.inst), a.tback && this.visitExpr(a.tback)),
              a.cause && this.visitExpr(a.cause))
            break
          case self.Sk.astnodes.Assert:
            this.visitExpr(a.test)
            a.msg && this.visitExpr(a.msg)
            break
          case self.Sk.astnodes.Import:
          case self.Sk.astnodes.ImportFrom:
            this.visitAlias(a.names, a.lineno)
            break
          case self.Sk.astnodes.Global:
            var f = a.names.length
            for (b = 0; b < f; ++b) {
              e = self.Sk.mangleName(this.curClass, a.names[b]).v
              e = self.Sk.fixReservedNames(e)
              c = this.cur.symFlags[e]
              if (c & 10) {
                if (c & 2)
                  throw new self.Sk.builtin.SyntaxError(
                    "name '" + e + "' is assigned to before global declaration",
                    this.filename,
                    a.lineno,
                  )
                throw new self.Sk.builtin.SyntaxError(
                  "name '" + e + "' is used prior to global declaration",
                  this.filename,
                  a.lineno,
                )
              }
              this.addDef(new self.Sk.builtin.str(e), 1, a.lineno)
            }
            break
          case self.Sk.astnodes.Expr:
            this.visitExpr(a.value)
            break
          case self.Sk.astnodes.Pass:
          case self.Sk.astnodes.Break:
          case self.Sk.astnodes.Continue:
          case self.Sk.astnodes.Debugger:
            break
          case self.Sk.astnodes.With:
            d(this.visit_withitem.bind(this), a.items)
            d(this.visitStmt.bind(this), a.body)
            break
          case self.Sk.astnodes.Try:
            this.SEQStmt(a.body)
            this.visitExcepthandlers(a.handlers)
            this.SEQStmt(a.orelse)
            this.SEQStmt(a.finalbody)
            break
          default:
            self.Sk.asserts.fail(
              "Unhandled type " + a.constructor.name + " in visitStmt",
            )
        }
      }
      c.prototype.visit_withitem = function(a) {
        this.visitExpr(a.context_expr)
        a.optional_vars && this.visitExpr(a.optional_vars)
      }
      c.prototype.visitExpr = function(a) {
        self.Sk.asserts.assert(void 0 !== a, "visitExpr called with undefined")
        switch (a.constructor) {
          case self.Sk.astnodes.BoolOp:
            this.SEQExpr(a.values)
            break
          case self.Sk.astnodes.BinOp:
            this.visitExpr(a.left)
            this.visitExpr(a.right)
            break
          case self.Sk.astnodes.UnaryOp:
            this.visitExpr(a.operand)
            break
          case self.Sk.astnodes.Lambda:
            this.addDef(new self.Sk.builtin.str("lambda"), 2, a.lineno)
            a.args.defaults && this.SEQExpr(a.args.defaults)
            this.enterBlock("lambda", "function", a, a.lineno)
            this.visitArguments(a.args, a.lineno)
            this.visitExpr(a.body)
            this.exitBlock()
            break
          case self.Sk.astnodes.IfExp:
            this.visitExpr(a.test)
            this.visitExpr(a.body)
            this.visitExpr(a.orelse)
            break
          case self.Sk.astnodes.Dict:
            this.SEQExpr(a.keys)
            this.SEQExpr(a.values)
            break
          case self.Sk.astnodes.DictComp:
          case self.Sk.astnodes.SetComp:
            this.visitComprehension(a.generators, 0)
            break
          case self.Sk.astnodes.ListComp:
            this.newTmpname(a.lineno)
            this.visitExpr(a.elt)
            this.visitComprehension(a.generators, 0)
            break
          case self.Sk.astnodes.GeneratorExp:
            this.visitGenexp(a)
            break
          case self.Sk.astnodes.Yield:
            a.value && this.visitExpr(a.value)
            this.cur.generator = !0
            if (this.cur.returnsValue)
              throw new self.Sk.builtin.SyntaxError(
                "'return' with argument inside generator",
                this.filename,
              )
            break
          case self.Sk.astnodes.Compare:
            this.visitExpr(a.left)
            this.SEQExpr(a.comparators)
            break
          case self.Sk.astnodes.Call:
            this.visitExpr(a.func)
            if (a.args)
              for (let b of a.args)
                b.constructor === self.Sk.astnodes.Starred
                  ? this.visitExpr(b.value)
                  : this.visitExpr(b)
            if (a.keywords) for (let b of a.keywords) this.visitExpr(b.value)
            break
          case self.Sk.astnodes.Num:
          case self.Sk.astnodes.Str:
            break
          case self.Sk.astnodes.Attribute:
            this.visitExpr(a.value)
            break
          case self.Sk.astnodes.Subscript:
            this.visitExpr(a.value)
            this.visitSlice(a.slice)
            break
          case self.Sk.astnodes.Name:
            this.addDef(a.id, a.ctx === self.Sk.astnodes.Load ? 8 : 2, a.lineno)
            break
          case self.Sk.astnodes.NameConstant:
            break
          case self.Sk.astnodes.List:
          case self.Sk.astnodes.Tuple:
          case self.Sk.astnodes.Set:
            this.SEQExpr(a.elts)
            break
          case self.Sk.astnodes.Starred:
            this.visitExpr(a.value)
            break
          default:
            self.Sk.asserts.fail(
              "Unhandled type " + a.constructor.name + " in visitExpr",
            )
        }
      }
      c.prototype.visitComprehension = function(a, b) {
        var c,
          d = a.length
        for (c = b; c < d; ++c)
          (b = a[c]),
            this.visitExpr(b.target),
            this.visitExpr(b.iter),
            this.SEQExpr(b.ifs)
      }
      c.prototype.visitAlias = function(a, b) {
        var c, d
        for (d = 0; d < a.length; ++d) {
          var e = a[d]
          var f = (c = null === e.asname ? e.name.v : e.asname.v)
          e = c.indexOf(".")
          ;-1 !== e && (f = c.substr(0, e))
          if ("*" !== c) this.addDef(new self.Sk.builtin.str(f), 1024, b)
          else if ("module" !== this.cur.blockType)
            throw new self.Sk.builtin.SyntaxError(
              "import * only allowed at module level",
              this.filename,
            )
        }
      }
      c.prototype.visitGenexp = function(a) {
        var b = a.generators[0]
        this.visitExpr(b.iter)
        this.enterBlock("genexpr", "function", a, a.lineno)
        this.cur.generator = !0
        this.addDef(new self.Sk.builtin.str(".0"), 4, a.lineno)
        this.visitExpr(b.target)
        this.SEQExpr(b.ifs)
        this.visitComprehension(a.generators, 1)
        this.visitExpr(a.elt)
        this.exitBlock()
      }
      c.prototype.visitExcepthandlers = function(a) {
        var b, c
        for (b = 0; (c = a[b]); ++b)
          c.type && this.visitExpr(c.type),
            c.name && this.visitExpr(c.name),
            this.SEQStmt(c.body)
      }
      c.prototype.analyzeBlock = function(a, b, c, d) {
        var k = {}
        var f = {},
          l = {},
          g = {},
          h = {}
        "class" == a.blockType && (e(l, d), b && e(g, b))
        for (p in a.symFlags) {
          var m = a.symFlags[p]
          this.analyzeName(a, f, p, m, b, k, c, d)
        }
        "class" !== a.blockType &&
          ("function" === a.blockType && e(g, k), b && e(g, b), e(l, d))
        k = {}
        var p = a.children.length
        for (m = 0; m < p; ++m)
          if (
            ((d = a.children[m]),
            this.analyzeChildBlock(d, g, h, l, k),
            d.hasFree || d.childHasFree)
          )
            a.childHasFree = !0
        e(h, k)
        "function" === a.blockType && this.analyzeCells(f, h)
        b = this.updateSymbols(a.symFlags, f, b, h, "class" === a.blockType)
        a.hasFree = a.hasFree || b
        e(c, h)
      }
      c.prototype.analyzeChildBlock = function(a, b, c, d, f) {
        var k = {}
        e(k, b)
        b = {}
        e(b, c)
        c = {}
        e(c, d)
        this.analyzeBlock(a, k, b, c)
        e(f, b)
      }
      c.prototype.analyzeCells = function(a, b) {
        var c
        for (c in a) {
          var d = a[c]
          1 === d && void 0 !== b[c] && ((a[c] = 5), delete b[c])
        }
      }
      c.prototype.updateSymbols = function(a, b, c, d, e) {
        var k,
          f = !1
        for (k in a) {
          var l = a[k]
          var g = b[k]
          l |= g << 11
          a[k] = l
        }
        for (k in d)
          (b = a[k]),
            void 0 !== b
              ? e && b & 1031 && ((b |= 512), (a[k] = b))
              : void 0 !== c[k] && ((a[k] = 8192), (f = !0))
        return f
      }
      c.prototype.analyzeName = function(a, b, c, d, e, f, q, m) {
        if (d & 1) {
          if (d & 4)
            throw new self.Sk.builtin.SyntaxError(
              "name '" + c + "' is local and global",
              this.filename,
              a.lineno,
            )
          b[c] = 2
          m[c] = null
          e && void 0 !== e[c] && delete e[c]
        } else
          d & 1030
            ? ((b[c] = 1), (f[c] = null), delete m[c])
            : e && void 0 !== e[c]
            ? ((b[c] = 4), (a.hasFree = !0), (q[c] = null))
            : ((m && void 0 !== m[c]) || !a.isNested || (a.hasFree = !0),
              (b[c] = 3))
      }
      c.prototype.analyze = function() {
        this.analyzeBlock(this.top, null, {}, {})
      }
      self.Sk.symboltable = function(a, b) {
        var d = new c(b)
        d.enterBlock("top", "module", a, 0)
        d.top = d.cur
        for (b = 0; b < a.body.length; ++b) d.visitStmt(a.body[b])
        d.exitBlock()
        d.analyze()
        return d
      }
      self.Sk.dumpSymtab = function(a) {
        var b = function(a) {
            return a ? "True" : "False"
          },
          c = function(a) {
            var b,
              c = []
            for (b = 0; b < a.length; ++b)
              c.push(new self.Sk.builtin.str(a[b]).$r().v)
            return "[" + c.join(", ") + "]"
          },
          d = function(a, e) {
            var k, f
            void 0 === e && (e = "")
            var l = e + "Sym_type: " + a.get_type() + "\n"
            l += e + "Sym_name: " + a.get_name() + "\n"
            l += e + "Sym_lineno: " + a.get_lineno() + "\n"
            l += e + "Sym_nested: " + b(a.is_nested()) + "\n"
            l += e + "Sym_haschildren: " + b(a.has_children()) + "\n"
            "class" === a.get_type()
              ? (l += e + "Class_methods: " + c(a.get_methods()) + "\n")
              : "function" === a.get_type() &&
                ((l += e + "Func_params: " + c(a.get_parameters()) + "\n"),
                (l += e + "Func_locals: " + c(a.get_locals()) + "\n"),
                (l += e + "Func_globals: " + c(a.get_globals()) + "\n"),
                (l += e + "Func_frees: " + c(a.get_frees()) + "\n"))
            l += e + "-- Identifiers --\n"
            var g = a.get_identifiers()
            var h = g.length
            for (f = 0; f < h; ++f) {
              var n = a.lookup(g[f])
              l += e + "name: " + n.get_name() + "\n"
              l += e + "  is_referenced: " + b(n.is_referenced()) + "\n"
              l += e + "  is_imported: " + b(n.is_imported()) + "\n"
              l += e + "  is_parameter: " + b(n.is_parameter()) + "\n"
              l += e + "  is_global: " + b(n.is_global()) + "\n"
              l +=
                e + "  is_declared_global: " + b(n.is_declared_global()) + "\n"
              l += e + "  is_local: " + b(n.is_local()) + "\n"
              l += e + "  is_free: " + b(n.is_free()) + "\n"
              l += e + "  is_assigned: " + b(n.is_assigned()) + "\n"
              l += e + "  is_namespace: " + b(n.is_namespace()) + "\n"
              var r = n.get_namespaces()
              var m = r.length
              l += e + "  namespaces: [\n"
              var p = []
              for (k = 0; k < m; ++k) (n = r[k]), p.push(d(n, e + "    "))
              l += p.join("\n")
              l += e + "  ]\n"
            }
            return l
          }
        return d(a.top, "")
      }
      self.Sk.exportSymbol("Sk.symboltable", self.Sk.symboltable)
      self.Sk.exportSymbol("Sk.dumpSymtab", self.Sk.dumpSymtab)
    },
    function(m, p) {
      function a(a, b, c, d, e) {
        this.filename = a
        this.st = b
        this.flags = c
        this.canSuspend = d
        this.interactive = !1
        this.nestlevel = 0
        this.u = null
        this.stack = []
        this.result = []
        this.allUnits = []
        this.source = e ? e.split("\n") : !1
      }
      function b() {
        this.name = this.ste = null
        this.doesSuspend = this.canSuspend = !1
        this.private_ = null
        this.lineno = this.firstlineno = 0
        this.linenoSet = !1
        this.localnames = []
        this.localtemps = []
        this.tempsToSave = []
        this.blocknum = 0
        this.blocks = []
        this.curblock = 0
        this.consts = {}
        this.scopename = null
        this.suffixCode = this.switchCode = this.varDeclsCode = this.prefixCode =
          ""
        this.breakBlocks = []
        this.continueBlocks = []
        this.exceptBlocks = []
        this.finallyBlocks = []
      }
      function c(a) {
        return !0 !== g[a] ? a : a + "_$rw$"
      }
      function d(a) {
        return h[a] ? a + "_$rn$" : a
      }
      function e(a, b) {
        var c = b.v
        if (
          null === a ||
          null === c ||
          "_" !== c.charAt(0) ||
          "_" !== c.charAt(1) ||
          ("_" === c.charAt(c.length - 1) && "_" === c.charAt(c.length - 2))
        )
          return b
        var d = a.v
        d.replace(/_/g, "")
        if ("" === d) return b
        d = a.v
        d.replace(/^_*/, "")
        return (d = new self.Sk.builtin.str("_" + d + c))
      }
      var f
      self.Sk.gensymcount = 0
      b.prototype.activateScope = function() {
        var a = this
        f = function() {
          var b,
            c = a.blocks[a.curblock]
          if (null === c._next)
            for (b = 0; b < arguments.length; ++b) c.push(arguments[b])
        }
      }
      a.prototype.getSourceLine = function(a) {
        self.Sk.asserts.assert(this.source)
        return this.source[a - 1]
      }
      a.prototype.annotateSource = function(a) {
        var b
        if (this.source) {
          var c = a.lineno
          var d = a.col_offset
          f("\n//\n// line ", c, ":\n// ", this.getSourceLine(c), "\n// ")
          for (b = 0; b < d; ++b) f(" ")
          f("^\n//\n")
          self.Sk.asserts.assert(void 0 !== a.lineno && void 0 !== a.col_offset)
          f("$currLineNo = ", c, ";\n$currColNo = ", d, ";\n\n")
        }
      }
      a.prototype.gensym = function(a) {
        return (a = "$" + (a || "") + self.Sk.gensymcount++)
      }
      a.prototype.niceName = function(a) {
        return this.gensym(
          a
            .replace("<", "")
            .replace(">", "")
            .replace(" ", "_"),
        )
      }
      var g = {
          abstract: !0,
          as: !0,
          boolean: !0,
          break: !0,
          byte: !0,
          case: !0,
          catch: !0,
          char: !0,
          class: !0,
          continue: !0,
          const: !0,
          debugger: !0,
          default: !0,
          delete: !0,
          do: !0,
          double: !0,
          else: !0,
          enum: !0,
          export: !0,
          extends: !0,
          false: !0,
          final: !0,
          finally: !0,
          float: !0,
          for: !0,
          function: !0,
          goto: !0,
          if: !0,
          implements: !0,
          import: !0,
          in: !0,
          instanceof: !0,
          int: !0,
          interface: !0,
          is: !0,
          long: !0,
          namespace: !0,
          native: !0,
          new: !0,
          null: !0,
          package: !0,
          private: !0,
          protected: !0,
          public: !0,
          return: !0,
          short: !0,
          static: !0,
          super: !1,
          switch: !0,
          synchronized: !0,
          this: !0,
          throw: !0,
          throws: !0,
          transient: !0,
          true: !0,
          try: !0,
          typeof: !0,
          use: !0,
          var: !0,
          void: !0,
          volatile: !0,
          while: !0,
          with: !0,
        },
        h = {
          __defineGetter__: !0,
          __defineSetter__: !0,
          apply: !0,
          call: !0,
          eval: !0,
          hasOwnProperty: !0,
          isPrototypeOf: !0,
          __lookupGetter__: !0,
          __lookupSetter__: !0,
          __noSuchMethod__: !0,
          propertyIsEnumerable: !0,
          toSource: !0,
          toLocaleString: !0,
          toString: !0,
          unwatch: !0,
          valueOf: !0,
          watch: !0,
          length: !0,
          name: !0,
        }
      a.prototype.makeConstant = function(a) {
        var b,
          c = ""
        for (b = 0; b < arguments.length; ++b) c += arguments[b]
        for (d in this.u.consts)
          if (
            this.u.consts.hasOwnProperty(d) &&
            ((b = this.u.consts[d]), b == c)
          )
            return d
        var d = this.u.scopename + "." + this.gensym("const")
        this.u.consts[d] = c
        return d
      }
      a.prototype._gr = function(a, b) {
        var c,
          d = this.gensym(a)
        this.u.localtemps.push(d)
        f("var ", d, "=")
        for (c = 1; c < arguments.length; ++c) f(arguments[c])
        f(";")
        return d
      }
      a.prototype.outputInterruptTest = function() {
        var a = ""
        if (
          null !== self.Sk.execLimit ||
          (null !== self.Sk.yieldLimit && this.u.canSuspend)
        )
          (a += "var $dateNow = Date.now();"),
            null !== self.Sk.execLimit &&
              (a +=
                "if ($dateNow - self.Sk.execStart > self.Sk.execLimit) {throw new self.Sk.builtin.TimeLimitError(self.Sk.timeoutMsg())}"),
            null !== self.Sk.yieldLimit &&
              this.u.canSuspend &&
              ((a =
                a +
                "if ($dateNow - self.Sk.lastYield > self.Sk.yieldLimit) {" +
                ("var $susp = $saveSuspension({data: {type: 'self.Sk.yield'}, resume: function() {}}, '" +
                  this.filename +
                  "',$currLineNo,$currColNo);")),
              (a += "$susp.$blk = $blk;$susp.optional = true;return $susp;}"),
              (this.u.doesSuspend = !0))
        return a
      }
      a.prototype._jumpfalse = function(a, b) {
        a = this._gr(
          "jfalse",
          "(",
          a,
          "===false||!self.Sk.misceval.isTrue(",
          a,
          "))",
        )
        f("if(", a, "){/*test failed */$blk=", b, ";continue;}")
      }
      a.prototype._jumpundef = function(a, b) {
        f("if(", a, "===undefined){$blk=", b, ";continue;}")
      }
      a.prototype._jumpnotundef = function(a, b) {
        f("if(", a, "!==undefined){$blk=", b, ";continue;}")
      }
      a.prototype._jumptrue = function(a, b) {
        a = this._gr("jtrue", "(", a, "===true||self.Sk.misceval.isTrue(", a, "))")
        f("if(", a, "){/*test passed */$blk=", b, ";continue;}")
      }
      a.prototype._jump = function(a) {
        null === this.u.blocks[this.u.curblock]._next &&
          (f("$blk=", a, ";"), (this.u.blocks[this.u.curblock]._next = a))
      }
      a.prototype._checkSuspension = function(a) {
        if (this.u.canSuspend) {
          var b = this.newBlock("function return or resume suspension")
          this._jump(b)
          this.setBlock(b)
          a = a || { lineno: "$currLineNo", col_offset: "$currColNo" }
          f(
            "if ($ret && $ret.$isSuspension) { return $saveSuspension($ret,'" +
              this.filename +
              "'," +
              a.lineno +
              "," +
              a.col_offset +
              "); }",
          )
          this.u.doesSuspend = !0
          this.u.tempsToSave = this.u.tempsToSave.concat(this.u.localtemps)
        } else
          f(
            "if ($ret && $ret.$isSuspension) { $ret = self.Sk.misceval.retryOptionalSuspensionOrThrow($ret); }",
          )
      }
      a.prototype.cunpackstarstoarray = function(a, b) {
        if (!a || 0 == a.length) return "[]"
        let c = !1
        for (let d of a) {
          if (b && c)
            throw new self.Sk.builtin.SyntaxError(
              "Extended argument unpacking is not permitted in Python 2",
            )
          d.constructor === self.Sk.astnodes.Starred && (c = !0)
        }
        if (c) {
          b = this._gr("unpack", "[]")
          for (let c of a)
            c.constructor !== self.Sk.astnodes.Starred
              ? f(b, ".push(", this.vexpr(c), ");")
              : (f(
                  "$ret = self.Sk.misceval.iterFor(self.Sk.abstr.iter(",
                  this.vexpr(c.value),
                  "), function(e) { ",
                  b,
                  ".push(e); });",
                ),
                this._checkSuspension())
          return b
        }
        return "[" + a.map(a => this.vexpr(a)).join(",") + "]"
      }
      a.prototype.ctuplelistorset = function(a, b, c) {
        self.Sk.asserts.assert("tuple" === c || "list" === c || "set" === c)
        var d = !1
        for (k of a.elts)
          if (k.constructor === self.Sk.astnodes.Starred) {
            d = !0
            break
          }
        if (a.ctx === self.Sk.astnodes.Store) {
          if (d)
            throw new self.Sk.builtin.SyntaxError(
              "Tuple unpacking with stars is not supported",
            )
          d = this._gr(
            "items",
            "Sk.abstr.sequenceUnpack(" + b + "," + a.elts.length + ")",
          )
          for (b = 0; b < a.elts.length; ++b)
            this.vexpr(a.elts[b], d + "[" + b + "]")
        } else if (a.ctx === self.Sk.astnodes.Load || "set" === c) {
          if (d) {
            if (!self.Sk.__future__.python3)
              throw new self.Sk.builtin.SyntaxError(
                "List packing with stars is not supported in Python 2",
              )
            return this._gr(
              "load" + c,
              "new self.Sk.builtins['",
              c,
              "'](",
              this.cunpackstarstoarray(a.elts),
              ")",
            )
          }
          if ("tuple" === c) {
            var e = !0
            d = []
            for (b = 0; b < a.elts.length; ++b) {
              var k = this.vexpr(a.elts[b])
              e && -1 == k.indexOf("$const") && (e = !1)
              d.push(k)
            }
            if (e) return this.makeConstant("new self.Sk.builtin.tuple([" + d + "])")
            for (b = 0; b < d.length; ++b) d[b] = this._gr("elem", d[b])
            return this._gr("load" + c, "new self.Sk.builtins['", c, "']([", d, "])")
          }
          d = []
          for (b = 0; b < a.elts.length; ++b)
            d.push(this._gr("elem", this.vexpr(a.elts[b])))
          return this._gr("load" + c, "new self.Sk.builtins['", c, "']([", d, "])")
        }
      }
      a.prototype.cdict = function(a) {
        var b
        var c = []
        if (null !== a.keys)
          for (
            self.Sk.asserts.assert(a.values.length === a.keys.length), b = 0;
            b < a.values.length;
            ++b
          ) {
            var d = this.vexpr(a.values[b])
            c.push(this.vexpr(a.keys[b]))
            c.push(d)
          }
        return this._gr("loaddict", "new self.Sk.builtins['dict']([", c, "])")
      }
      a.prototype.clistcomp = function(a) {
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.ListComp)
        var b = this._gr("_compr", "new self.Sk.builtins['list']([])")
        return this.ccompgen("list", b, a.generators, 0, a.elt, null, a)
      }
      a.prototype.cdictcomp = function(a) {
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.DictComp)
        var b = this._gr("_dcompr", "new self.Sk.builtins.dict([])")
        return this.ccompgen("dict", b, a.generators, 0, a.value, a.key, a)
      }
      a.prototype.csetcomp = function(a) {
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.SetComp)
        var b = this._gr("_setcompr", "new self.Sk.builtins.set([])")
        return this.ccompgen("set", b, a.generators, 0, a.elt, null, a)
      }
      a.prototype.ccompgen = function(a, b, c, d, e, g, h) {
        var k = this.newBlock(a + " comp start"),
          l = this.newBlock(a + " comp skip"),
          n = this.newBlock(a + " comp anchor"),
          r = c[d],
          q = this.vexpr(r.iter)
        q = this._gr("iter", "Sk.abstr.iter(", q, ")")
        var m
        this._jump(k)
        this.setBlock(k)
        f("$ret = self.Sk.abstr.iternext(", q, ", true);")
        this._checkSuspension(h)
        q = this._gr("next", "$ret")
        this._jumpundef(q, n)
        this.vexpr(r.target, q)
        var p = r.ifs ? r.ifs.length : 0
        for (m = 0; m < p; ++m)
          (q = this.vexpr(r.ifs[m])), this._jumpfalse(q, k)
        ++d < c.length && this.ccompgen(a, b, c, d, e, g, h)
        d >= c.length &&
          ((c = this.vexpr(e)),
          "dict" === a
            ? ((a = this.vexpr(g)), f(b, ".mp$ass_subscript(", a, ",", c, ");"))
            : "list" === a
            ? f(b, ".v.push(", c, ");")
            : "set" === a && f(b, ".v.mp$ass_subscript(", c, ", true);"),
          this._jump(l),
          this.setBlock(l))
        this._jump(k)
        this.setBlock(n)
        return b
      }
      a.prototype.cyield = function(a) {
        if (this.u.ste.blockType !== self.Sk.SYMTAB_CONSTS.FunctionBlock)
          throw new SyntaxError("'yield' outside function")
        var b = "null"
        a.value && (b = this.vexpr(a.value))
        a = this.newBlock("after yield")
        f("return [/*resume*/", a, ",/*ret*/", b, "];")
        this.setBlock(a)
        return "$gen.gi$sentvalue"
      }
      a.prototype.ccompare = function(a) {
        var b
        self.Sk.asserts.assert(a.ops.length === a.comparators.length)
        var c = this.vexpr(a.left)
        var d = a.ops.length
        var e = this.newBlock("done")
        var k = this._gr("compareres", "null")
        for (b = 0; b < d; ++b) {
          var g = this.vexpr(a.comparators[b])
          f(
            "$ret = self.Sk.builtin.bool(self.Sk.misceval.richCompareBool(",
            c,
            ",",
            g,
            ",'",
            a.ops[b].prototype._astname,
            "', true));",
          )
          this._checkSuspension(a)
          f(k, "=$ret;")
          this._jumpfalse("$ret", e)
          c = g
        }
        this._jump(e)
        this.setBlock(e)
        return k
      }
      a.prototype.ccall = function(a) {
        var b = this.vexpr(a.func)
        let c = this.cunpackstarstoarray(a.args, !self.Sk.__future__.python3)
        var d = "undefined"
        if (a.keywords && 0 < a.keywords.length) {
          let c = !1
          d = []
          for (let b of a.keywords) {
            if (c && !self.Sk.__future__.python3)
              throw new SyntaxError(
                "Advanced unpacking of function arguments is not supported in Python 2",
              )
            b.arg
              ? (d.push("'" + b.arg.v + "'"), d.push(this.vexpr(b.value)))
              : (c = !0)
          }
          d = "[" + d.join(",") + "]"
          if (c) {
            d = this._gr("keywordArgs", d)
            for (let c of a.keywords)
              c.arg ||
                (f(
                  "$ret = self.Sk.abstr.mappingUnpackIntoKeywordArray(",
                  d,
                  ",",
                  this.vexpr(c.value),
                  ",",
                  b,
                  ");",
                ),
                this._checkSuspension())
          }
        }
        self.Sk.__future__.super_args &&
          a.func.id &&
          "super" === a.func.id.v &&
          "[]" === c &&
          (f(
            'if (typeof self === "undefined" || self.toString().indexOf("Window") > 0) { throw new self.Sk.builtin.RuntimeError("super(): no arguments") };',
          ),
          (c = "[$gbl.__class__,self]"))
        "undefined" !== d
          ? f(
              "$ret = self.Sk.misceval.applyOrSuspend(",
              b,
              ",undefined,undefined,",
              d,
              ",",
              c,
              ");",
            )
          : "[]" != c
          ? f("$ret = self.Sk.misceval.callsimOrSuspendArray(", b, ", ", c, ");")
          : f("$ret = self.Sk.misceval.callsimOrSuspendArray(", b, ");")
        this._checkSuspension(a)
        return this._gr("call", "$ret")
      }
      a.prototype.cslice = function(a) {
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.Slice)
        if (self.Sk.__future__.python3) {
          var b = a.lower ? this.vexpr(a.lower) : "Sk.builtin.none.none$"
          var c = a.upper ? this.vexpr(a.upper) : "Sk.builtin.none.none$"
        } else
          (b = a.lower
            ? this.vexpr(a.lower)
            : a.step
            ? "Sk.builtin.none.none$"
            : "new self.Sk.builtin.int_(0)"),
            (c = a.upper
              ? this.vexpr(a.upper)
              : a.step
              ? "Sk.builtin.none.none$"
              : "new self.Sk.builtin.int_(2147483647)")
        a = a.step ? this.vexpr(a.step) : "Sk.builtin.none.none$"
        return this._gr(
          "slice",
          "new self.Sk.builtins['slice'](",
          b,
          ",",
          c,
          ",",
          a,
          ")",
        )
      }
      a.prototype.eslice = function(a) {
        var b
        self.Sk.asserts.assert(a instanceof Array)
        var c = []
        for (b = 0; b < a.length; b++) c.push(this.vslicesub(a[b]))
        return this._gr("extslice", "new self.Sk.builtins['tuple']([", c, "])")
      }
      a.prototype.vslicesub = function(a) {
        switch (a.constructor) {
          case self.Sk.astnodes.Index:
            var b = this.vexpr(a.value)
            break
          case self.Sk.astnodes.Slice:
            b = this.cslice(a)
            break
          case self.Sk.astnodes.Ellipsis:
            self.Sk.asserts.fail("todo compile.js Ellipsis;")
            break
          case self.Sk.astnodes.ExtSlice:
            b = this.eslice(a.dims)
            break
          default:
            self.Sk.asserts.fail("invalid subscript kind")
        }
        return b
      }
      a.prototype.vslice = function(a, b, c, d) {
        a = this.vslicesub(a)
        return this.chandlesubscr(b, c, a, d)
      }
      a.prototype.chandlesubscr = function(a, b, c, d) {
        if (a === self.Sk.astnodes.Load || a === self.Sk.astnodes.AugLoad)
          return (
            f("$ret = self.Sk.abstr.objectGetItem(", b, ",", c, ", true);"),
            this._checkSuspension(),
            this._gr("lsubscr", "$ret")
          )
        a === self.Sk.astnodes.Store || a === self.Sk.astnodes.AugStore
          ? (f("$ret = self.Sk.abstr.objectSetItem(", b, ",", c, ",", d, ", true);"),
            this._checkSuspension())
          : a === self.Sk.astnodes.Del
          ? f("Sk.abstr.objectDelItem(", b, ",", c, ");")
          : self.Sk.asserts.fail("handlesubscr fail")
      }
      a.prototype.cboolop = function(a) {
        var b, c
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.BoolOp)
        var d = a.op === self.Sk.astnodes.And ? this._jumpfalse : this._jumptrue
        var e = this.newBlock("end of boolop")
        var k = a.values
        var g = k.length
        for (b = 0; b < g; ++b)
          (a = this.vexpr(k[b])),
            0 === b && (c = this._gr("boolopsucc", a)),
            f(c, "=", a, ";"),
            d.call(this, a, e)
        this._jump(e)
        this.setBlock(e)
        return c
      }
      a.prototype.vexpr = function(a, b, g, h) {
        var k
        a.lineno > this.u.lineno &&
          ((this.u.lineno = a.lineno), (this.u.linenoSet = !1))
        switch (a.constructor) {
          case self.Sk.astnodes.BoolOp:
            return this.cboolop(a)
          case self.Sk.astnodes.BinOp:
            return this._gr(
              "binop",
              "Sk.abstr.numberBinOp(",
              this.vexpr(a.left),
              ",",
              this.vexpr(a.right),
              ",'",
              a.op.prototype._astname,
              "')",
            )
          case self.Sk.astnodes.UnaryOp:
            return this._gr(
              "unaryop",
              "Sk.abstr.numberUnaryOp(",
              this.vexpr(a.operand),
              ",'",
              a.op.prototype._astname,
              "')",
            )
          case self.Sk.astnodes.Lambda:
            return this.clambda(a)
          case self.Sk.astnodes.IfExp:
            return this.cifexp(a)
          case self.Sk.astnodes.Dict:
            return this.cdict(a)
          case self.Sk.astnodes.ListComp:
            return this.clistcomp(a)
          case self.Sk.astnodes.DictComp:
            return this.cdictcomp(a)
          case self.Sk.astnodes.SetComp:
            return this.csetcomp(a)
          case self.Sk.astnodes.GeneratorExp:
            return this.cgenexp(a)
          case self.Sk.astnodes.Yield:
            return this.cyield(a)
          case self.Sk.astnodes.Compare:
            return this.ccompare(a)
          case self.Sk.astnodes.Call:
            return (b = this.ccall(a)), this.annotateSource(a), b
          case self.Sk.astnodes.Num:
            if ("number" === typeof a.n) return a.n
            if (a.n instanceof self.Sk.builtin.int_)
              return this.makeConstant("new self.Sk.builtin.int_(" + a.n.v + ")")
            if (a.n instanceof self.Sk.builtin.float_)
              return (
                (a = 0 === a.n.v && -Infinity === 1 / a.n.v ? "-0" : a.n.v),
                this.makeConstant("new self.Sk.builtin.float_(" + a + ")")
              )
            if (a.n instanceof self.Sk.builtin.lng)
              return this.makeConstant(
                "Sk.longFromStr('" + a.n.tp$str().v + "')",
              )
            if (a.n instanceof self.Sk.builtin.complex)
              return this.makeConstant(
                "new self.Sk.builtin.complex(new self.Sk.builtin.float_(" +
                  (0 === a.n.real.v && -Infinity === 1 / a.n.real.v
                    ? "-0"
                    : a.n.real.v) +
                  "), new self.Sk.builtin.float_(" +
                  (0 === a.n.imag.v && -Infinity === 1 / a.n.imag.v
                    ? "-0"
                    : a.n.imag.v) +
                  "))",
              )
            self.Sk.asserts.fail("unhandled Num type")
          case self.Sk.astnodes.Str:
            return this.makeConstant("new self.Sk.builtin.str(", a.s.$r().v, ")")
          case self.Sk.astnodes.Attribute:
            a.ctx !== self.Sk.astnodes.AugLoad &&
              a.ctx !== self.Sk.astnodes.AugStore &&
              (k = this.vexpr(a.value))
            h = a.attr.$r().v
            h = h.substring(1, h.length - 1)
            h = e(this.u.private_, new self.Sk.builtin.str(h)).v
            h = c(h)
            h = d(h)
            h = this.makeConstant("new self.Sk.builtin.str('" + h + "')")
            switch (a.ctx) {
              case self.Sk.astnodes.AugLoad:
                return (
                  f("$ret = self.Sk.abstr.gattr(", g, ",", h, ", true);"),
                  this._checkSuspension(a),
                  this._gr("lattr", "$ret")
                )
              case self.Sk.astnodes.Load:
                return (
                  f("$ret = self.Sk.abstr.gattr(", k, ",", h, ", true);"),
                  this._checkSuspension(a),
                  this._gr("lattr", "$ret")
                )
              case self.Sk.astnodes.AugStore:
                f("$ret = undefined;")
                f("if(", b, "!==undefined){")
                f("$ret = self.Sk.abstr.sattr(", g, ",", h, ",", b, ", true);")
                f("}")
                this._checkSuspension(a)
                break
              case self.Sk.astnodes.Store:
                f("$ret = self.Sk.abstr.sattr(", k, ",", h, ",", b, ", true);")
                this._checkSuspension(a)
                break
              case self.Sk.astnodes.Del:
                self.Sk.asserts.fail("todo Del;")
                break
              default:
                self.Sk.asserts.fail("invalid attribute expression")
            }
            break
          case self.Sk.astnodes.Subscript:
            switch (a.ctx) {
              case self.Sk.astnodes.AugLoad:
                return (
                  f("$ret = self.Sk.abstr.objectGetItem(", g, ",", h, ", true);"),
                  this._checkSuspension(a),
                  this._gr("gitem", "$ret")
                )
              case self.Sk.astnodes.Load:
              case self.Sk.astnodes.Store:
              case self.Sk.astnodes.Del:
                return this.vslice(a.slice, a.ctx, this.vexpr(a.value), b)
              case self.Sk.astnodes.AugStore:
                f("$ret=undefined;")
                f("if(", b, "!==undefined){")
                f("$ret=self.Sk.abstr.objectSetItem(", g, ",", h, ",", b, ", true)")
                f("}")
                this._checkSuspension(a)
                break
              default:
                self.Sk.asserts.fail("invalid subscript expression")
            }
            break
          case self.Sk.astnodes.Name:
            return this.nameop(a.id, a.ctx, b)
          case self.Sk.astnodes.NameConstant:
            if (
              a.ctx === self.Sk.astnodes.Store ||
              a.ctx === self.Sk.astnodes.AugStore ||
              a.ctx === self.Sk.astnodes.Del
            )
              throw new self.Sk.builtin.SyntaxError(
                "can not assign to a constant name",
              )
            switch (a.value) {
              case self.Sk.builtin.none.none$:
                return "Sk.builtin.none.none$"
              case self.Sk.builtin.bool.true$:
                return "Sk.builtin.bool.true$"
              case self.Sk.builtin.bool.false$:
                return "Sk.builtin.bool.false$"
              default:
                self.Sk.asserts.fail("invalid named constant")
            }
            break
          case self.Sk.astnodes.List:
            return this.ctuplelistorset(a, b, "list")
          case self.Sk.astnodes.Tuple:
            return this.ctuplelistorset(a, b, "tuple")
          case self.Sk.astnodes.Set:
            return this.ctuplelistorset(a, b, "set")
          case self.Sk.astnodes.Starred:
            break
          default:
            self.Sk.asserts.fail("unhandled case " + a.constructor.name + " vexpr")
        }
      }
      a.prototype.vseqexpr = function(a, b) {
        var c
        self.Sk.asserts.assert(void 0 === b || a.length === b.length)
        var d = []
        for (c = 0; c < a.length; ++c)
          d.push(this.vexpr(a[c], void 0 === b ? void 0 : b[c]))
        return d
      }
      a.prototype.caugassign = function(a) {
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.AugAssign)
        var b = a.target
        switch (b.constructor) {
          case self.Sk.astnodes.Attribute:
            var c = this.vexpr(b.value)
            b = new self.Sk.astnodes.Attribute(
              b.value,
              b.attr,
              self.Sk.astnodes.AugLoad,
              b.lineno,
              b.col_offset,
            )
            var d = this.vexpr(b, void 0, c)
            var e = this.vexpr(a.value)
            a = this._gr(
              "inplbinopattr",
              "Sk.abstr.numberInplaceBinOp(",
              d,
              ",",
              e,
              ",'",
              a.op.prototype._astname,
              "')",
            )
            b.ctx = self.Sk.astnodes.AugStore
            return this.vexpr(b, a, c)
          case self.Sk.astnodes.Subscript:
            c = this.vexpr(b.value)
            var k = this.vslicesub(b.slice)
            b = new self.Sk.astnodes.Subscript(
              b.value,
              k,
              self.Sk.astnodes.AugLoad,
              b.lineno,
              b.col_offset,
            )
            d = this.vexpr(b, void 0, c, k)
            e = this.vexpr(a.value)
            a = this._gr(
              "inplbinopsubscr",
              "Sk.abstr.numberInplaceBinOp(",
              d,
              ",",
              e,
              ",'",
              a.op.prototype._astname,
              "')",
            )
            b.ctx = self.Sk.astnodes.AugStore
            return this.vexpr(b, a, c, k)
          case self.Sk.astnodes.Name:
            return (
              (c = this.nameop(b.id, self.Sk.astnodes.Load)),
              (e = this.vexpr(a.value)),
              (a = this._gr(
                "inplbinop",
                "Sk.abstr.numberInplaceBinOp(",
                c,
                ",",
                e,
                ",'",
                a.op.prototype._astname,
                "')",
              )),
              this.nameop(b.id, self.Sk.astnodes.Store, a)
            )
          default:
            self.Sk.asserts.fail("unhandled case in augassign")
        }
      }
      a.prototype.exprConstant = function(a) {
        switch (a.constructor) {
          case self.Sk.astnodes.Num:
            return self.Sk.misceval.isTrue(a.n) ? 1 : 0
          case self.Sk.astnodes.Str:
            return self.Sk.misceval.isTrue(a.s) ? 1 : 0
          default:
            return -1
        }
      }
      a.prototype.newBlock = function(a) {
        var b = this.u.blocknum++
        this.u.blocks[b] = []
        this.u.blocks[b]._name = a || "<unnamed>"
        this.u.blocks[b]._next = null
        return b
      }
      a.prototype.setBlock = function(a) {
        self.Sk.asserts.assert(0 <= a && a < this.u.blocknum)
        this.u.curblock = a
      }
      a.prototype.pushBreakBlock = function(a) {
        self.Sk.asserts.assert(0 <= a && a < this.u.blocknum)
        this.u.breakBlocks.push(a)
      }
      a.prototype.popBreakBlock = function() {
        this.u.breakBlocks.pop()
      }
      a.prototype.pushContinueBlock = function(a) {
        self.Sk.asserts.assert(0 <= a && a < this.u.blocknum)
        this.u.continueBlocks.push(a)
      }
      a.prototype.popContinueBlock = function() {
        this.u.continueBlocks.pop()
      }
      a.prototype.pushExceptBlock = function(a) {
        self.Sk.asserts.assert(0 <= a && a < this.u.blocknum)
        this.u.exceptBlocks.push(a)
      }
      a.prototype.popExceptBlock = function() {
        this.u.exceptBlocks.pop()
      }
      a.prototype.pushFinallyBlock = function(a) {
        self.Sk.asserts.assert(0 <= a && a < this.u.blocknum)
        self.Sk.asserts.assert(
          this.u.breakBlocks.length === this.u.continueBlocks.length,
        )
        this.u.finallyBlocks.push({
          blk: a,
          breakDepth: this.u.breakBlocks.length,
        })
      }
      a.prototype.popFinallyBlock = function() {
        this.u.finallyBlocks.pop()
      }
      a.prototype.peekFinallyBlock = function() {
        return 0 < this.u.finallyBlocks.length
          ? this.u.finallyBlocks[this.u.finallyBlocks.length - 1]
          : void 0
      }
      a.prototype.setupExcept = function(a) {
        f("$exc.push(", a, ");")
      }
      a.prototype.endExcept = function() {
        f("$exc.pop();")
      }
      a.prototype.outputLocals = function(a) {
        var b,
          c = {}
        for (b = 0; a.argnames && b < a.argnames.length; ++b)
          c[a.argnames[b]] = !0
        a.localnames.sort()
        var d = []
        for (b = 0; b < a.localnames.length; ++b) {
          var e = a.localnames[b]
          void 0 === c[e] && (d.push(e), (c[e] = !0))
        }
        return 0 < d.length ? "var " + d.join(",") + "; /* locals */" : ""
      }
      a.prototype.outputSuspensionHelpers = function(a) {
        var b,
          c = [],
          d = a.localnames.concat(a.tempsToSave),
          e = {},
          f =
            a.ste.blockType === self.Sk.SYMTAB_CONSTS.FunctionBlock &&
            a.ste.childHasFree,
          k =
            (0 < d.length ? "var " + d.join(",") + ";" : "") +
            "var $wakeFromSuspension = function() {var susp = " +
            a.scopename +
            ".$wakingSuspension; " +
            a.scopename +
            ".$wakingSuspension = undefined;$blk=susp.$blk; $loc=susp.$loc; $gbl=susp.$gbl; $exc=susp.$exc; $err=susp.$err; $postfinally=susp.$postfinally;$currLineNo=susp.$lineno; $currColNo=susp.$colno; self.Sk.lastYield=Date.now();" +
            (f ? "$cell=susp.$cell;" : "")
        for (b = 0; b < d.length; b++) {
          var g = d[b]
          void 0 === e[g] && ((k += g + "=susp.$tmps." + g + ";"), (e[g] = !0))
        }
        k +=
          "try { $ret=susp.child.resume(); } catch(err) { if (!(err instanceof self.Sk.builtin.BaseException)) { err = new self.Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '" +
          this.filename +
          "'}); if($exc.length>0) { $err=err; $blk=$exc.pop(); } else { throw err; } }};"
        k +=
          "var $saveSuspension = function($child, $filename, $lineno, $colno) {var susp = new self.Sk.misceval.Suspension(); susp.child=$child;susp.resume=function(){" +
          a.scopename +
          ".$wakingSuspension=susp; return " +
          a.scopename +
          "(" +
          (a.ste.generator ? "$gen" : "") +
          "); };susp.data=susp.child.data;susp.$blk=$blk;susp.$loc=$loc;susp.$gbl=$gbl;susp.$exc=$exc;susp.$err=$err;susp.$postfinally=$postfinally;susp.$filename=$filename;susp.$lineno=$lineno;susp.$colno=$colno;susp.optional=susp.child.optional;" +
          (f ? "susp.$cell=$cell;" : "")
        e = {}
        for (b = 0; b < d.length; b++)
          (g = d[b]),
            void 0 === e[g] && (c.push('"' + g + '":' + g), (e[g] = !0))
        return (k += "susp.$tmps={" + c.join(",") + "};return susp;};")
      }
      a.prototype.outputAllUnits = function() {
        var a,
          b,
          c = ""
        for (b = 0; b < this.allUnits.length; ++b) {
          var d = this.allUnits[b]
          c += d.prefixCode
          c += this.outputLocals(d)
          d.doesSuspend && (c += this.outputSuspensionHelpers(d))
          c += d.varDeclsCode
          c += d.switchCode
          var e = d.blocks
          var f = Object.create(null)
          for (a = 0; a < e.length; ++a) {
            var g = a
            if (!(g in f))
              for (;;)
                if (
                  ((f[g] = !0),
                  (c += "case " + g + ": /* --- " + e[g]._name + " --- */"),
                  (c += e[g].join("")),
                  null !== e[g]._next)
                )
                  if (e[g]._next in f) {
                    c += "/* jump */ continue;"
                    break
                  } else
                    (c += "/* allowing case fallthrough */"), (g = e[g]._next)
                else {
                  c +=
                    "throw new self.Sk.builtin.SystemError('internal error: unterminated block');"
                  break
                }
          }
          c += d.suffixCode
        }
        return c
      }
      a.prototype.cif = function(a) {
        var b
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.If)
        var c = this.exprConstant(a.test)
        if (0 === c) a.orelse && 0 < a.orelse.length && this.vseqstmt(a.orelse)
        else if (1 === c) this.vseqstmt(a.body)
        else {
          var d = this.newBlock("end of if")
          a.orelse &&
            0 < a.orelse.length &&
            (b = this.newBlock("next branch of if"))
          c = this.vexpr(a.test)
          a.orelse && 0 < a.orelse.length
            ? (this._jumpfalse(c, b),
              this.vseqstmt(a.body),
              this._jump(d),
              this.setBlock(b),
              this.vseqstmt(a.orelse))
            : (this._jumpfalse(c, d), this.vseqstmt(a.body))
          this._jump(d)
          this.setBlock(d)
        }
      }
      a.prototype.cwhile = function(a) {
        if (0 === this.exprConstant(a.test)) a.orelse && this.vseqstmt(a.orelse)
        else {
          var b = this.newBlock("while test")
          this._jump(b)
          this.setBlock(b)
          var c = this.newBlock("after while")
          var d = 0 < a.orelse.length ? this.newBlock("while orelse") : null
          var e = this.newBlock("while body")
          this.annotateSource(a)
          this._jumpfalse(this.vexpr(a.test), d ? d : c)
          this._jump(e)
          this.pushBreakBlock(c)
          this.pushContinueBlock(b)
          this.setBlock(e)
          ;(self.Sk.debugging || self.Sk.killableWhile) &&
            this.u.canSuspend &&
            ((e = this.newBlock("debug breakpoint for line " + a.lineno)),
            f(
              "if (self.Sk.breakpoints('" +
                this.filename +
                "'," +
                a.lineno +
                "," +
                a.col_offset +
                ")) {",
              "var $susp = $saveSuspension({data: {type: 'self.Sk.delay'}, resume: function() {}}, '" +
                this.filename +
                "'," +
                a.lineno +
                "," +
                a.col_offset +
                ");",
              "$susp.$blk = " + e + ";",
              "$susp.optional = true;",
              "return $susp;",
              "}",
            ),
            this._jump(e),
            this.setBlock(e),
            (this.u.doesSuspend = !0))
          this.vseqstmt(a.body)
          this._jump(b)
          this.popContinueBlock()
          this.popBreakBlock()
          0 < a.orelse.length &&
            (this.setBlock(d), this.vseqstmt(a.orelse), this._jump(c))
          this.setBlock(c)
        }
      }
      a.prototype.cfor = function(a) {
        var b = this.newBlock("for start"),
          c = this.newBlock("for cleanup"),
          d = this.newBlock("for end")
        this.pushBreakBlock(d)
        this.pushContinueBlock(b)
        var e = this.vexpr(a.iter)
        if (this.u.ste.generator) {
          var k = "$loc." + this.gensym("iter")
          f(k, "=self.Sk.abstr.iter(", e, ");")
        } else
          (k = this._gr("iter", "Sk.abstr.iter(", e, ")")),
            this.u.tempsToSave.push(k)
        this._jump(b)
        this.setBlock(b)
        f(
          "$ret = self.Sk.abstr.iternext(",
          k,
          this.u.canSuspend ? ", true" : ", false",
          ");",
        )
        this._checkSuspension(a)
        k = this._gr("next", "$ret")
        this._jumpundef(k, c)
        this.vexpr(a.target, k)
        ;(self.Sk.debugging || self.Sk.killableFor) &&
          this.u.canSuspend &&
          ((k = this.newBlock("debug breakpoint for line " + a.lineno)),
          f(
            "if (self.Sk.breakpoints('" +
              this.filename +
              "'," +
              a.lineno +
              "," +
              a.col_offset +
              ")) {",
            "var $susp = $saveSuspension({data: {type: 'self.Sk.delay'}, resume: function() {}}, '" +
              this.filename +
              "'," +
              a.lineno +
              "," +
              a.col_offset +
              ");",
            "$susp.$blk = " + k + ";",
            "$susp.optional = true;",
            "return $susp;",
            "}",
          ),
          this._jump(k),
          this.setBlock(k),
          (this.u.doesSuspend = !0))
        this.vseqstmt(a.body)
        this._jump(b)
        this.setBlock(c)
        this.popContinueBlock()
        this.popBreakBlock()
        this.vseqstmt(a.orelse)
        this._jump(d)
        this.setBlock(d)
      }
      a.prototype.craise = function(a) {
        if (a.exc) {
          var b = this._gr("exc", this.vexpr(a.exc)),
            c = this.newBlock("exception now instantiated"),
            d = this._gr(
              "isclass",
              b +
                " instanceof self.Sk.builtin.type || " +
                b +
                ".prototype instanceof self.Sk.builtin.BaseException",
            )
          this._jumpfalse(d, c)
          a.inst
            ? ((d = this._gr("inst", this.vexpr(a.inst))),
              f(
                "if(!(",
                d,
                " instanceof self.Sk.builtin.tuple)) {",
                d,
                "= new self.Sk.builtin.tuple([",
                d,
                "]);",
                "}",
              ),
              f("$ret = self.Sk.misceval.callsimOrSuspendArray(", b, ",", d, ".v);"))
            : f("$ret = self.Sk.misceval.callsimOrSuspend(", b, ");")
          this._checkSuspension(a)
          f(b, "=$ret;")
          this._jump(c)
          this.setBlock(c)
          f("throw ", b, ";")
        } else f("throw $err;")
      }
      a.prototype.outputFinallyCascade = function(a) {
        if (0 == this.u.finallyBlocks.length)
          f(
            "if($postfinally!==undefined) { if ($postfinally.returning) { return $postfinally.returning; } else { $blk=$postfinally.gotoBlock; $postfinally=undefined; continue; } }",
          )
        else {
          var b = this.peekFinallyBlock()
          f(
            "if($postfinally!==undefined) {",
            "if ($postfinally.returning",
            b.breakDepth == a.breakDepth ? "|| $postfinally.isBreak" : "",
            ") {",
            "$blk=",
            b.blk,
            ";continue;",
            "} else {",
            "$blk=$postfinally.gotoBlock;$postfinally=undefined;continue;",
            "}",
            "}",
          )
        }
      }
      a.prototype.ctry = function(a) {
        var b,
          c = a.handlers.length
        if (a.finalbody) {
          var d = this.newBlock("finalbody")
          var e = this.newBlock("finalexh")
          var k = this._gr("finally_reraise", "undefined")
          this.u.tempsToSave.push(k)
          this.pushFinallyBlock(d)
          var g = this.peekFinallyBlock()
          this.setupExcept(e)
        }
        var h = []
        for (b = 0; b < c; ++b) h.push(this.newBlock("except_" + b + "_"))
        var m = this.newBlock("unhandled")
        var p = this.newBlock("orelse")
        var C = this.newBlock("end")
        0 != h.length && this.setupExcept(h[0])
        this.vseqstmt(a.body)
        0 != h.length && this.endExcept()
        this._jump(p)
        for (b = 0; b < c; ++b) {
          this.setBlock(h[b])
          var K = a.handlers[b]
          if (!K.type && b < c - 1)
            throw new SyntaxError("default 'except:' must be last")
          if (K.type) {
            var B = this.vexpr(K.type)
            var S = b == c - 1 ? m : h[b + 1]
            B = this._gr(
              "instance",
              "Sk.misceval.isTrue(self.Sk.builtin.isinstance($err, ",
              B,
              "))",
            )
            this._jumpfalse(B, S)
          }
          K.name && this.vexpr(K.name, "$err")
          this.vseqstmt(K.body)
          this._jump(C)
        }
        this.setBlock(m)
        f("throw $err;")
        this.setBlock(p)
        this.vseqstmt(a.orelse)
        this._jump(C)
        this.setBlock(C)
        a.finalbody &&
          (this.endExcept(),
          this._jump(d),
          this.setBlock(e),
          f(k, "=$err;"),
          this._jump(d),
          this.setBlock(d),
          this.popFinallyBlock(),
          this.vseqstmt(a.finalbody),
          f("if(", k, "!==undefined) { throw ", k, ";}"),
          this.outputFinallyCascade(g))
      }
      a.prototype.cwith = function(a, b) {
        var c = this.newBlock("withexh"),
          d = this.newBlock("withtidyup"),
          e = this.newBlock("withcarryon")
        var k = this._gr("mgr", this.vexpr(a.items[b].context_expr))
        f("$ret = self.Sk.abstr.gattr(", k, ",self.Sk.builtin.str.$exit, true);")
        this._checkSuspension(a)
        var g = this._gr("exit", "$ret")
        this.u.tempsToSave.push(g)
        f("$ret = self.Sk.abstr.gattr(", k, ",self.Sk.builtin.str.$enter, true);")
        this._checkSuspension(a)
        f("$ret = self.Sk.misceval.callsimOrSuspendArray($ret);")
        this._checkSuspension(a)
        k = this._gr("value", "$ret")
        this.pushFinallyBlock(d)
        var h = this.u.finallyBlocks[this.u.finallyBlocks.length - 1]
        this.setupExcept(c)
        a.items[b].optional_vars &&
          this.nameop(a.items[b].optional_vars.id, self.Sk.astnodes.Store, k)
        b + 1 < a.items.length ? this.cwith(a, b + 1) : this.vseqstmt(a.body)
        this.endExcept()
        this._jump(d)
        this.setBlock(c)
        f(
          "$ret = self.Sk.misceval.applyOrSuspend(",
          g,
          ",undefined,self.Sk.builtin.getExcInfo($err),undefined,[]);",
        )
        this._checkSuspension(a)
        this._jumptrue("$ret", e)
        f("throw $err;")
        this.setBlock(d)
        this.popFinallyBlock()
        f(
          "$ret = self.Sk.misceval.callsimOrSuspendArray(",
          g,
          ",[self.Sk.builtin.none.none$,self.Sk.builtin.none.none$,self.Sk.builtin.none.none$]);",
        )
        this._checkSuspension(a)
        this.outputFinallyCascade(h)
        this._jump(e)
        this.setBlock(e)
      }
      a.prototype.cassert = function(a) {
        var b = this.vexpr(a.test),
          c = this.newBlock("end")
        this._jumptrue(b, c)
        f(
          "throw new self.Sk.builtin.AssertionError(",
          a.msg ? this.vexpr(a.msg) : "",
          ");",
        )
        this.setBlock(c)
      }
      a.prototype.cimportas = function(a, b, c) {
        a = a.v
        var d = a.indexOf("."),
          e = c
        if (-1 !== d)
          for (a = a.substr(d + 1); -1 !== d; )
            (d = a.indexOf(".")),
              (c = -1 !== d ? a.substr(0, d) : a),
              (e = this._gr(
                "lattr",
                "Sk.abstr.gattr(",
                e,
                ", new self.Sk.builtin.str('",
                c,
                "'))",
              )),
              (a = a.substr(d + 1))
        return this.nameop(b, self.Sk.astnodes.Store, e)
      }
      a.prototype.cimport = function(a) {
        var b,
          c = a.names.length
        for (b = 0; b < c; ++b) {
          var d = a.names[b]
          f(
            "$ret = self.Sk.builtin.__import__(",
            d.name.$r().v,
            ",$gbl,$loc,[],",
            self.Sk.__future__.absolute_import ? 0 : -1,
            ");",
          )
          this._checkSuspension(a)
          var e = this._gr("module", "$ret")
          if (d.asname) this.cimportas(d.name, d.asname, e)
          else {
            var k = d.name
            d = k.v.indexOf(".")
            ;-1 !== d && (k = new self.Sk.builtin.str(k.v.substr(0, d)))
            this.nameop(k, self.Sk.astnodes.Store, e)
          }
        }
      }
      a.prototype.cfromimport = function(a) {
        var b,
          d = a.names.length
        var e = []
        var k = a.level
        0 != k || self.Sk.__future__.absolute_import || (k = -1)
        for (b = 0; b < d; ++b) e[b] = "'" + c(a.names[b].name.v) + "'"
        f(
          "$ret = self.Sk.builtin.__import__(",
          a.module.$r().v,
          ",$gbl,$loc,[",
          e,
          "],",
          k,
          ");",
        )
        this._checkSuspension(a)
        k = this._gr("module", "$ret")
        for (b = 0; b < d; ++b) {
          e = a.names[b]
          var g = "'" + c(e.name.v) + "'"
          if (0 === b && "*" === e.name.v) {
            self.Sk.asserts.assert(1 === d)
            f("Sk.importStar(", k, ",$loc, $gbl);")
            break
          }
          var h = this._gr(
            "item",
            "Sk.abstr.gattr(",
            k,
            ", new self.Sk.builtin.str(",
            g,
            "))",
          )
          g = e.name
          e.asname && (g = e.asname)
          this.nameop(g, self.Sk.astnodes.Store, h)
        }
      }
      a.prototype.buildcodeobj = function(a, b, c, d, e, g) {
        var k = [],
          h,
          l = [],
          n = [],
          m = [],
          r = null,
          q = null
        c && (l = this.vseqexpr(c))
        d && d.defaults && (n = this.vseqexpr(d.defaults))
        d &&
          d.kw_defaults &&
          (m = d.kw_defaults.map(a => (a ? this.vexpr(a) : "undefined")))
        d && d.vararg && (r = d.vararg)
        d && d.kwarg && (q = d.kwarg)
        if (
          !self.Sk.__future__.python3 &&
          d &&
          d.kwonlyargs &&
          0 != d.kwonlyargs.length
        )
          throw new self.Sk.builtin.SyntaxError(
            "Keyword-only arguments are not supported in Python 2",
          )
        c = this.enterScope(b, a, a.lineno, this.canSuspend)
        a = this.u.ste.generator
        var p = this.u.ste.hasFree
        var D = this.u.ste.childHasFree
        var z = this.newBlock("codeobj entry")
        this.u.prefixCode =
          "var " + c + "=(function " + this.niceName(b.v) + "$("
        var P = []
        if (a) {
          if (q)
            throw new SyntaxError(
              b.v + "(): keyword arguments in generators not supported",
            )
          if (r)
            throw new SyntaxError(
              b.v +
                "(): variable number of arguments in generators not supported",
            )
          P.push("$gen")
        } else {
          q && (P.push("$kwa"), this.u.tempsToSave.push("$kwa"))
          for (h = 0; d && h < d.args.length; ++h)
            P.push(this.nameop(d.args[h].arg, self.Sk.astnodes.Param))
          for (h = 0; d && d.kwonlyargs && h < d.kwonlyargs.length; ++h)
            P.push(this.nameop(d.kwonlyargs[h].arg, self.Sk.astnodes.Param))
          r && P.push(this.nameop(d.vararg.arg, self.Sk.astnodes.Param))
        }
        p && (P.push("$free"), this.u.tempsToSave.push("$free"))
        this.u.prefixCode += P.join(",")
        this.u.prefixCode += "){"
        a && (this.u.prefixCode += "\n// generator\n")
        p && (this.u.prefixCode += "\n// has free\n")
        D && (this.u.prefixCode += "\n// has cell\n")
        P = "{}"
        a && ((z = "$gen.gi$resumeat"), (P = "$gen.gi$locals"))
        h = ",$cell={}"
        D && a && (h = ",$cell=$gen.gi$cells")
        this.u.varDeclsCode +=
          "var $blk=" +
          z +
          ",$exc=[],$loc=" +
          P +
          h +
          ",$gbl=this,$err=undefined,$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;"
        null !== self.Sk.execLimit &&
          (this.u.varDeclsCode +=
            "if (typeof self.Sk.execStart === 'undefined') {self.Sk.execStart = Date.now()}")
        null !== self.Sk.yieldLimit &&
          this.u.canSuspend &&
          (this.u.varDeclsCode +=
            "if (typeof self.Sk.lastYield === 'undefined') {self.Sk.lastYield = Date.now()}")
        this.u.varDeclsCode +=
          "if (" +
          c +
          ".$wakingSuspension!==undefined) { $wakeFromSuspension(); } else {"
        if (a && 0 < n.length)
          for (D = d.args.length - n.length, h = 0; h < n.length; ++h)
            (z = this.nameop(d.args[h + D].arg, self.Sk.astnodes.Param)),
              (this.u.varDeclsCode +=
                "if(" +
                z +
                "===undefined)" +
                z +
                "=" +
                c +
                ".$defaults[" +
                h +
                "];")
        for (h = 0; d && h < d.args.length; ++h)
          (z = d.args[h].arg),
            this.isCell(z) &&
              (this.u.varDeclsCode += "$cell." + z.v + "=" + z.v + ";")
        for (h = 0; d && d.kwonlyargs && h < d.kwonlyargs.length; ++h)
          (z = d.kwonlyargs[h].arg),
            this.isCell(z) &&
              (this.u.varDeclsCode += "$cell." + z.v + "=" + z.v + ";")
        r &&
          this.isCell(r.arg) &&
          (this.u.varDeclsCode += "$cell." + r.arg.v + "=" + r.arg.v + ";")
        q &&
          (this.u.localnames.push(q.arg.v),
          (this.u.varDeclsCode += q.arg.v + "=new self.Sk.builtins['dict']($kwa);"),
          this.isCell(q.arg) &&
            (this.u.varDeclsCode += "$cell." + q.arg.v + "=" + q.arg.v + ";"))
        this.u.varDeclsCode += "}"
        self.Sk.python3 &&
          g &&
          (this.u.varDeclsCode += "$gbl.__class__=this." + g.v + ";")
        this.u.switchCode = "while(true){try{"
        this.u.switchCode += this.outputInterruptTest()
        this.u.switchCode += "switch($blk){"
        this.u.suffixCode =
          "} }catch(err){ if (!(err instanceof self.Sk.builtin.BaseException)) { err = new self.Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '" +
          this.filename +
          "'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});"
        e.call(this, c)
        if (d) {
          for (let a of d.args) k.push(a.arg.v)
          for (let a of d.kwonlyargs || []) k.push(a.arg.v)
          this.u.argnames = k
        }
        this.exitScope()
        0 < n.length && f(c, ".$defaults=[", n.join(","), "];")
        d &&
          d.kwonlyargs &&
          0 < d.kwonlyargs.length &&
          (f(c, ".co_argcount=", d.args.length, ";"),
          f(c, ".co_kwonlyargcount=", d.kwonlyargs.length, ";"),
          f(c, ".$kwdefs=[", m.join(","), "];"))
        0 < k.length
          ? f(c, ".co_varnames=['", k.join("','"), "'];")
          : f(c, ".co_varnames=[];")
        q && f(c, ".co_kwargs=1;")
        r && f(c, ".co_varargs=1;")
        e = ""
        p && ((e = ",$cell"), (g = this.u.ste.hasFree) && (e += ",$free"))
        if (a)
          return d && 0 < d.args.length
            ? this._gr(
                "gener",
                "new self.Sk.builtins['function']((function(){var $origargs=Array.prototype.slice.call(arguments);self.Sk.builtin.pyCheckArgsLen(\"",
                b.v,
                '",arguments.length,',
                d.args.length - n.length,
                ",",
                d.args.length,
                ");return new self.Sk.builtins['generator'](",
                c,
                ",$gbl,$origargs",
                e,
                ");}))",
              )
            : this._gr(
                "gener",
                "new self.Sk.builtins['function']((function(){self.Sk.builtin.pyCheckArgsLen(\"",
                b.v,
                "\",arguments.length,0,0);return new self.Sk.builtins['generator'](",
                c,
                ",$gbl,[]",
                e,
                ");}))",
              )
        if (0 < l.length) {
          f("$ret = new self.Sk.builtins['function'](", c, ",$gbl", e, ");")
          for (let a of l)
            f("$ret = self.Sk.misceval.callsimOrSuspendArray(", a, ",[$ret]);"),
              this._checkSuspension()
          return this._gr("funcobj", "$ret")
        }
        return this._gr(
          "funcobj",
          "new self.Sk.builtins['function'](",
          c,
          ",$gbl",
          e,
          ")",
        )
      }
      a.prototype.cfunction = function(a, b) {
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.FunctionDef)
        b = this.buildcodeobj(
          a,
          a.name,
          a.decorator_list,
          a.args,
          function(b) {
            this.vseqstmt(a.body)
            f("return self.Sk.builtin.none.none$;")
          },
          b,
        )
        this.nameop(a.name, self.Sk.astnodes.Store, b)
      }
      a.prototype.clambda = function(a) {
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.Lambda)
        return this.buildcodeobj(
          a,
          new self.Sk.builtin.str("<lambda>"),
          null,
          a.args,
          function(b) {
            b = this.vexpr(a.body)
            f("return ", b, ";")
          },
        )
      }
      a.prototype.cifexp = function(a) {
        var b = this.newBlock("next of ifexp"),
          c = this.newBlock("end of ifexp"),
          d = this._gr("res", "null"),
          e = this.vexpr(a.test)
        this._jumpfalse(e, b)
        f(d, "=", this.vexpr(a.body), ";")
        this._jump(c)
        this.setBlock(b)
        f(d, "=", this.vexpr(a.orelse), ";")
        this._jump(c)
        this.setBlock(c)
        return d
      }
      a.prototype.cgenexpgen = function(a, b, c) {
        var d = this.newBlock("start for " + b),
          e = this.newBlock("skip for " + b)
        this.newBlock("if cleanup for " + b)
        var g = this.newBlock("end for " + b),
          k = a[b]
        if (0 === b) var h = "$loc.$iter0"
        else {
          var l = this.vexpr(k.iter)
          h = "$loc." + this.gensym("iter")
          f(h, "=", "Sk.abstr.iter(", l, ");")
        }
        this._jump(d)
        this.setBlock(d)
        this.annotateSource(c)
        f(
          "$ret = self.Sk.abstr.iternext(",
          h,
          this.u.canSuspend ? ", true" : ", false",
          ");",
        )
        this._checkSuspension(c)
        l = this._gr("next", "$ret")
        this._jumpundef(l, g)
        this.vexpr(k.target, l)
        var m = k.ifs ? k.ifs.length : 0
        for (h = 0; h < m; ++h)
          this.annotateSource(k.ifs[h]),
            (l = this.vexpr(k.ifs[h])),
            this._jumpfalse(l, d)
        ++b < a.length && this.cgenexpgen(a, b, c)
        b >= a.length &&
          (this.annotateSource(c),
          (a = this.vexpr(c)),
          f("return [", e, "/*resume*/,", a, "/*ret*/];"),
          this.setBlock(e))
        this._jump(d)
        this.setBlock(g)
        1 === b && f("return self.Sk.builtin.none.none$;")
      }
      a.prototype.cgenexp = function(a) {
        var b = this.buildcodeobj(
          a,
          new self.Sk.builtin.str("<genexpr>"),
          null,
          null,
          function(b) {
            this.cgenexpgen(a.generators, 0, a.elt)
          },
        )
        b = this._gr("gener", "Sk.misceval.callsimArray(", b, ");")
        f(
          b,
          ".gi$locals.$iter0=self.Sk.abstr.iter(",
          this.vexpr(a.generators[0].iter),
          ");",
        )
        return b
      }
      a.prototype.cclass = function(a) {
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.ClassDef)
        var b = this.vseqexpr(a.decorator_list)
        var c = this.vseqexpr(a.bases)
        var d = this.enterScope(a.name, a, a.lineno)
        var e = this.newBlock("class entry")
        this.u.prefixCode =
          "var " +
          d +
          "=(function $" +
          a.name.v +
          "$class_outer($globals,$locals,$cell){var $gbl=$globals,$loc=$locals;$free=$globals;"
        this.u.switchCode += "(function $" + a.name.v + "$_closure($cell){"
        this.u.switchCode +=
          "var $blk=" +
          e +
          ",$exc=[],$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;"
        null !== self.Sk.execLimit &&
          (this.u.switchCode +=
            "if (typeof self.Sk.execStart === 'undefined') {self.Sk.execStart = Date.now()}")
        null !== self.Sk.yieldLimit &&
          this.u.canSuspend &&
          (this.u.switchCode +=
            "if (typeof self.Sk.lastYield === 'undefined') {self.Sk.lastYield = Date.now()}")
        this.u.switchCode += "while(true){try{"
        this.u.switchCode += this.outputInterruptTest()
        this.u.switchCode += "switch($blk){"
        this.u.suffixCode =
          "}}catch(err){ if (!(err instanceof self.Sk.builtin.BaseException)) { err = new self.Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '" +
          this.filename +
          "'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }}}"
        this.u.suffixCode += "}).call(null, $cell);});"
        this.u.private_ = a.name
        this.cbody(a.body, a.name)
        f("return;")
        this.exitScope()
        f(
          "$ret = self.Sk.misceval.buildClass($gbl,",
          d,
          ",",
          a.name.$r().v,
          ",[",
          c,
          "], $cell);",
        )
        for (let a of b)
          f("$ret = self.Sk.misceval.callsimOrSuspendArray(", a, ", [$ret]);"),
            this._checkSuspension()
        this.nameop(a.name, self.Sk.astnodes.Store, "$ret")
      }
      a.prototype.ccontinue = function(a) {
        a = this.peekFinallyBlock()
        if (0 == this.u.continueBlocks.length)
          throw new SyntaxError("'continue' outside loop")
        var b = this.u.continueBlocks[this.u.continueBlocks.length - 1]
        self.Sk.asserts.assert(
          this.u.breakBlocks.length === this.u.continueBlocks.length,
        )
        a && a.breakDepth == this.u.continueBlocks.length
          ? f("$postfinally={isBreak:true,gotoBlock:", b, "};")
          : this._jump(b)
      }
      a.prototype.cbreak = function(a) {
        a = this.peekFinallyBlock()
        if (0 === this.u.breakBlocks.length)
          throw new SyntaxError("'break' outside loop")
        var b = this.u.breakBlocks[this.u.breakBlocks.length - 1]
        a && a.breakDepth == this.u.breakBlocks.length
          ? f("$postfinally={isBreak:true,gotoBlock:", b, "};")
          : this._jump(b)
      }
      a.prototype.vstmt = function(a, b) {
        this.u.lineno = a.lineno
        this.u.linenoSet = !1
        this.u.localtemps = []
        if (self.Sk.debugging && this.u.canSuspend) {
          var c = this.newBlock("debug breakpoint for line " + a.lineno)
          f(
            "if (self.Sk.breakpoints('" +
              this.filename +
              "'," +
              a.lineno +
              "," +
              a.col_offset +
              ")) {",
            "var $susp = $saveSuspension({data: {type: 'self.Sk.debug'}, resume: function() {}}, '" +
              this.filename +
              "'," +
              a.lineno +
              "," +
              a.col_offset +
              ");",
            "$susp.$blk = " + c + ";",
            "$susp.optional = true;",
            "return $susp;",
            "}",
          )
          this._jump(c)
          this.setBlock(c)
          this.u.doesSuspend = !0
        }
        this.annotateSource(a)
        switch (a.constructor) {
          case self.Sk.astnodes.FunctionDef:
            this.cfunction(a, b)
            break
          case self.Sk.astnodes.ClassDef:
            this.cclass(a)
            break
          case self.Sk.astnodes.Return:
            if (this.u.ste.blockType !== self.Sk.SYMTAB_CONSTS.FunctionBlock)
              throw new SyntaxError("'return' outside function")
            c = a.value ? this.vexpr(a.value) : "Sk.builtin.none.none$"
            0 == this.u.finallyBlocks.length
              ? f("return ", c, ";")
              : (f("$postfinally={returning:", c, "};"),
                this._jump(this.peekFinallyBlock().blk))
            break
          case self.Sk.astnodes.Delete:
            this.vseqexpr(a.targets)
            break
          case self.Sk.astnodes.Assign:
            var d = a.targets.length
            c = this.vexpr(a.value)
            for (b = 0; b < d; ++b) this.vexpr(a.targets[b], c)
            break
          case self.Sk.astnodes.AnnAssign:
            c = this.vexpr(a.value)
            this.vexpr(a.target, c)
            this.vexpr(a.annotation)
            break
          case self.Sk.astnodes.AugAssign:
            return this.caugassign(a)
          case self.Sk.astnodes.Print:
            this.cprint(a)
            break
          case self.Sk.astnodes.For:
            return this.cfor(a)
          case self.Sk.astnodes.While:
            return this.cwhile(a)
          case self.Sk.astnodes.If:
            return this.cif(a)
          case self.Sk.astnodes.Raise:
            return this.craise(a)
          case self.Sk.astnodes.Try:
            return this.ctry(a)
          case self.Sk.astnodes.With:
            return this.cwith(a, 0)
          case self.Sk.astnodes.Assert:
            return this.cassert(a)
          case self.Sk.astnodes.Import:
            return this.cimport(a)
          case self.Sk.astnodes.ImportFrom:
            return this.cfromimport(a)
          case self.Sk.astnodes.Global:
            break
          case self.Sk.astnodes.Expr:
            this.vexpr(a.value)
            break
          case self.Sk.astnodes.Pass:
            break
          case self.Sk.astnodes.Break:
            this.cbreak(a)
            break
          case self.Sk.astnodes.Continue:
            this.ccontinue(a)
            break
          case self.Sk.astnodes.Debugger:
            f("debugger;")
            break
          default:
            self.Sk.asserts.fail("unhandled case in vstmt: " + JSON.stringify(a))
        }
      }
      a.prototype.vseqstmt = function(a) {
        var b
        for (b = 0; b < a.length; ++b) this.vstmt(a[b])
      }
      a.prototype.isCell = function(a) {
        a = e(this.u.private_, a).v
        return this.u.ste.getScope(a) === self.Sk.SYMTAB_CONSTS.CELL
      }
      a.prototype.nameop = function(a, b, g) {
        if (
          (b === self.Sk.astnodes.Store ||
            b === self.Sk.astnodes.AugStore ||
            b === self.Sk.astnodes.Del) &&
          "__debug__" === a.v
        )
          throw new self.Sk.builtin.SyntaxError("can not assign to __debug__")
        self.Sk.asserts.assert("None" !== a.v)
        if ("NotImplemented" === a.v)
          return "Sk.builtin.NotImplemented.NotImplemented$"
        var k = e(this.u.private_, a).v
        k = d(k)
        var h = 3
        var l = this.u.ste.getScope(k)
        var m = null
        switch (l) {
          case self.Sk.SYMTAB_CONSTS.FREE:
            m = "$free"
            h = 2
            break
          case self.Sk.SYMTAB_CONSTS.CELL:
            m = "$cell"
            h = 2
            break
          case self.Sk.SYMTAB_CONSTS.LOCAL:
            this.u.ste.blockType !== self.Sk.SYMTAB_CONSTS.FunctionBlock ||
              this.u.ste.generator ||
              (h = 0)
            break
          case self.Sk.SYMTAB_CONSTS.GLOBAL_IMPLICIT:
            this.u.ste.blockType === self.Sk.SYMTAB_CONSTS.FunctionBlock && (h = 1)
            break
          case self.Sk.SYMTAB_CONSTS.GLOBAL_EXPLICIT:
            h = 1
        }
        k = c(k)
        self.Sk.asserts.assert(l || "_" === a.v.charAt(1))
        a = k
        this.u.ste.generator ||
        this.u.ste.blockType !== self.Sk.SYMTAB_CONSTS.FunctionBlock
          ? (k = "$loc." + k)
          : (0 === h || 3 === h) && this.u.localnames.push(k)
        switch (h) {
          case 0:
            switch (b) {
              case self.Sk.astnodes.Load:
              case self.Sk.astnodes.Param:
                return (
                  f(
                    "if (",
                    k,
                    " === undefined) { throw new self.Sk.builtin.UnboundLocalError('local variable \\'",
                    k,
                    "\\' referenced before assignment'); }\n",
                  ),
                  k
                )
              case self.Sk.astnodes.Store:
                f(k, "=", g, ";")
                break
              case self.Sk.astnodes.Del:
                f("delete ", k, ";")
                break
              default:
                self.Sk.asserts.fail("unhandled")
            }
            break
          case 3:
            switch (b) {
              case self.Sk.astnodes.Load:
                return this._gr(
                  "loadname",
                  k,
                  "!==undefined?",
                  k,
                  ":self.Sk.misceval.loadname('",
                  a,
                  "',$gbl);",
                )
              case self.Sk.astnodes.Store:
                f(k, "=", g, ";")
                break
              case self.Sk.astnodes.Del:
                f("delete ", k, ";")
                break
              case self.Sk.astnodes.Param:
                return k
              default:
                self.Sk.asserts.fail("unhandled")
            }
            break
          case 1:
            switch (b) {
              case self.Sk.astnodes.Load:
                return this._gr(
                  "loadgbl",
                  "Sk.misceval.loadname('",
                  a,
                  "',$gbl)",
                )
              case self.Sk.astnodes.Store:
                f("$gbl.", a, "=", g, ";")
                break
              case self.Sk.astnodes.Del:
                f("delete $gbl.", a)
                break
              default:
                self.Sk.asserts.fail("unhandled case in name op_global")
            }
            break
          case 2:
            switch (b) {
              case self.Sk.astnodes.Load:
                return m + "." + a
              case self.Sk.astnodes.Store:
                f(m, ".", a, "=", g, ";")
                break
              case self.Sk.astnodes.Param:
                return a
              default:
                self.Sk.asserts.fail("unhandled case in name op_deref")
            }
            break
          default:
            self.Sk.asserts.fail("unhandled case")
        }
      }
      a.prototype.enterScope = function(a, c, d, e) {
        var f = new b()
        f.ste = this.st.getStsForAst(c)
        f.name = a
        f.firstlineno = d
        f.canSuspend = e || !1
        this.u && this.u.private_ && (f.private_ = this.u.private_)
        this.stack.push(this.u)
        this.allUnits.push(f)
        a = this.gensym("scope")
        f.scopename = a
        this.u = f
        this.u.activateScope()
        this.nestlevel++
        return a
      }
      a.prototype.exitScope = function() {
        var a = this.u
        this.nestlevel--
        ;(this.u = 0 <= this.stack.length - 1 ? this.stack.pop() : null) &&
          this.u.activateScope()
        if ("<module>" !== a.name.v) {
          var b = a.name.$r().v
          b = b.substring(1, b.length - 1)
          b = c(b)
          b = d(b)
          f(a.scopename, ".co_name=new self.Sk.builtins['str']('", b, "');")
        }
        for (var e in a.consts)
          a.consts.hasOwnProperty(e) &&
            (a.suffixCode += e + " = " + a.consts[e] + ";")
      }
      a.prototype.cbody = function(a, b) {
        var c
        for (c = 0; c < a.length; ++c) this.vstmt(a[c], b)
      }
      a.prototype.cprint = function(a) {
        var b
        self.Sk.asserts.assert(a instanceof self.Sk.astnodes.Print)
        a.dest && this.vexpr(a.dest)
        var c = a.values.length
        for (b = 0; b < c; ++b)
          f(
            "$ret = self.Sk.misceval.print_(",
            "new self.Sk.builtins['str'](",
            this.vexpr(a.values[b]),
            ").v);",
          ),
            this._checkSuspension(a)
        a.nl &&
          (f("$ret = self.Sk.misceval.print_(", '"\\n");'), this._checkSuspension(a))
      }
      a.prototype.cmod = function(a) {
        var b = this.enterScope(
            new self.Sk.builtin.str("<module>"),
            a,
            0,
            this.canSuspend,
          ),
          c = this.newBlock("module entry")
        this.u.prefixCode = "var " + b + "=(function($forcegbl){"
        this.u.varDeclsCode =
          "var $gbl = $forcegbl || {}, $blk=" +
          c +
          ",$exc=[],$loc=$gbl,$cell={},$err=undefined;$loc.__file__=new self.Sk.builtins.str('" +
          this.filename +
          "');var $ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;"
        null !== self.Sk.execLimit &&
          (this.u.varDeclsCode +=
            "if (typeof self.Sk.execStart === 'undefined') {self.Sk.execStart = Date.now()}")
        null !== self.Sk.yieldLimit &&
          this.u.canSuspend &&
          (this.u.varDeclsCode +=
            "if (typeof self.Sk.lastYield === 'undefined') {self.Sk.lastYield = Date.now()}")
        this.u.varDeclsCode +=
          "if (" +
          b +
          ".$wakingSuspension!==undefined) { $wakeFromSuspension(); }if (self.Sk.retainGlobals) {    if (self.Sk.globals) { $gbl = self.Sk.globals; self.Sk.globals = $gbl; $loc = $gbl; }    if (self.Sk.globals) { $gbl = self.Sk.globals; self.Sk.globals = $gbl; $loc = $gbl; $loc.__file__=new self.Sk.builtins.str('" +
          this.filename +
          "');}    else { self.Sk.globals = $gbl; }} else { self.Sk.globals = $gbl; }"
        this.u.switchCode = "while(true){try{"
        this.u.switchCode += this.outputInterruptTest()
        this.u.switchCode += "switch($blk){"
        this.u.suffixCode = "}"
        this.u.suffixCode +=
          "}catch(err){ if (!(err instanceof self.Sk.builtin.BaseException)) { err = new self.Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '" +
          this.filename +
          "'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } });"
        switch (a.constructor) {
          case self.Sk.astnodes.Module:
            this.cbody(a.body)
            f("return $loc;")
            break
          default:
            self.Sk.asserts.fail("todo; unhandled case in compilerMod")
        }
        this.exitScope()
        this.result.push(this.outputAllUnits())
        return b
      }
      self.Sk.compile = function(b, c, d, e) {
        d = self.Sk.__future__
        self.Sk.__future__ = Object.create(self.Sk.__future__)
        var f = self.Sk.parse(c, b),
          g = self.Sk.astFromParse(f.cst, c, f.flags)
        f = f.flags
        var h = self.Sk.symboltable(g, c)
        b = new a(c, h, f, e, b)
        c = b.cmod(g)
        self.Sk.__future__ = d
        return {
          funcname: "$compiledmod",
          code:
            "$compiledmod = function() {" +
            b.result.join("") +
            "\nreturn " +
            c +
            ";}();",
        }
      }
      self.Sk.exportSymbol("Sk.compile", self.Sk.compile)
      self.Sk.resetCompiler = function() {
        self.Sk.gensymcount = 0
      }
      self.Sk.exportSymbol("Sk.resetCompiler", self.Sk.resetCompiler)
      self.Sk.fixReservedWords = c
      self.Sk.exportSymbol("Sk.fixReservedWords", self.Sk.fixReservedWords)
      self.Sk.fixReservedNames = d
      self.Sk.exportSymbol("Sk.fixReservedNames", self.Sk.fixReservedNames)
      self.Sk.unfixReserved = function(a) {
        return a.replace(/_\$r[wn]\$$/, "")
      }
      self.Sk.exportSymbol("Sk.unfixReserved", self.Sk.unfixReserved)
      self.Sk.mangleName = e
      self.Sk.exportSymbol("Sk.mangleName", self.Sk.mangleName)
    },
    function(m, p) {
      self.Sk.sysmodules = new self.Sk.builtin.dict([])
      self.Sk.realsyspath = void 0
      self.Sk.importSearchPathForName = function(a, b, c) {
        var d = a.replace(/\./g, "/"),
          e = function(a, b) {
            return self.Sk.misceval.chain(
              self.Sk.misceval.tryCatch(
                function() {
                  return self.Sk.read(a)
                },
                function(a) {},
              ),
              function(c) {
                if (void 0 !== c)
                  return new self.Sk.misceval.Break({
                    filename: a,
                    code: c,
                    packagePath: b,
                  })
              },
            )
          }
        void 0 === c && (c = self.Sk.realsyspath)
        return self.Sk.misceval.iterFor(c.tp$iter(), function(a) {
          return self.Sk.misceval.chain(e(a.v + "/" + d + b, !1), function(c) {
            return c ? c : e(a.v + "/" + d + "/__init__" + b, a.v + "/" + d)
          })
        })
      }
      self.Sk.doOneTimeInitialization = function(a) {
        var b
        self.Sk.builtin.type.basesStr_ = new self.Sk.builtin.str("__bases__")
        self.Sk.builtin.type.mroStr_ = new self.Sk.builtin.str("__mro__")
        for (f in self.Sk.builtin)
          if (
            ((a = self.Sk.builtin[f]),
            (a.prototype instanceof self.Sk.builtin.object ||
              a === self.Sk.builtin.object) &&
              !a.sk$abstract)
          ) {
            var c = a
            var d = []
            for (a = c.tp$base; void 0 !== a; a = a.tp$base) d.push(a)
            c.tp$mro = new self.Sk.builtin.tuple([c])
            c.tp$base || (c.tp$base = d[0])
            c.$d = new self.Sk.builtin.dict([])
            c.$d.mp$ass_subscript(
              self.Sk.builtin.type.basesStr_,
              new self.Sk.builtin.tuple(d),
            )
            c.$d.mp$ass_subscript(self.Sk.builtin.type.mroStr_, c.tp$mro)
          }
        d = [
          self.Sk.builtin.object,
          self.Sk.builtin.type,
          self.Sk.builtin.func,
          self.Sk.builtin.method,
        ]
        for (c = 0; c < d.length; c++) {
          var e = d[c]
          var f = e.prototype
          for (b = 0; b < e.pythonFunctions.length; b++) {
            a = e.pythonFunctions[b]
            if (f[a] instanceof self.Sk.builtin.func) break
            f[a].co_kwargs = null
            f[a] = new self.Sk.builtin.func(f[a])
          }
        }
        for (var g in self.Sk.internalPy.files)
          (f = g.split(".")[0].split("/")[1]),
            (a = self.Sk.importBuiltinWithBody(f, !1, self.Sk.internalPy.files[g], !0)),
            (a = self.Sk.misceval.retryOptionalSuspensionOrThrow(a)),
            self.Sk.asserts.assert(
              void 0 !== a.$d[f],
              "Should have imported name " + f,
            ),
            (self.Sk.builtins[f] = a.$d[f])
      }
      self.Sk.importSetUpPath = function(a) {
        var b
        if (!self.Sk.realsyspath) {
          var c = [
            new self.Sk.builtin.str("src/builtin"),
            new self.Sk.builtin.str("src/lib"),
            new self.Sk.builtin.str("."),
          ]
          for (b = 0; b < self.Sk.syspath.length; ++b)
            c.push(new self.Sk.builtin.str(self.Sk.syspath[b]))
          self.Sk.realsyspath = new self.Sk.builtin.list(c)
          self.Sk.doOneTimeInitialization(a)
        }
      }
      self.Sk.importModuleInternal_ = function(a, b, c, d, e, f, g) {
        var h,
          k,
          l,
          m = null,
          n = void 0 !== e ? e.tp$getattr(self.Sk.builtin.str.$name) : void 0,
          p = void 0 !== n ? n.v + "." : "",
          D = void 0 !== e ? e.tp$getattr(self.Sk.builtin.str.$path) : void 0
        self.Sk.importSetUpPath(g)
        if (e && !n) {
          if (f) return
          throw new self.Sk.builtin.ValueError(
            "Attempted to import relative to invalid package (no name)",
          )
        }
        void 0 === c && (c = p + a)
        var x = a.split(".")
        try {
          var H = self.Sk.sysmodules.mp$subscript(c)
          return 1 < x.length ? self.Sk.sysmodules.mp$subscript(p + x[0]) : H
        } catch (A) {}
        if (1 < x.length) {
          var J = x.slice(0, x.length - 1).join(".")
          m = self.Sk.importModuleInternal_(J, b, void 0, void 0, e, f, g)
        }
        H = self.Sk.misceval.chain(
          m,
          function(b) {
            var c = a
            m = b
            if (1 < x.length) {
              if (!m) return
              k = self.Sk.sysmodules.mp$subscript(p + J)
              c = x[x.length - 1]
              D = k.tp$getattr(self.Sk.builtin.str.$path)
            }
            l = new self.Sk.builtin.module()
            d
              ? ((h = a + ".py"), (b = self.Sk.compile(d, h, "exec", g)))
              : (b = self.Sk.misceval.chain(
                  void 0,
                  function() {
                    if (
                      self.Sk.onBeforeImport &&
                      "function" === typeof self.Sk.onBeforeImport
                    )
                      return self.Sk.onBeforeImport(a)
                  },
                  function(b) {
                    if (!1 === b)
                      throw new self.Sk.builtin.ImportError(
                        "Importing " + a + " is not allowed",
                      )
                    if ("string" === typeof b)
                      throw new self.Sk.builtin.ImportError(b)
                    return self.Sk.importSearchPathForName(c, ".js", D)
                  },
                  function(a) {
                    return a
                      ? {
                          funcname: "$builtinmodule",
                          code: a.code,
                          filename: a.filename,
                          packagePath: a.packagePath,
                        }
                      : self.Sk.misceval.chain(
                          self.Sk.importSearchPathForName(c, ".py", D),
                          function(b) {
                            if ((a = b))
                              return self.Sk.compile(a.code, a.filename, "exec", g)
                          },
                          function(b) {
                            if (b) return (b.packagePath = a.packagePath), b
                          },
                        )
                  },
                ))
            return b
          },
          function(a) {
            if (a) {
              self.Sk.sysmodules.mp$ass_subscript(c, l)
              var d = (l.$js = a.code)
              null == h && (h = a.filename)
              ;(null != self.Sk.dateSet && self.Sk.dateSet) ||
                ((d = "Sk.execStart = self.Sk.lastYield = new Date();\n" + a.code),
                (self.Sk.dateSet = !0))
              if (b) {
                var e = function(a) {
                  var b,
                    c = self.Sk.js_beautify(a).split("\n")
                  for (b = 1; b <= c.length; ++b) {
                    var d = ("" + b).length
                    for (a = ""; 5 > d; ++d) a += " "
                    c[b - 1] = "/* " + a + b + " */ " + c[b - 1]
                  }
                  return c.join("\n")
                }
                d = e(d)
                self.Sk.debugout(d)
              }
              d += "\n" + a.funcname + ";"
              d = self.Sk.global.eval(d)
              l.$d = {
                __name__: new self.Sk.builtin.str(c),
                __doc__: self.Sk.builtin.none.none$,
                __package__: a.packagePath
                  ? new self.Sk.builtin.str(c)
                  : J
                  ? new self.Sk.builtin.str(p + J)
                  : n
                  ? n
                  : self.Sk.builtin.none.none$,
              }
              a.packagePath &&
                (l.$d.__path__ = new self.Sk.builtin.tuple([
                  new self.Sk.builtin.str(a.packagePath),
                ]))
              return d(l.$d)
            }
          },
          function(b) {
            var c
            if (void 0 === b) {
              if (f && !m) return
              throw new self.Sk.builtin.ImportError("No module named " + a)
            }
            if (b !== l.$d) {
              for (c in l.$d) b[c] || (b[c] = l.$d[c])
              l.$d = b
            }
            if (self.Sk.onAfterImport && "function" === typeof self.Sk.onAfterImport)
              try {
                self.Sk.onAfterImport(a)
              } catch (K) {}
            if (m)
              return k.tp$setattr(new self.Sk.builtin.str(x[x.length - 1]), l), m
            e && e.tp$setattr(new self.Sk.builtin.str(a), l)
            return l
          },
        )
        return g ? H : self.Sk.misceval.retryOptionalSuspensionOrThrow(H)
      }
      self.Sk.importModule = function(a, b, c) {
        return self.Sk.importModuleInternal_(a, b, void 0, void 0, void 0, !1, c)
      }
      self.Sk.importMain = function(a, b, c) {
        self.Sk.dateSet = !1
        self.Sk.filesLoaded = !1
        self.Sk.sysmodules = new self.Sk.builtin.dict([])
        self.Sk.realsyspath = void 0
        self.Sk.resetCompiler()
        return self.Sk.importModuleInternal_(a, b, "__main__", void 0, void 0, !1, c)
      }
      self.Sk.importMainWithBody = function(a, b, c, d) {
        self.Sk.dateSet = !1
        self.Sk.filesLoaded = !1
        self.Sk.sysmodules = new self.Sk.builtin.dict([])
        self.Sk.realsyspath = void 0
        self.Sk.resetCompiler()
        return self.Sk.importModuleInternal_(a, b, "__main__", c, void 0, !1, d)
      }
      self.Sk.importBuiltinWithBody = function(a, b, c, d) {
        return self.Sk.importModuleInternal_(
          a,
          b,
          "__builtin__." + a,
          c,
          void 0,
          !1,
          d,
        )
      }
      self.Sk.builtin.__import__ = function(a, b, c, d, e) {
        var f = self.Sk.globals,
          g
        void 0 === e && (e = self.Sk.__future__.absolute_import ? 0 : -1)
        if (
          0 !== e &&
          b.__package__ &&
          b.__package__ !== self.Sk.builtin.none.none$
        ) {
          if ((g = b.__package__.v) && 0 < e) {
            b = g.split(".")
            if (e - 1 >= b.length)
              throw new self.Sk.builtin.ValueError(
                "Attempted relative import beyond toplevel package",
              )
            b.length -= e - 1
            g = b.join(".")
          }
          try {
            var h = self.Sk.sysmodules.mp$subscript(g)
          } catch (k) {
            g = void 0
          }
        }
        if (0 < e && void 0 === h)
          throw new self.Sk.builtin.ValueError(
            "Attempted relative import in non-package",
          )
        a.split(".")
        return self.Sk.misceval.chain(
          void 0,
          function() {
            if (0 !== e && void 0 !== h)
              return "" === a
                ? h
                : self.Sk.importModuleInternal_(
                    a,
                    void 0,
                    g + "." + a,
                    void 0,
                    h,
                    -1 == e,
                    !0,
                  )
          },
          function(b) {
            return void 0 === b
              ? ((g = h = void 0),
                self.Sk.importModuleInternal_(
                  a,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  !1,
                  !0,
                ))
              : b
          },
          function(b) {
            if (d && 0 !== d.length) {
              var c
              var e = self.Sk.sysmodules.mp$subscript(
                (g || "") + (g && a ? "." : "") + a,
              )
              for (b = 0; b < d.length; b++) {
                var f = d[b]
                "*" != f &&
                  void 0 === e.tp$getattr(new self.Sk.builtin.str(f)) &&
                  (c = self.Sk.misceval.chain(
                    c,
                    self.Sk.importModuleInternal_.bind(
                      null,
                      f,
                      void 0,
                      void 0,
                      void 0,
                      e,
                      !0,
                      !0,
                    ),
                  ))
              }
              return self.Sk.misceval.chain(c, function() {
                self.Sk.asserts.assert(e)
                return e
              })
            }
            return b
          },
          function(a) {
            f !== self.Sk.globals && (self.Sk.globals = f)
            return a
          },
        )
      }
      self.Sk.importStar = function(a, b, c) {
        if ((c = a.tp$getattr(new self.Sk.builtin.str("__all__"))))
          for (
            let d = self.Sk.abstr.iter(c), e = d.tp$iternext();
            void 0 !== e;
            e = d.tp$iternext()
          )
            b[e.v] = self.Sk.abstr.gattr(a, e)
        else {
          c = Object.getOwnPropertyNames(a.$d)
          for (let d in c) "_" != c[d].charAt(0) && (b[c[d]] = a.$d[c[d]])
        }
      }
      self.Sk.exportSymbol("Sk.importMain", self.Sk.importMain)
      self.Sk.exportSymbol("Sk.importMainWithBody", self.Sk.importMainWithBody)
      self.Sk.exportSymbol("Sk.importBuiltinWithBody", self.Sk.importBuiltinWithBody)
      self.Sk.exportSymbol("Sk.builtin.__import__", self.Sk.builtin.__import__)
      self.Sk.exportSymbol("Sk.importStar", self.Sk.importStar)
    },
    function(m, p) {
      self.Sk.builtin.timSort = function(a, b) {
        this.list = new self.Sk.builtin.list(a.v)
        this.MIN_GALLOP = 7
        this.listlength = b ? b : a.sq$length()
      }
      self.Sk.builtin.timSort.prototype.lt = function(a, b) {
        return self.Sk.misceval.richCompareBool(a, b, "Lt")
      }
      self.Sk.builtin.timSort.prototype.le = function(a, b) {
        return !this.lt(b, a)
      }
      self.Sk.builtin.timSort.prototype.setitem = function(a, b) {
        this.list.v[a] = b
      }
      self.Sk.builtin.timSort.prototype.binary_sort = function(a, b) {
        var c
        for (c = a.base + b; c < a.base + a.len; c++) {
          var d = a.base
          var e = c
          for (b = a.getitem(e); d < e; ) {
            var f = d + ((e - d) >> 1)
            this.lt(b, a.getitem(f)) ? (e = f) : (d = f + 1)
          }
          self.Sk.asserts.assert(d === e)
          for (f = c; f > d; f--) a.setitem(f, a.getitem(f - 1))
          a.setitem(d, b)
        }
      }
      self.Sk.builtin.timSort.prototype.count_run = function(a) {
        var b
        if (1 >= a.len) {
          var c = a.len
          var d = !1
        } else if (((c = 2), this.lt(a.getitem(a.base + 1), a.getitem(a.base))))
          for (d = !0, b = a.base + 2; b < a.base + a.len; b++)
            if (this.lt(a.getitem(b), a.getitem(b - 1))) c++
            else break
        else
          for (
            d = !1, b = a.base + 2;
            b < a.base + a.len && !this.lt(a.getitem(b), a.getitem(b - 1));
            b++
          )
            c++
        return {
          run: new self.Sk.builtin.listSlice(a.list, a.base, c),
          descending: d,
        }
      }
      self.Sk.builtin.timSort.prototype.sort = function() {
        var a,
          b = new self.Sk.builtin.listSlice(this.list, 0, this.listlength)
        if (!(2 > b.len)) {
          this.merge_init()
          for (a = this.merge_compute_minrun(b.len); 0 < b.len; ) {
            var c = this.count_run(b)
            c.descending && c.run.reverse()
            if (c.run.len < a) {
              var d = c.run.len
              c.run.len = a < b.len ? a : b.len
              this.binary_sort(c.run, d)
            }
            b.advance(c.run.len)
            this.pending.push(c.run)
            this.merge_collapse()
          }
          self.Sk.asserts.assert(b.base == this.listlength)
          this.merge_force_collapse()
          self.Sk.asserts.assert(1 == this.pending.length)
          self.Sk.asserts.assert(0 === this.pending[0].base)
          self.Sk.asserts.assert(this.pending[0].len == this.listlength)
        }
      }
      self.Sk.builtin.timSort.prototype.gallop = function(a, b, c, d) {
        var e
        self.Sk.asserts.assert(0 <= c && c < b.len)
        var f = this
        d = d
          ? function(a, b) {
              return f.le(a, b)
            }
          : function(a, b) {
              return f.lt(a, b)
            }
        var g = b.base + c
        var h = 0
        var k = 1
        if (d(b.getitem(g), a)) {
          for (e = b.len - c; k < e; )
            if (d(b.getitem(g + k), a)) {
              h = k
              try {
                k = (k << 1) + 1
              } catch (l) {
                k = e
              }
            } else break
          k > e && (k = e)
          h += c
          k += c
        } else {
          for (e = c + 1; k < e && !d(b.getitem(g - k), a); ) {
            h = k
            try {
              k = (k << 1) + 1
            } catch (l) {
              k = e
            }
          }
          k > e && (k = e)
          g = c - h
          h = c - k
          k = g
        }
        self.Sk.asserts.assert(-1 <= h < k <= b.len)
        for (h += 1; h < k; )
          (c = h + ((k - h) >> 1)),
            d(b.getitem(b.base + c), a) ? (h = c + 1) : (k = c)
        self.Sk.asserts.assert(h == k)
        return k
      }
      self.Sk.builtin.timSort.prototype.merge_init = function() {
        this.min_gallop = this.MIN_GALLOP
        this.pending = []
      }
      self.Sk.builtin.timSort.prototype.merge_lo = function(a, b) {
        var c, d, e
        self.Sk.asserts.assert(0 < a.len && 0 < b.len && a.base + a.len == b.base)
        var f = this.min_gallop
        var g = a.base
        a = a.copyitems()
        try {
          if ((this.setitem(g, b.popleft()), g++, 1 != a.len && 0 !== b.len))
            for (;;) {
              for (d = c = 0; ; )
                if (this.lt(b.getitem(b.base), a.getitem(a.base))) {
                  this.setitem(g, b.popleft())
                  g++
                  if (0 === b.len) return
                  d++
                  c = 0
                  if (d >= f) break
                } else {
                  this.setitem(g, a.popleft())
                  g++
                  if (1 == a.len) return
                  c++
                  d = 0
                  if (c >= f) break
                }
              for (f += 1; ; ) {
                this.min_gallop = f -= 1 < f
                c = this.gallop(b.getitem(b.base), a, 0, !0)
                for (e = a.base; e < a.base + c; e++)
                  this.setitem(g, a.getitem(e)), g++
                a.advance(c)
                if (1 >= a.len) return
                this.setitem(g, b.popleft())
                g++
                if (0 === b.len) return
                d = this.gallop(a.getitem(a.base), b, 0, !1)
                for (e = b.base; e < b.base + d; e++)
                  this.setitem(g, b.getitem(e)), g++
                b.advance(d)
                if (0 === b.len) return
                this.setitem(g, a.popleft())
                g++
                if (1 == a.len) return
                if (c < this.MIN_GALLOP && d < this.MIN_GALLOP) break
                f++
                this.min_gallop = f
              }
            }
        } finally {
          self.Sk.asserts.assert(0 <= a.len && 0 <= b.len)
          for (e = b.base; e < b.base + b.len; e++)
            this.setitem(g, b.getitem(e)), g++
          for (e = a.base; e < a.base + a.len; e++)
            this.setitem(g, a.getitem(e)), g++
        }
      }
      self.Sk.builtin.timSort.prototype.merge_hi = function(a, b) {
        var c, d, e
        self.Sk.asserts.assert(0 < a.len && 0 < b.len && a.base + a.len == b.base)
        var f = this.min_gallop
        var g = b.base + b.len
        b = b.copyitems()
        try {
          if ((g--, this.setitem(g, a.popright()), 0 !== a.len && 1 != b.len))
            for (;;) {
              for (d = c = 0; ; ) {
                var h = a.getitem(a.base + a.len - 1)
                var k = b.getitem(b.base + b.len - 1)
                if (this.lt(k, h)) {
                  g--
                  this.setitem(g, h)
                  a.len--
                  if (0 === a.len) return
                  c++
                  d = 0
                  if (c >= f) break
                } else {
                  g--
                  this.setitem(g, k)
                  b.len--
                  if (1 == b.len) return
                  d++
                  c = 0
                  if (d >= f) break
                }
              }
              for (f += 1; ; ) {
                this.min_gallop = f -= 1 < f
                k = b.getitem(b.base + b.len - 1)
                var l = this.gallop(k, a, a.len - 1, !0)
                c = a.len - l
                for (e = a.base + a.len - 1; e > a.base + l - 1; e--)
                  g--, this.setitem(g, a.getitem(e))
                a.len -= c
                if (0 === a.len) return
                g--
                this.setitem(g, b.popright())
                if (1 == b.len) return
                h = a.getitem(a.base + a.len - 1)
                l = this.gallop(h, b, b.len - 1, !1)
                d = b.len - l
                for (e = b.base + b.len - 1; e > b.base + l - 1; e--)
                  g--, this.setitem(g, b.getitem(e))
                b.len -= d
                if (1 >= b.len) return
                g--
                this.setitem(g, a.popright())
                if (0 === a.len) return
                if (c < this.MIN_GALLOP && d < this.MIN_GALLOP) break
                f++
                this.min_gallop = f
              }
            }
        } finally {
          self.Sk.asserts.assert(0 <= a.len && 0 <= b.len)
          for (e = a.base + a.len - 1; e > a.base - 1; e--)
            g--, this.setitem(g, a.getitem(e))
          for (e = b.base + b.len - 1; e > b.base - 1; e--)
            g--, this.setitem(g, b.getitem(e))
        }
      }
      self.Sk.builtin.timSort.prototype.merge_at = function(a) {
        0 > a && (a = this.pending.length + a)
        var b = this.pending[a]
        var c = this.pending[a + 1]
        self.Sk.asserts.assert(0 < b.len && 0 < c.len)
        self.Sk.asserts.assert(b.base + b.len == c.base)
        this.pending[a] = new self.Sk.builtin.listSlice(
          this.list,
          b.base,
          b.len + c.len,
        )
        this.pending.splice(a + 1, 1)
        a = this.gallop(c.getitem(c.base), b, 0, !0)
        b.advance(a)
        0 !== b.len &&
          ((c.len = this.gallop(
            b.getitem(b.base + b.len - 1),
            c,
            c.len - 1,
            !1,
          )),
          0 !== c.len &&
            (b.len <= c.len ? this.merge_lo(b, c) : this.merge_hi(b, c)))
      }
      self.Sk.builtin.timSort.prototype.merge_collapse = function() {
        for (var a = this.pending; 1 < a.length; )
          if (
            3 <= a.length &&
            a[a.length - 3].len <= a[a.length - 2].len + a[a.length - 1].len
          )
            a[a.length - 3].len < a[a.length - 1].len
              ? this.merge_at(-3)
              : this.merge_at(-2)
          else if (a[a.length - 2].len <= a[a.length - 1].len) this.merge_at(-2)
          else break
      }
      self.Sk.builtin.timSort.prototype.merge_force_collapse = function() {
        for (var a = this.pending; 1 < a.length; )
          3 <= a.length && a[a.length - 3].len < a[a.length - 1].len
            ? this.merge_at(-3)
            : this.merge_at(-2)
      }
      self.Sk.builtin.timSort.prototype.merge_compute_minrun = function(a) {
        for (var b = 0; 64 <= a; ) (b |= a & 1), (a >>= 1)
        return a + b
      }
      self.Sk.builtin.listSlice = function(a, b, c) {
        this.list = a
        this.base = b
        this.len = c
      }
      self.Sk.builtin.listSlice.prototype.copyitems = function() {
        var a = this.base,
          b = this.base + this.len
        self.Sk.asserts.assert(0 <= a <= b)
        return new self.Sk.builtin.listSlice(
          new self.Sk.builtin.list(this.list.v.slice(a, b)),
          0,
          this.len,
        )
      }
      self.Sk.builtin.listSlice.prototype.advance = function(a) {
        this.base += a
        this.len -= a
        self.Sk.asserts.assert(this.base <= this.list.sq$length())
      }
      self.Sk.builtin.listSlice.prototype.getitem = function(a) {
        return this.list.v[a]
      }
      self.Sk.builtin.listSlice.prototype.setitem = function(a, b) {
        this.list.v[a] = b
      }
      self.Sk.builtin.listSlice.prototype.popleft = function() {
        var a = this.list.v[this.base]
        this.base++
        this.len--
        return a
      }
      self.Sk.builtin.listSlice.prototype.popright = function() {
        this.len--
        return this.list.v[this.base + this.len]
      }
      self.Sk.builtin.listSlice.prototype.reverse = function() {
        for (
          var a, b, c = this.list, d = this.base, e = d + this.len - 1;
          d < e;

        )
          (a = c.v[e]), (b = c.v[d]), (c.v[d] = a), (c.v[e] = b), d++, e--
      }
      self.Sk.exportSymbol("Sk.builtin.listSlice", self.Sk.builtin.listSlice)
      self.Sk.exportSymbol("Sk.builtin.timSort", self.Sk.builtin.timSort)
    },
    function(m, p) {
      self.Sk.builtin.sorted = function(a, b, c, d) {
        var e
        if (void 0 === d) d = !1
        else {
          if (d instanceof self.Sk.builtin.float_)
            throw new self.Sk.builtin.TypeError("an integer is required, got float")
          if (
            d instanceof self.Sk.builtin.int_ ||
            d.prototype instanceof self.Sk.builtin.int_
          )
            d = self.Sk.misceval.isTrue(d)
          else throw new self.Sk.builtin.TypeError("an integer is required")
        }
        if (void 0 === c || c instanceof self.Sk.builtin.none)
          b instanceof self.Sk.builtin.none || void 0 === b || (e = b),
            (a = new self.Sk.builtin.list(a))
        else {
          e =
            b instanceof self.Sk.builtin.none || void 0 === b
              ? function(a, b) {
                  return self.Sk.misceval.richCompareBool(a[0], b[0], "Lt")
                    ? new self.Sk.builtin.int_(-1)
                    : new self.Sk.builtin.int_(0)
                }
              : function(a, c) {
                  return self.Sk.misceval.callsimArray(b, [a[0], c[0]])
                }
          var f = a.tp$iter()
          var g = f.tp$iternext()
          for (a = []; void 0 !== g; )
            a.push([self.Sk.misceval.callsimArray(c, [g]), g]), (g = f.tp$iternext())
          a = new self.Sk.builtin.list(a)
        }
        void 0 !== e ? a.list_sort_(a, e) : a.list_sort_(a)
        d && a.list_reverse_(a)
        if (void 0 !== c && !(c instanceof self.Sk.builtin.none)) {
          f = a.tp$iter()
          g = f.tp$iternext()
          for (a = []; void 0 !== g; ) a.push(g[1]), (g = f.tp$iternext())
          a = new self.Sk.builtin.list(a)
        }
        return a
      }
    },
    function(m, p) {
      self.Sk.builtin.type_is_subtype_base_chain = function(a, b) {
        do {
          if (a == b) return !0
          a = a.tp$base
        } while (void 0 !== a)
        return b == self.Sk.builtin.object
      }
      self.Sk.builtin.PyType_IsSubtype = function(a, b) {
        var c = a.tp$mro
        if (c) {
          self.Sk.asserts.assert(c instanceof self.Sk.builtin.tuple)
          for (a = 0; a < c.v.length; a++) if (c.v[a] == b) return !0
          return !1
        }
        return self.Sk.builtin.type_is_subtype_base_chain(a, b)
      }
      self.Sk.builtin.super_ = function(a, b) {
        self.Sk.builtin.pyCheckArgsLen("super", arguments.length, 1)
        if (!(this instanceof self.Sk.builtin.super_))
          return new self.Sk.builtin.super_(a, b)
        self.Sk.misceval.callsimArray(self.Sk.builtin.super_.__init__, [this, a, b])
        return this
      }
      self.Sk.builtin.super_.__init__ = new self.Sk.builtin.func(function(a, b, c) {
        a.obj = c
        a.type = b
        if (!b.tp$mro)
          throw new self.Sk.builtin.TypeError(
            "must be type, not " + b.ob$type.tp$name,
          )
        a.obj_type = b.tp$mro.v[1]
        if (!c)
          throw new self.Sk.builtin.NotImplementedError(
            "unbound super not supported because skulpts implementation of type descriptors aren't brilliant yet, see this question for more information https://stackoverflow.com/a/30190341/117242",
          )
        if (!self.Sk.builtin.PyType_IsSubtype(a.obj.ob$type, a.type))
          throw new self.Sk.builtin.TypeError(
            "super(type, obj): obj must be an instance of subtype of type",
          )
        return self.Sk.builtin.none.none$
      })
      self.Sk.abstr.setUpInheritance("super", self.Sk.builtin.super_, self.Sk.builtin.object)
      self.Sk.builtin.super_.prototype.tp$getattr = function(a, b) {
        var c,
          d,
          e = a.$jsstr()
        var f = this.obj_type
        self.Sk.asserts.assert(void 0 !== f, "object has no ob$type!")
        if ((d = this.obj.$d || this.obj.constructor.$d))
          if (
            (d.mp$lookup
              ? (c = d.mp$lookup(a))
              : d.mp$subscript
              ? (c = self.Sk.builtin._tryGetSubscript(d, a))
              : "object" === typeof d && (c = d[e]),
            void 0 !== c)
          )
            return c
        c = self.Sk.builtin.type.typeLookup(f, a)
        if (void 0 !== c && null !== c && (a = c.tp$descr_get))
          return a.call(c, this.obj, this.obj_type, b)
        if (void 0 !== c) return c
      }
      self.Sk.builtin.super_.prototype.$r = function(a) {
        return this.obj
          ? new self.Sk.builtin.str(
              "<super: <class '" +
                (this.type ? this.type.tp$name : "NULL") +
                "'>, <" +
                this.obj.tp$name +
                " object>>",
            )
          : new self.Sk.builtin.str(
              "<super: <class '" +
                (this.type ? this.type.tp$name : "NULL") +
                "'>, NULL>",
            )
      }
      self.Sk.builtin.super_.__doc__ = new self.Sk.builtin.str(
        "super(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type) -> unbound super object\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super(C, self).meth(arg)",
      )
    },
    function(m, p) {
      self.Sk.builtins = {
        range: new self.Sk.builtin.func(self.Sk.builtin.range),
        round: new self.Sk.builtin.func(self.Sk.builtin.round),
        len: new self.Sk.builtin.func(self.Sk.builtin.len),
        min: new self.Sk.builtin.func(self.Sk.builtin.min),
        max: new self.Sk.builtin.func(self.Sk.builtin.max),
        sum: new self.Sk.builtin.func(self.Sk.builtin.sum),
        abs: new self.Sk.builtin.func(self.Sk.builtin.abs),
        fabs: new self.Sk.builtin.func(self.Sk.builtin.fabs),
        ord: new self.Sk.builtin.func(self.Sk.builtin.ord),
        chr: new self.Sk.builtin.func(self.Sk.builtin.chr),
        hex: new self.Sk.builtin.func(self.Sk.builtin.hex),
        oct: new self.Sk.builtin.func(self.Sk.builtin.oct),
        bin: new self.Sk.builtin.func(self.Sk.builtin.bin),
        dir: new self.Sk.builtin.func(self.Sk.builtin.dir),
        repr: new self.Sk.builtin.func(self.Sk.builtin.repr),
        open: new self.Sk.builtin.func(self.Sk.builtin.open),
        isinstance: new self.Sk.builtin.func(self.Sk.builtin.isinstance),
        hash: new self.Sk.builtin.func(self.Sk.builtin.hash),
        getattr: new self.Sk.builtin.func(self.Sk.builtin.getattr),
        hasattr: new self.Sk.builtin.func(self.Sk.builtin.hasattr),
        id: new self.Sk.builtin.func(self.Sk.builtin.id),
        reduce: new self.Sk.builtin.func(self.Sk.builtin.reduce),
        sorted: new self.Sk.builtin.func(self.Sk.builtin.sorted),
        any: new self.Sk.builtin.func(self.Sk.builtin.any),
        all: new self.Sk.builtin.func(self.Sk.builtin.all),
        AttributeError: self.Sk.builtin.AttributeError,
        ValueError: self.Sk.builtin.ValueError,
        Exception: self.Sk.builtin.Exception,
        ZeroDivisionError: self.Sk.builtin.ZeroDivisionError,
        AssertionError: self.Sk.builtin.AssertionError,
        ImportError: self.Sk.builtin.ImportError,
        IndentationError: self.Sk.builtin.IndentationError,
        IndexError: self.Sk.builtin.IndexError,
        KeyError: self.Sk.builtin.KeyError,
        TypeError: self.Sk.builtin.TypeError,
        NameError: self.Sk.builtin.NameError,
        IOError: self.Sk.builtin.IOError,
        NotImplementedError: self.Sk.builtin.NotImplementedError,
        StandardError: self.Sk.builtin.StandardError,
        SystemExit: self.Sk.builtin.SystemExit,
        OverflowError: self.Sk.builtin.OverflowError,
        OperationError: self.Sk.builtin.OperationError,
        NegativePowerError: self.Sk.builtin.NegativePowerError,
        RuntimeError: self.Sk.builtin.RuntimeError,
        StopIteration: self.Sk.builtin.StopIteration,
        float_$rw$: self.Sk.builtin.float_,
        int_$rw$: self.Sk.builtin.int_,
        bool: self.Sk.builtin.bool,
        complex: self.Sk.builtin.complex,
        enumerate: self.Sk.builtin.enumerate,
        dict: self.Sk.builtin.dict,
        file: self.Sk.builtin.file,
        function: self.Sk.builtin.func,
        generator: self.Sk.builtin.generator,
        list: self.Sk.builtin.list,
        long_$rw$: self.Sk.builtin.lng,
        method: self.Sk.builtin.method,
        object: self.Sk.builtin.object,
        slice: self.Sk.builtin.slice,
        str: self.Sk.builtin.str,
        set: self.Sk.builtin.set,
        tuple: self.Sk.builtin.tuple,
        type: self.Sk.builtin.type,
        input: new self.Sk.builtin.func(self.Sk.builtin.input),
        raw_input: new self.Sk.builtin.func(self.Sk.builtin.raw_input),
        setattr: new self.Sk.builtin.func(self.Sk.builtin.setattr),
        jseval: self.Sk.builtin.jseval,
        jsmillis: self.Sk.builtin.jsmillis,
        quit: new self.Sk.builtin.func(self.Sk.builtin.quit),
        exit: new self.Sk.builtin.func(self.Sk.builtin.quit),
        print: self.Sk.builtin.print,
        divmod: new self.Sk.builtin.func(self.Sk.builtin.divmod),
        format: new self.Sk.builtin.func(self.Sk.builtin.format),
        globals: new self.Sk.builtin.func(self.Sk.builtin.globals),
        issubclass: new self.Sk.builtin.func(self.Sk.builtin.issubclass),
        iter: self.Sk.builtin.iter,
        bytearray: self.Sk.builtin.bytearray,
        callable: self.Sk.builtin.callable,
        delattr: self.Sk.builtin.delattr,
        eval_$rn$: self.Sk.builtin.eval_,
        execfile: self.Sk.builtin.execfile,
        frozenset: self.Sk.builtin.frozenset,
        help: self.Sk.builtin.help,
        locals: self.Sk.builtin.locals,
        memoryview: self.Sk.builtin.memoryview,
        next: self.Sk.builtin.next_,
        pow: self.Sk.builtin.pow,
        reload: self.Sk.builtin.reload,
        reversed: self.Sk.builtin.reversed,
        super: self.Sk.builtin.super_,
        unichr: self.Sk.builtin.unichr,
        vars: self.Sk.builtin.vars,
        xrange: self.Sk.builtin.xrange,
        apply_$rn$: self.Sk.builtin.apply_,
        buffer: self.Sk.builtin.buffer,
        coerce: self.Sk.builtin.coerce,
        intern: self.Sk.builtin.intern,
      }
      self.Sk.setupObjects = function(a) {
        a
          ? ((self.Sk.builtins.filter = self.Sk.builtin.filter_),
            (self.Sk.builtins.map = self.Sk.builtin.map_),
            (self.Sk.builtins.zip = self.Sk.builtin.zip_),
            (self.Sk.builtins.range = new self.Sk.builtin.func(self.Sk.builtin.xrange)),
            delete self.Sk.builtins.xrange,
            delete self.Sk.builtins.StandardError)
          : ((self.Sk.builtins.filter = new self.Sk.builtin.func(self.Sk.builtin.filter)),
            (self.Sk.builtins.map = new self.Sk.builtin.func(self.Sk.builtin.map)),
            (self.Sk.builtins.zip = new self.Sk.builtin.func(self.Sk.builtin.zip)),
            (self.Sk.builtins.range = new self.Sk.builtin.func(self.Sk.builtin.range)),
            (self.Sk.builtins.xrange = new self.Sk.builtin.func(self.Sk.builtin.xrange)),
            (self.Sk.builtins.StandardError = self.Sk.builtin.StandardError))
      }
      self.Sk.exportSymbol("Sk.setupObjects", self.Sk.setupObjects)
      self.Sk.exportSymbol("Sk.builtins", self.Sk.builtins)
    },
    function(m, p) {
      self.Sk.builtin.str.$emptystr = new self.Sk.builtin.str("")
      self.Sk.builtin.bool.true$ = Object.create(self.Sk.builtin.bool.prototype, {
        v: { value: 1, enumerable: !0 },
      })
      self.Sk.builtin.bool.false$ = Object.create(self.Sk.builtin.bool.prototype, {
        v: { value: 0, enumerable: !0 },
      })
      self.Sk.builtin.int_.co_varnames = ["number", "base"]
      self.Sk.builtin.int_.$defaults = [0, self.Sk.builtin.none.none$]
      self.Sk.builtin.lng.co_varnames = ["number", "base"]
      self.Sk.builtin.lng.$defaults = [0, self.Sk.builtin.none.none$]
      self.Sk.builtin.sorted.co_varnames = ["list", "cmp", "key", "reverse"]
      self.Sk.builtin.sorted.$defaults = [
        self.Sk.builtin.none.none$,
        self.Sk.builtin.none.none$,
        self.Sk.builtin.bool.false$,
      ]
      self.Sk.builtin.dict.$fromkeys.co_name = new self.Sk.builtin.str("fromkeys")
      self.Sk.builtin.dict.prototype.fromkeys = new self.Sk.builtin.func(
        self.Sk.builtin.dict.$fromkeys,
      )
      self.Sk.builtin.str.$empty = new self.Sk.builtin.str("")
      self.Sk.builtin.str.$default_factory = new self.Sk.builtin.str("default_factory")
      self.Sk.builtin.str.$imag = new self.Sk.builtin.str("imag")
      self.Sk.builtin.str.$real = new self.Sk.builtin.str("real")
      self.Sk.builtin.str.$abs = new self.Sk.builtin.str("__abs__")
      self.Sk.builtin.str.$call = new self.Sk.builtin.str("__call__")
      self.Sk.builtin.str.$cmp = new self.Sk.builtin.str("__cmp__")
      self.Sk.builtin.str.$complex = new self.Sk.builtin.str("__complex__")
      self.Sk.builtin.str.$contains = new self.Sk.builtin.str("__contains__")
      self.Sk.builtin.str.$copy = new self.Sk.builtin.str("__copy__")
      self.Sk.builtin.str.$dict = new self.Sk.builtin.str("__dict__")
      self.Sk.builtin.str.$dir = new self.Sk.builtin.str("__dir__")
      self.Sk.builtin.str.$enter = new self.Sk.builtin.str("__enter__")
      self.Sk.builtin.str.$eq = new self.Sk.builtin.str("__eq__")
      self.Sk.builtin.str.$exit = new self.Sk.builtin.str("__exit__")
      self.Sk.builtin.str.$index = new self.Sk.builtin.str("__index__")
      self.Sk.builtin.str.$init = new self.Sk.builtin.str("__init__")
      self.Sk.builtin.str.$int_ = new self.Sk.builtin.str("__int__")
      self.Sk.builtin.str.$iter = new self.Sk.builtin.str("__iter__")
      self.Sk.builtin.str.$float_ = new self.Sk.builtin.str("__float__")
      self.Sk.builtin.str.$format = new self.Sk.builtin.str("__format__")
      self.Sk.builtin.str.$ge = new self.Sk.builtin.str("__ge__")
      self.Sk.builtin.str.$getattr = new self.Sk.builtin.str("__getattr__")
      self.Sk.builtin.str.$getattribute = new self.Sk.builtin.str("__getattribute__")
      self.Sk.builtin.str.$getitem = new self.Sk.builtin.str("__getitem__")
      self.Sk.builtin.str.$gt = new self.Sk.builtin.str("__gt__")
      self.Sk.builtin.str.$le = new self.Sk.builtin.str("__le__")
      self.Sk.builtin.str.$len = new self.Sk.builtin.str("__len__")
      self.Sk.builtin.str.$lt = new self.Sk.builtin.str("__lt__")
      self.Sk.builtin.str.$name = new self.Sk.builtin.str("__name__")
      self.Sk.builtin.str.$ne = new self.Sk.builtin.str("__ne__")
      self.Sk.builtin.str.$new = new self.Sk.builtin.str("__new__")
      self.Sk.builtin.str.$next2 = new self.Sk.builtin.str("next")
      self.Sk.builtin.str.$next3 = new self.Sk.builtin.str("__next__")
      self.Sk.builtin.str.$path = new self.Sk.builtin.str("__path__")
      self.Sk.builtin.str.$repr = new self.Sk.builtin.str("__repr__")
      self.Sk.builtin.str.$reversed = new self.Sk.builtin.str("__reversed__")
      self.Sk.builtin.str.$round = new self.Sk.builtin.str("__round__")
      self.Sk.builtin.str.$setattr = new self.Sk.builtin.str("__setattr__")
      self.Sk.builtin.str.$setitem = new self.Sk.builtin.str("__setitem__")
      self.Sk.builtin.str.$str = new self.Sk.builtin.str("__str__")
      self.Sk.builtin.str.$trunc = new self.Sk.builtin.str("__trunc__")
      self.Sk.builtin.str.$write = new self.Sk.builtin.str("write")
      self.Sk.misceval.op2method_ = {
        Eq: self.Sk.builtin.str.$eq,
        NotEq: self.Sk.builtin.str.$ne,
        Gt: self.Sk.builtin.str.$gt,
        GtE: self.Sk.builtin.str.$ge,
        Lt: self.Sk.builtin.str.$lt,
        LtE: self.Sk.builtin.str.$le,
      }
      m = "int_ lng sorted range round len min max sum zip abs fabs ord chr hex oct bin dir repr open isinstance hash getattr hasattr id map filter reduce sorted any all input raw_input setattr quit quit divmod format globals issubclass".split(
        " ",
      )
      for (p = 0; p < m.length; p++)
        self.Sk.builtin[m[p]].co_name = new self.Sk.builtin.str(m[p])
    },
    function(m, p) {
      self.Sk.internalPy = {
        files: {
          "src/classmethod.py":
            'class classmethod(object):\n    "Emulate PyClassMethod_Type() in Objects/funcobject.c"\n\n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, obj, klass=None):\n        if klass is None:\n            klass = type(obj)\n        def newfunc(*args):\n            return self.f(klass, *args)\n        return newfunc\n',
          "src/property.py":
            'class property(object):\n    "Emulate PyProperty_Type() in Objects/descrobject.c"\n\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        if doc is None and fget is not None:\n            if hasattr(fget, \'__doc__\'):\n                doc = fget.__doc__\n            else:\n                doc = None\n        self.__doc__ = doc\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if self.fget is None:\n            raise AttributeError("unreadable attribute")\n        return self.fget(obj)\n\n    def __set__(self, obj, value):\n        if self.fset is None:\n            raise AttributeError("can\'t set attribute")\n        self.fset(obj, value)\n\n    def __delete__(self, obj):\n        if self.fdel is None:\n            raise AttributeError("can\'t delete attribute")\n        self.fdel(obj)\n\n    def getter(self, fget):\n        return type(self)(fget, self.fset, self.fdel, self.__doc__)\n\n    def setter(self, fset):\n        return type(self)(self.fget, fset, self.fdel, self.__doc__)\n\n    def deleter(self, fdel):\n        return type(self)(self.fget, self.fset, fdel, self.__doc__)\n',
          "src/staticmethod.py":
            'class staticmethod(object):\n    "Emulate PyStaticMethod_Type() in Objects/funcobject.c"\n\n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, obj, objtype=None):\n        return self.f\n',
        },
      }
    },
  ])
}.call(this || window))

//# sourceMappingURL=skulpt.min.js.map
